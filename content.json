{"meta":{"title":"Biluo","subtitle":"There is nothing permanent except change","description":"","author":"Biluo","url":"http://codebiluo.cn","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-01-19T12:44:36.954Z","updated":"2020-01-19T12:44:36.954Z","comments":true,"path":"404.html","permalink":"http://codebiluo.cn/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-01-27T14:18:27.621Z","updated":"2020-01-27T14:18:27.621Z","comments":true,"path":"about/index.html","permalink":"http://codebiluo.cn/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-19T09:32:34.000Z","updated":"2020-01-22T14:20:28.669Z","comments":true,"path":"tags/index.html","permalink":"http://codebiluo.cn/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-01-19T09:05:44.000Z","updated":"2020-01-22T14:22:02.769Z","comments":true,"path":"categories/index.html","permalink":"http://codebiluo.cn/categories/index.html","excerpt":"","text":""},{"title":"朋友们","date":"2020-01-19T12:02:15.604Z","updated":"2020-01-19T12:02:15.604Z","comments":true,"path":"friends/index.html","permalink":"http://codebiluo.cn/friends/index.html","excerpt":"","text":""},{"title":"link","date":"2020-01-19T07:41:07.000Z","updated":"2020-01-19T07:41:07.248Z","comments":true,"path":"link/index.html","permalink":"http://codebiluo.cn/link/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode-97","slug":"LeetCode-97","date":"2020-01-28T02:41:56.000Z","updated":"2020-01-28T02:42:15.990Z","comments":true,"path":"2020/01/28/LeetCode-97/","link":"","permalink":"http://codebiluo.cn/2020/01/28/LeetCode-97/","excerpt":"","text":"题目分析这个题要求判断两个字符串s1、s2，是否能通过某种方式，将他们的字符任意排列，从而组成字符串s3，也就是题目所说的s1、s2交错组成s3。 思路分析1、暴力法首先想到的是简单的暴力法，对问题进行递归。按字符顺序递归。假设某一层递归s1，s2，s3分别到达下标p1，p2，p3，问题变成分别尝试s3[p3]取s1[p1]和s2[p2]（取的规则是字符要求相同）并继续递归。 1234567891011121314151617181920212223242526class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if (s1.size() + s2.size() != s3.size()) return false; return helper(s1 , 0 , s2 , 0 , s3 , 0); &#125; bool helper(string s1 , int p1 , string s2 , int p2 , string s3 , int p3) &#123; if (p3 == s3.size()) return true; bool flag1 , flag2; flag1 = flag2 = 0; // 用s1[p1]作为s3[p3] if (p1 &lt; s1.size() &amp;&amp; s1[p1] == s3[p3]) flag1 = helper(s1 , p1+1 , s2 , p2 , s3 , p3+1); // 用s2[p2]作为s3[p3] if (p2 &lt; s2.size() &amp;&amp; s2[p2] == s3[p3]) flag2 = helper(s1 , p1 , s2 , p2+1 , s3 , p3+1); if (flag1 == true || flag2 == true) return true; else return false; &#125;&#125;; 时间复杂度：o(2^m * (m-n))（m为s1、s2中长度较长者）注意：由于这个方法是指数爆炸增长的复杂度，cpp代码会超时。 2、动态规划使用二维布尔数组dp用于表示两数组某一位的交错情况：dp[i][j]==1表示s1的前i位和s2的前j位可以交错组成s3的前i+j位。知道dp数组表示的含义，问题也就迎刃而解。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; int len1 = s1.size() , len2 = s2.size() , len3 = s3.size(); if (len1+len2 != len3) return false; vector&lt;vector&lt;bool&gt;&gt; dp(len1+1 , vector&lt;bool&gt;(len2+1 , false)); dp[0][0] = 1; // 初始化第一行 for (int i = 1 ; i &lt;= len2 ; ++i) &#123; if (dp[0][i-1] == true &amp;&amp; s2[i-1] == s3[i-1]) dp[0][i] = true; &#125; // 初始化第一列 for (int i = 1 ; i &lt;= len1 ; ++i) &#123; if (dp[i-1][0] == true &amp;&amp; s1[i-1] == s3[i-1]) dp[i][0] = true; &#125; for (int i = 1 ; i &lt;= len1 ; ++i) &#123; for (int j = 1 ; j &lt;= len2 ; ++j) &#123; if ((dp[i-1][j] == true &amp;&amp; s1[i-1] == s3[i+j-1]) || (dp[i][j-1] == true &amp;&amp; s2[j-1] == s3[i+j-1])) dp[i][j] = true; else dp[i][j] = false; &#125; &#125; // for (int i = 0 ; i &lt; len1 ; ++i) // 显示dp数组 // &#123; // copy(dp[i].begin() , dp[i].end() , ostream_iterator&lt;bool&gt;(cout , \" \")); // cout &lt;&lt; endl; // &#125; return dp[len1][len2]; &#125;&#125;; 时间复杂度：o(m*n)（m，n为s1，s2数组的长度）","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"Django-4","slug":"Django-4","date":"2020-01-27T13:50:46.000Z","updated":"2020-01-27T13:51:05.717Z","comments":true,"path":"2020/01/27/Django-4/","link":"","permalink":"http://codebiluo.cn/2020/01/27/Django-4/","excerpt":"","text":"• 编写一个用于问题显示的表单（form）form是HTML的一个元素，修改polls/detail.html 12345678910&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&#123;% if error_message %&#125;&lt;p&gt;&lt;strong&gt;&#123;&#123; error_message &#125;&#125;&lt;/strong&gt;&lt;/p&gt;&#123;% endif %&#125;&lt;form action=\"&#123;% url 'polls:vote' question.id %&#125;\" method=\"post\"&gt;&#123;% csrf_token %&#125;&#123;% for choice in question.choice_set.all %&#125; &lt;input type=\"radio\" name=\"choice\" id=\"choice&#123;&#123; forloop.counter &#125;&#125;\" value=\"&#123;&#123; choice.id &#125;&#125;\"&gt; &lt;label for=\"choice&#123;&#123; forloop.counter &#125;&#125;\"&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/label&gt;&lt;br&gt;&#123;% endfor %&#125;&lt;input type=\"submit\" value=\"Vote\"&gt;&lt;/form&gt; 这部分涉及HTML相关内容，不再赘述 • 添加投票界面的相关内容添加关于polls/views.py的vote()函数的相关实现： 12345678910111213141516171819202122from django.http import HttpResponse, HttpResponseRedirectfrom django.shortcuts import get_object_or_404, renderfrom django.urls import reversefrom .models import Choice, Question# ...def vote(request, question_id): question = get_object_or_404(Question, pk=question_id) try: selected_choice = question.choice_set.get(pk=request.POST['choice']) except (KeyError, Choice.DoesNotExist): # Redisplay the question voting form. return render(request, 'polls/detail.html', &#123; 'question': question, 'error_message': \"You didn't select a choice.\", &#125;) else: selected_choice.votes += 1 selected_choice.save() # Always return an HttpResponseRedirect after successfully dealing # with POST data. This prevents data from being posted twice if a # user hits the Back button. return HttpResponseRedirect(reverse('polls:results', args=(question.id,))) 相关内容说明：1、request.POST是类似于字典的对象，可让您通过键名访问提交的数据。在这种情况下， request.POST[‘choice’]以字符串形式返回所选选项的ID。request.POST值始终是字符串。 请注意，Django还提供request.GET了以相同方式访问GET数据的方法-但我们request.POST在代码中明确使用，以确保仅通过POST调用更改数据。 2、如果没有提供POST数据，那么就会产生KEYERROR异常，重新显示问题表单。 3、在此示例reverse()中，我们在HttpResponseRedirect构造函数中使用该函数 。此功能有助于避免在视图功能中对URL进行硬编码。它提供了我们想要将控制权传递给的视图的名称，以及指向该视图的URL模式的可变部分。在这种情况下，使用我们在教程3中设置的URLconf ，此reverse()调用将返回一个字符串，例如’/polls/3/results/‘，其中3是的值question.id。然后，此重定向的URL将调用‘results’视图以显示最后一页。 • 投票结果页面相关内容进行投票之后，vote()视图将重定向到该问题的结果页面，故编写视图在views.py： 1234from django.shortcuts import get_object_or_404, renderdef results(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/results.html', &#123;'question': question&#125;) 同时创建polls/results.html模板： 1234567&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&lt;ul&gt;&#123;% for choice in question.choice_set.all %&#125; &lt;li&gt;&#123;&#123; choice.choice_text &#125;&#125; -- &#123;&#123; choice.votes &#125;&#125; vote&#123;&#123; choice.votes|pluralize &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt;&lt;a href=\"&#123;% url 'polls:detail' question.id %&#125;\"&gt;Vote again?&lt;/a&gt; 现在可以运行服务器，来看一看问题页面、投票页面和投票结果显示页面， • 使用通用视图来减少代码量在 detail() 和 results() 的视图函数是非常短并且相似，所以重复的代码是冗余的。这些视图代表了基本Web开发的一种常见情况：根据URL中传递的参数从数据库获取数据，加载模板并返回渲染的模板。因为这很常见，所以Django提供了一个捷径，称为“通用视图”系统。为了转换为通用视图系统，需要经过一些步骤： 1. 转换URLconf。 2. 删除一些旧的不需要的视图。 3. 根据Django的通用视图介绍新视图。 修改URL配置首先对polls/urls.py的URLconf进行修改： 123456789from django.urls import pathfrom . import viewsapp_name = 'polls'urlpatterns = [ path('', views.IndexView.as_view(), name='index'), path('&lt;int:pk&gt;/', views.DetailView.as_view(), name='detail'), path('&lt;int:pk&gt;/results/', views.ResultsView.as_view(), name='results'), path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 修改的是将更改为。 修改视图将polls/views.py修改为： 12345678910111213141516171819from django.http import HttpResponseRedirectfrom django.shortcuts import get_object_or_404, renderfrom django.urls import reversefrom django.views import genericfrom .models import Choice, Questionclass IndexView(generic.ListView): template_name = 'polls/index.html' context_object_name = 'latest_question_list'def get_queryset(self): \"\"\"Return the last five published questions.\"\"\" return Question.objects.order_by('-pub_date')[:5]class DetailView(generic.DetailView): model = Question template_name = 'polls/detail.html'class ResultsView(generic.DetailView): model = Question template_name = 'polls/results.html'def vote(request, question_id): ... # same as above, no changes needed. 在这里使用了两个通用视图ListView和DetailView，分别抽象了“显示对象列表”和“显示特定类型的对象的详细信息页面”的概念。","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"}]},{"title":"LeetCode-95","slug":"LeetCode-95","date":"2020-01-27T13:48:24.000Z","updated":"2020-01-27T13:49:00.842Z","comments":true,"path":"2020/01/27/LeetCode-95/","link":"","permalink":"http://codebiluo.cn/2020/01/27/LeetCode-95/","excerpt":"","text":"一、思路最开始做这道题的时候，我把题目理解成了值为1到n的二叉搜索树有几颗，而不是这些树分别是什么。但这两个问题的关联度较大，问题的关键在于想到：当我们确定了根节点的值是什么，那么他左右子树的取值范围就已经很明确了。若根节点的取值是在[left , right]中的一个值k，由二叉搜索树的定义可知，左子树的值在[left , k-1]，右子树的值在[k+1 , right]。假设我们已经求出左右子树（注意求出的应该是一组树，而不是一个树），所以我们用两重循环遍历所有左右子树搭配的可能，也就求出根节点值为k、取值范围在[left , right]间的所有树，遍历即可求出值为[left , right]的所有树。这样问题就形成了递归，自然也就解决。 二、注意：在最开始的时候，我将helper()（代码中的函数）的返回值设置成void，虽然想到根节点确定，左右子树范围确定这一点，但是一直不知道该怎么转换成代码。（当时冒出的想法是，一棵树如果已经完整（有n个节点），那么就将他push_back到结果中，但是没有实现） 三、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if (n == 0) &#123; vector&lt;TreeNode*&gt; ans; return ans; &#125; return helper(1 , n); &#125; vector&lt;TreeNode*&gt; helper(int left , int right) &#123; vector&lt;TreeNode*&gt; ans; if (left &gt; right) &#123; ans.push_back(NULL); return ans; &#125; for (int i = left ; i &lt;= right ; ++i) &#123; vector&lt;TreeNode*&gt; leftTrees = helper(left , i-1); vector&lt;TreeNode*&gt; rightTrees = helper(i+1 , right); for (auto leftTree : leftTrees) &#123; for (auto rightTree : rightTrees) &#123; TreeNode* root = new TreeNode(i); root-&gt;left = leftTree; root-&gt;right = rightTree; ans.push_back(root); &#125; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-92","slug":"LeetCode-92","date":"2020-01-26T04:38:42.000Z","updated":"2020-01-27T13:35:23.135Z","comments":true,"path":"2020/01/26/LeetCode-92/","link":"","permalink":"http://codebiluo.cn/2020/01/26/LeetCode-92/","excerpt":"","text":"一、解题思路这个问题其实等同于反转链表，只是将问题变成了子链表。在反转链表的时候，是引入了prev，scan，next三个指针，分别表示当前节点的前一个节点，当前节点，当前节点的后一个节点。遍历的过程只需要将scan-&gt;next赋值为prev。最后处理头节点即可。回到这个问题，其实就是在反转m至n号节点，将最后处理头节点的过程变成处理这一段链表两端节点。 二、具体流程首先需要先找到第m个节点，然后反转m至n号节点，然后将m号节点的next指针指向第n+1号节点，再将m-1号节点的next指针指向m-1号节点。 三、重点问题在处理的过程中会有这么几个问题：eg：1-&gt;2-&gt;3-&gt;4-&gt;NULL1、考虑m=1，n=2的情况，这种情况导致m-1号节点为空，如果直接对给定链表操作，会导致代码中不断地在考虑特殊情况，所以我们添加哨位节点，这样代码实现的难度直线下降。2、考虑m=3，n=4的情况，这种情况会在next进行迭代的时候出现空指针访问的情况。所以在迭代的时候需要充分考虑空指针。 四、代码12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; ListNode *prev , *scan , *next; ListNode *tem = new ListNode(0); tem-&gt;next = head; head = tem; //添加一个哨位节点 // 遍历找第m个节点 scan = head; for (int i = 1 ; i &lt; m ; ++i) scan = scan-&gt;next; ListNode *m_1Node = scan; ListNode *mNode = scan-&gt;next; // 反转m至n号节点 prev = mNode; scan = mNode-&gt;next; next = mNode-&gt;next==NULL?NULL:mNode-&gt;next-&gt;next; //考虑翻转最后一个节点的可能 for (int i = m ; i &lt; n ; ++i) &#123; scan-&gt;next = prev; prev = scan; scan = next; next = next==NULL?NULL:next-&gt;next; // 考虑n号节点之后再没有节点 &#125; // 连接两端 m_1Node-&gt;next = prev; mNode-&gt;next = scan; return head-&gt;next; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-3","slug":"LeetCode-3","date":"2020-01-26T03:39:48.000Z","updated":"2020-01-26T03:52:36.207Z","comments":true,"path":"2020/01/26/LeetCode-3/","link":"","permalink":"http://codebiluo.cn/2020/01/26/LeetCode-3/","excerpt":"","text":"一、子问题解决这道题之前，可以先思考一个重要的问题，就是给定的一段字符串，如何判断它是否有重复的字符。法一、容易想到的是遍历每一个字符，判断在它之后是否出现相同字符，时间复杂度o(n^2)。法二、同LeetCode-1，用哈希表进行搜索加速：维护一个数组作为哈希表，初始化为0。遍历字符串，并将每个字符对应位置（eg：‘f’-‘a’ = 5，‘f’对应下标为5）置为1，如果该位置已经置1，那么就说明出现重复字符。这个方法只需要一次遍历，时间复杂度o(n)。 二、问题思路解决子问题之后，我们知道可以用哈希表来进行加速。维护一个数组作为哈希表，初始化内容为-1（不初始化为0是因为之后哈希表中保存的会是字符下标），遍历整个字符串，将每一个字符对应位置保存当前字符的下标。遍历至下标n处，如果该位置对应哈希表内容为m（m != -1），则说明 [m,n) 是无重复字符子串，[m,n]会出现重复字符。计算当前无重复子串长度后，保存较大者。之后重置哈希表，再进行之后字符串的遍历。这个方法也就是官方题解中的优化滑动窗口。 三、代码1234567891011121314151617181920212223242526272829303132int lengthOfLongestSubstring(char * s)&#123; int from , to; //当前最长子串起止下标 from = to = 0; int ans = 0; int hash[256]; //每个字符的键值对 memset(hash , -1 , sizeof(hash)); while (s[to] != '\\0') &#123; if (hash[s[to]] == -1) &#123; hash[s[to]] = to; to++; &#125; else if (hash[s[to]] &lt; from) //重复的不是当前最长子串 &#123; hash[s[to]] = to; to++; &#125; else //当前最长子串出现重复，更新from的值为重复字符（前面的那个）位置加1 &#123; ans = ans &gt; (to - from) ? ans : (to - from); from = hash[s[to]] + 1; hash[s[to]] = to; to++; &#125; &#125; ans = ans &gt; (to - from) ? ans : (to - from); return ans;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-2","slug":"LeetCode-2","date":"2020-01-23T02:54:44.000Z","updated":"2020-01-26T03:34:57.997Z","comments":true,"path":"2020/01/23/LeetCode-2/","link":"","permalink":"http://codebiluo.cn/2020/01/23/LeetCode-2/","excerpt":"","text":"一次遍历这个问题主要考察的是链表的操作和出现特殊情况的处理。1、当两个链表一样长的时候，问题比较好处理，直接挨个相加即可；2、当两个链表不一样的时候，就需要对遍历节点进行判断，不能出现再访问属性val的语句；3、由于一条链有可能为空这种极端情况，所以不能简单的采用原地算法；4、问题有一个小坑，就是有可能最后还有一位进位，对这个情况要考虑在内；5、可以通过添加一个哑节点来减少代码； 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *scan1 = l1; ListNode *scan2 = l2; ListNode *head = new ListNode(0); //这是哑节点 ListNode *scan = head; int flag = 0; //标记进位 while (1) &#123; if (scan1 == NULL &amp;&amp; scan2 == NULL) break; int n1 = scan1!=NULL?scan1-&gt;val:0; int n2 = scan2!=NULL?scan2-&gt;val:0; scan-&gt;next = new ListNode((n1+n2+flag)%10); flag = (n1+n2+flag)/10; if (scan1 != NULL) scan1 = scan1-&gt;next; if (scan2 != NULL) scan2 = scan2-&gt;next; scan = scan-&gt;next; &#125; if (flag) //如果最后还有进位 scan-&gt;next = new ListNode(1); return head-&gt;next; &#125;&#125;; 时间复杂度：O(MAX{m,n})空间复杂度：O(MAX{m,n})","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-1","slug":"LeetCode-1","date":"2020-01-23T02:30:11.000Z","updated":"2020-01-23T02:30:55.329Z","comments":true,"path":"2020/01/23/LeetCode-1/","link":"","permalink":"http://codebiluo.cn/2020/01/23/LeetCode-1/","excerpt":"","text":"问题可以转换为，已有一个ele（为数组中的任意元素），需要在数组中寻找另一个元素等于target-ele 1、暴力遍历法最直观的想法遍历每一个元素，再对该元素进行遍历，查看是否有满足条件的其他元素，使得他们两的加和为target。 1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for (int i = 0 ; i &lt; nums.size() ; ++i) &#123; for (int j = i+1 ; j &lt; nums.size() ; ++j) &#123; if (nums[i]+nums[j] == target) return &#123;i , j&#125;; &#125; &#125; return &#123;-1 , -1&#125;; &#125;&#125;; 时间复杂度：O(n^2)空间复杂度：O(1) 2、一遍hash这个方法的想法主要是利用哈希表来进行查找加速。遍历数组元素ele，将ele放入哈希表中（ele值作为外键，ele下标作为內键），同时判断target-ele是否在哈希表中：如果在，那么搜索结束，直接返回；如果不在，继续遍历，直到结尾； 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; m; for (int i = 0 ; i &lt; nums.size() ; ++i) &#123; if (m.count(target-nums[i]) == 1) &#123; return &#123;m[target-nums[i]] , i&#125;; &#125; m[nums[i]] = i; &#125; return &#123;-1, -1&#125;; &#125;&#125;; 时间复杂度：O(n)空间复杂度：O(n)","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"Django-3","slug":"Django-3","date":"2020-01-22T11:46:05.000Z","updated":"2020-01-22T14:11:18.794Z","comments":true,"path":"2020/01/22/Django-3/","link":"","permalink":"http://codebiluo.cn/2020/01/22/Django-3/","excerpt":"","text":"• 视图视图其实是视图函数的简称，视图是Django应用程序中网页的“类型”，通常具有特定功能并具有特定模板。在Django中，网页和其他内容是通过视图传递的。每个视图均由Python函数（或方法（对于基于类的视图而言））表示。Django将通过检查所请求的URL（准确地说，是域名之后的URL部分）来选择视图。 • URLURL即统一资源定位符，是每一个信息资源都有统一的且在网上唯一的地址。URLconfs即URL模式，是URL的一般形式Django提供了更加优雅的URL模式，例如： 1/newsarchive/&lt;year&gt;/&lt;month&gt;/ • 添加更多的视图更改views.py： 1234567def detail(request, question_id): return HttpResponse(\"You're looking at question %s.\" % question_id)def results(request, question_id): response = \"You're looking at the results of question %s.\" return HttpResponse(response % question_id)def vote(request, question_id): return HttpResponse(\"You're voting on question %s.\" % question_id) 并更改polls.urls.py： 123456789101112from django.urls import pathfrom . import viewsurlpatterns = [ # ex: /polls/ path('', views.index, name='index'), # ex: /polls/5/ path('&lt;int:question_id&gt;/', views.detail, name='detail'), # ex: /polls/5/results/ path('&lt;int:question_id&gt;/results/', views.results, name='results'), # ex: /polls/5/vote/ path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 根据输入的URL地址，通过遍历的方式寻找匹配的URL模式串，并调用相对应的视图函数，相应相对应的网页。比如说，当有人从网站请求页面时，例如“ / polls / 34 /”，Django将加载mysite.urls的Python模块，因为该ROOT_URLCONF设置指向该模块 。它找到名为的变量urlpatterns并按顺序遍历模式。在找到匹配项之后’polls/‘，它将剥离匹配的文本（”polls/“），并将其余文本–发送 “34/“到’polls.urls’URLconf进行进一步处理。在那里匹配’int:question_id/‘，从而导致对detail()视图的调用，如下所示：detail(request=, question_id=34) • 编写更强大的视图每个视图负责执行以下两项操作之一：返回HttpResponse包含所请求页面内容的对象，或者引发诸如之类的异常Http404。HttpResponse需要自己对其进行填充，而HttpRequest是Django自己生成。视图可以从数据库中读取记录，也可以使用Django等模板系统，也可以不使用第三方Python模板系统。它还可以使用所需的任何Python库生成PDF文件，输出XML，或即时创建ZIP文件。在view.py添加代码： 123456from .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] output = ', '.join([q.question_text for q in latest_question_list]) return HttpResponse(output) # Leave the rest of the views (detail, results, vote) unchanged • 将模板与视图创建的硬编码分开首先，在目录templates中创建一个polls目录。Django将在那里寻找模板。您的项目TEMPLATES置描述了Django如何加载和呈现模板。默认设置文件配置一个DjangoTemplates 后端，其APP_DIRS选项设置为 True。按照惯例DjangoTemplates，在每个文件夹中都会寻找一个“模板”子目录INSTALLED_APPS。在polls/templates/polls/添加一个模板： 123456789&#123;% if latest_question_list %&#125; &lt;ul&gt; &#123;% for question in latest_question_list %&#125; &lt;li&gt;&lt;a href=\"/polls/&#123;&#123; question.id &#125;&#125;/\"&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&#123;% else %&#125; &lt;p&gt;No polls are available.&lt;/p&gt;&#123;% endif %&#125; 现在运行服务器之后，可以子项/polls来加载一个“最新消息”列表。 • 快捷方式加载模板，填充上下文并使用渲染后的模板的结果返回对象HttpResponse是一种非常常见的用法。同时，Django提供了一种快捷方式。重写index()： 123456from django.shortcuts import renderfrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] context = &#123;'latest_question_list': latest_question_list&#125; return render(request, 'polls/index.html', context) 该render()函数将请求对象作为其第一个参数，将模板名称作为其第二个参数，并将字典作为其可选的第三个参数。它返回使用HttpResponse 给定上下文呈现的给定模板的对象。 • 404错误在views.py中添加代码： 12345678910from django.http import Http404from django.shortcuts import renderfrom .models import Question# ...def detail(request, question_id): try: question = Question.objects.get(pk=question_id) except Question.DoesNotExist: raise Http404(\"Question does not exist\") return render(request, 'polls/detail.html', &#123;'question': question&#125;) 为了快速使示例正常工作，对应模板polls/templates/polls/detail.html中只添加： 1&#123;&#123; question &#125;&#125; 现在运行服务器，可以看到更完整的polls网页 • 404的快捷方式重写detail()函数： 1234567from django.shortcuts import get_object_or_404, renderfrom .models import Question# ...def detail(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/detail.html', &#123;'question': question&#125;) • 使用模板系统polls/detail.html改写为： 123456&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&lt;ul&gt;&#123;% for choice in question.choice_set.all %&#125; &lt;li&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 模板系统使用点查找语法来访问变量属性。在的示例中，首先Django在对象上进行字典查找。如果失败，它将尝试属性查找-在这种情况下可以工作。如果属性查找失败，它将尝试进行列表索引查找。 • 命名空间URL名称在实际的Django项目中，可能有很多个应用程序，Django如何区分它们之间的URL名称呢？答案是将名称空间添加到URLconf中。在polls/urls.py中添加app_name以设置为应用程序名称空间： 123456789from django.urls import patfrom . import viewsapp_name = 'polls'urlpatterns = [ path('', views.index, name='index'), path('&lt;int:question_id&gt;/', views.detail, name='detail'), path('&lt;int:question_id&gt;/results/', views.results, name='results'), path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 这样可以区分多个应用程序的URL名称。","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"}]},{"title":"Django-2","slug":"Django-2","date":"2020-01-19T12:37:53.000Z","updated":"2020-01-22T11:46:23.853Z","comments":true,"path":"2020/01/19/Django-2/","link":"","permalink":"http://codebiluo.cn/2020/01/19/Django-2/","excerpt":"","text":"• 数据库设置默认使用SQLite，相关的设置都在setting.py文件中进行。 setting,py中还有其他设置：INSTALLED_APPS文件顶部的设置。该名称包含在此Django实例中激活的所有Django应用程序的名称。其中包含一些默认的应用程序。不需要时可以在INSTALLED_APPS中删去。 1python manage.py migrate 该migrate命令将查看该INSTALLED_APPS设置，并根据mysite/settings.py文件中的数据库设置以及应用程序随附的数据库迁移来创建任何必要的数据库表。 • 创建模型模型是相关数据的唯一、确定的事实来源。它包含要存储数据的基本字段和行为。也就是一个包含各种属性（数据）和方法（行为）的类。比如说：在民意调查应用中，我们将创建两个模型：Question和Choice。Question有一个问题和出版日期。Choice有两个字段：选择的文本和投票提示。每个Choice都与关联Question。 在polls/models.py文件中添加代码 12345678from django.db import modelsclass Question(models.Model): question_text &#x3D; models.CharField(max_length&#x3D;200) pub_date &#x3D; models.DateTimeField(&#39;date published&#39;)class Choice(models.Model): question &#x3D; models.ForeignKey(Question, on_delete&#x3D;models.CASCADE) choice_text &#x3D; models.CharField(max_length&#x3D;200) votes &#x3D; models.IntegerField(default&#x3D;0) 在这里，==每个模型都是django.db.models.Model的子类==。每个模型都有许多类变量，每个类变量代表模型中的数据库字段。==每一个字段都是一个Field的实例==，不同的Field代表了不同类型的数据。 • 激活模型为了包含应用，需要将应用的引用添加在设置的INSTALLED_APPS中，也就是将polls.apps.PollsConfig添加到INSTALLED_APPS中 123456789INSTALLED_APPS &#x3D; [ &#39;polls.apps.PollsConfig&#39;, &#39;django.contrib.admin&#39;, &#39;django.contrib.auth&#39;, &#39;django.contrib.contenttypes&#39;, &#39;django.contrib.sessions&#39;, &#39;django.contrib.messages&#39;, &#39;django.contrib.staticfiles&#39;,] 1python manage.py makemigrations polls 表示对模型进行了一些修改，称之为迁移（migration），会生成一个polls/migrations/0001_initial.py文件，可以进行人工编辑。 1python manage.py sqlmigrate polls 0001 可以看到SQL中，进行了那些迁移操作。 注：1、数据表的名称是将应用名称和模型名称的小写组合起来自动生成的；2、Django将附加”_id”到外键字段名称。3、该sqlmigrate命令==实际上并未在数据库上运行迁移-而是将其打印到屏幕上==，以便您可以查看SQL Django认为需要的内容。这对于检查Django将要执行的操作或是否有需要SQL脚本进行更改的数据库管理员很有用。 1python manage.py check 检查项目中是否存在任何问题，而无需进行迁移或接触数据库 1python manage.py migrate 获取所有尚未应用的迁移，并针对数据库来运行它们，实际上就是根据之前的修改来改变数据库。 模型更改的三步： • 更改模型（在models.py中）。 • 运行为这些更改创建迁移 python manage.py makemigrations • 运行以将那些更改应用到数据库 python manage.py migrate Django Admin介绍admin是作为网站管理员存在 • 创建管理员用户1python manage.py createsuperuser 之后按提示信息输入内容（在输入密码的时候，可能会有密码无回显的情况，只需正常输入，不会有其他影响，我的环境是Python3.8+Django3.0） 然后运行服务器，输入http://127.0.0.1:8000/admin/会显示管理员登录界面： 注意这里输入的不是，这个网页出现的会是错误页面：修改polls/admin.py之后，应用就可以出现在管理员页面上。 123from django.contrib import adminfrom .models import Questionadmin.site.register(Question) 之后可以通过管理员界面对Question数据库进行修改。","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"}]},{"title":"Django-1","slug":"Django-1","date":"2020-01-19T09:39:15.000Z","updated":"2020-01-19T12:59:47.525Z","comments":true,"path":"2020/01/19/Django-1/","link":"","permalink":"http://codebiluo.cn/2020/01/19/Django-1/","excerpt":"","text":"• 创建项目1django-admin startproject mysite 创建了mysite目录： 12345678mysite&#x2F; manage.py #一个命令行实用程序，可让您以各种方式与该Django项目进行交互。 mysite&#x2F; __init__.py settings.py #此Django项目的设置&#x2F;配置。 urls.py #此Django项目的URL声明；Django支持的网站的“目录”。 asgi.py wsgi.py • 运行服务器1Python manage.py runserver 在浏览器中搜索http://127.0.0.1:8000/，就能看到Django火箭： • 创建应用程序（polls应用）项目和应用之间有什么区别？应用程序是执行某项操作的Web应用程序，例如Weblog系统，公共记录数据库或小型民意调查应用程序。项目是特定网站的配置和应用程序的集合。一个项目可以包含多个应用程序。一个应用程序可以在多个项目中。 1python manage.py startapp polls 创建了polls目录 123456789polls&#x2F; __init__.py admin.py apps.py migrations&#x2F; __init__.py models.py tests.py views.py • 第一个视图函数每一个请求的url地址，都对应着一个函数，叫视图函数，由视图函数处理请求后，再返回页面内容给浏览器显示。在polls/views.py中添加代码 1234from django.http import HttpResponsedef index(request): Return HttpResponse(&quot;Hello,world.You&#39;reatthepollsindex.&quot;) • 创建URL关系polls目录中创建URLconf，即创建一个urls.py文件，包含如下代码 1234567from django.urls import pathfrom . import viewsurlpatterns&#x3D;[path(&#39;&#39;, views.index, name&#x3D;&#39;index&#39;),] 在项目之下的urls.py文件（mysite/urls.py）中加入代码 1234567from django.contrib import adminfrom django.urls import include,pathurlpatterns&#x3D;[path(&#39;polls&#x2F;&#39;,include(&#39;polls.urls&#39;)),path(&#39;admin&#x2F;&#39;,admin.site.urls),] 重点：项目和应用之下urls.py文件的不同 123456# 项目下的urls.pyurlpatterns &#x3D; [ ... # 包含应用下的urls.py文件 url(正则表达式, include(&#39;应用名.urls&#39;))] 123456789101112131415# 应用下的urls.pyurlpatterns &#x3D; [ # 该path()函数传递了四个参数，两个是必需的 route和view， # 以及两个可选的kwargs和name。 path(route , view , kwargs , name), # route：route是包含URL模式的字符串。在处理请求时， # Django从第一个模式开始，urlpatterns然后沿列表向下移动， # 将请求的URL与每个模式进行比较，直到找到匹配的URL。 # view：当Django找到匹配的模式时，使用HttpRequest对象作为第一个参数， # 并将路线中所有“捕获的”值作为关键字参数，调用指定的view函数。 # name：命名URL可以使您在Django中的其他地方（尤其是在模板内部） # 明确地引用它。这项强大的功能可让您仅触摸单个文件 # 即可对项目的URL模式进行全局更改。]","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"}]}]}