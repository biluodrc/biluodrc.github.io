{"meta":{"title":"Biluo","subtitle":"There is nothing permanent except change","description":"","author":"Biluo","url":"http://codebiluo.cn","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-01-19T12:44:36.954Z","updated":"2020-01-19T12:44:36.954Z","comments":true,"path":"404.html","permalink":"http://codebiluo.cn/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"毕罗不是我的名字！","date":"2020-02-06T06:54:21.927Z","updated":"2020-02-06T06:54:21.927Z","comments":true,"path":"about/index.html","permalink":"http://codebiluo.cn/about/index.html","excerpt":"","text":"There‘s nothing permanent except CHANGE! 我是一个爱电影的成长期程序员，这里是我自己搭建的博客（用的是hexo+主题Material-X）。我会在这里分享技术、发布题解（然而我并不是ACM大佬，目前发布的都是一些LeetCode的题解），我还会聊一聊电影，写一些影评。望有缘人能有所收获，找到自己！！！ 技术只是手段，兴趣才会带来改变，希望探索各种新鲜的事物（不仅只是技术哦）能成为各位永恒的兴趣。"},{"title":"tags","date":"2020-01-19T09:32:34.000Z","updated":"2020-01-22T14:20:28.669Z","comments":true,"path":"tags/index.html","permalink":"http://codebiluo.cn/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-01-19T09:05:44.000Z","updated":"2020-01-22T14:22:02.769Z","comments":true,"path":"categories/index.html","permalink":"http://codebiluo.cn/categories/index.html","excerpt":"","text":""},{"title":"朋友们","date":"2020-02-05T11:20:14.342Z","updated":"2020-02-05T11:20:14.342Z","comments":true,"path":"friends/index.html","permalink":"http://codebiluo.cn/friends/index.html","excerpt":"","text":""},{"title":"link","date":"2020-01-19T07:41:07.000Z","updated":"2020-01-19T07:41:07.248Z","comments":true,"path":"link/index.html","permalink":"http://codebiluo.cn/link/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode-115","slug":"LeetCode-115","date":"2020-02-10T12:44:29.000Z","updated":"2020-02-10T12:45:02.855Z","comments":true,"path":"2020/02/10/LeetCode-115/","link":"","permalink":"http://codebiluo.cn/2020/02/10/LeetCode-115/","excerpt":"","text":"一、心路历程这道题是有关字符串的问题，与之前字符串匹配的问题不同，它要求的不是子串匹配，也不是模式串匹配，而是序列匹配。问题发生了变化，但不变的思路是：暴力！暴力就完了！ ，这道题如果使用暴力法可就真的“完了”。暴力法是使用类似bfs的思路，每一层递归遍历两个字符串，当某一位字符相同时，就递归到下一层，判断这一位之后的子串的匹配情况，当递归到 t字符串尾时，就将匹配方案数加一。还可以有剪枝的操作：如果 s字符串子串的长度比 t字符串子串的长度还要小，那就说明不可能完成匹配，所以直接返回到上一层即可。但是这个方法的时间复杂度爆炸，是指数级别。然后就没有AC。这时候就会想到总会在关键时刻拯救我们的动态规划。想到这，我以为只要写出状态转移方程不就好了吗！但是，现在我的问题又变成了：写不出状态转移方程/(ㄒoㄒ)/~~，然后还是看了题解。。。在主要思路之后我会说到我在写这个问题时对写状态转移方程时产生的灵感。 二、主要思路第一步：完成状态转移方程之前很关键的一步，就是明确 dp[i][j] 到底表示的是什么。这个问题中表示的是 t 的前 i+1 个字符和 s 的前 j+1 个字符有dp[i][j]种匹配方案。第二步：状态转移方程： 当 s[j] != t[i] 时：dp[i][j] = dp[i][j-1] 这里表示的是，反正 s[j] 和 t[i] 都不一样，那么我就不要 s[j]，用 t 的前 i+1个字符去匹配 s 的前 j 个字符，故赋值为dp[i][j-1] 当 s[j] == t[i] 时：dp[i][j] = dp[i][j-1]+dp[i-1][j-1] 这里表示的是两种情况1、用到 s[j] ，也就是用 t 的前 i+1 个字符去匹配 s 的前 j+1个字符，方案的数目等于用 t 的前 i 个字符去匹配 s 的前 j 个字符，也就是dp[i-1][j-1]；2、不用 s[j] ，这时就变成了用 t 的前 i+1个字符去匹配 s 的前 j 个字符，也就是dp[i][j-1]； 这个状态转移方程其实并不是显而易见的，对这个方程的解释，也是我在做完题之后才能够叙述的。但是最关键的还是掌握 dp[i][j] 指的是什么。我产生的灵感也就是来源于此：写出一个一般性的例子，将 dp 这个二维数组画出来，自己去填每一个空，然后找 dp[i][j]、dp[i-1][j-1]、dp[i][j-1]、dp[i-1][j] 之间的关系，找到后看是否能对其进行解释。这种方法可能就是取巧，但是可以做题的方法了。 三、代码123456789101112131415161718192021222324// 动态规划class Solution &#123;public: int numDistinct(string s, string t) &#123; int lenS = s.size(); int lenT = t.size(); vector&lt;vector&lt;long long&gt;&gt; dp(t.size()+1 , vector&lt;long long&gt;(s.size()+1,0)); // 行列数各加一是为了添加空字符串匹配的dp[0][0] // 初始化dp数组 for (int i = 0 ; i &lt;= lenS ; ++i) dp[0][i] = 1; for (int i = 1 ; i &lt;= lenT ; ++i) for (int j = 1 ; j &lt;= lenS ; ++j) &#123; if (t[i-1] == s[j-1]) dp[i][j] = dp[i][j-1]+dp[i-1][j-1]; else dp[i][j] = dp[i][j-1]; &#125; return dp[lenT][lenS]; &#125;&#125;; 时间复杂度：o(m*n)（m、n分别为s、t字符串的长度） 123456789101112131415161718192021222324252627// 暴力法——没有ACclass Solution &#123;public: int numDistinct(string s, string t) &#123; int ans = 0; helper(s , 0 , t , 0 , ans); return ans; &#125; void helper(string s , int indS , string t , int indT , int &amp;ans) &#123; int lenS = s.size(); int lenT = t.size(); if (indT == lenT) &#123; ans++; return; &#125; for (int i = indS ; i &lt; lenS ; ++i) &#123; if (lenS-i &lt; lenT-indT) break; if (s[i] == t[indT]) helper(s , i+1 , t , indT+1 , ans); &#125; &#125;&#125;; 时间复杂度：o(2^n)（我的想法是s字符串中每一个字符都有选择与不选两种情况，组合起来就是指数级别）","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-108-109 对链表的二分方法","slug":"LeetCode-108-109","date":"2020-02-08T14:46:03.000Z","updated":"2020-02-08T14:49:33.061Z","comments":true,"path":"2020/02/08/LeetCode-108-109/","link":"","permalink":"http://codebiluo.cn/2020/02/08/LeetCode-108-109/","excerpt":"","text":"一、思路这两道题都是要求将线性表转换成二叉搜索树，数组转化为二叉搜索树是很简单的，使用标准的二分法即可，不再赘述，之后附上代码。重点的问题是如何将链表转化为二叉搜索树（这里就不谈将链表转为数组这种只为AC的方法了）。由于不能用下标来访问链表，所以单纯地用数组转树的二分法是不合理的。那么不使用下标，该如何访问链表中点处的节点呢？方法是用快指针和慢指针来查找中点处的节点：快指针每次移动两个节点，慢指针每次移动一个节点，当快指针访问到链尾的时候，慢指针正好指的位置就是中点处的节点。 Over！ 二、代码123456789101112131415161718// 108题代码class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return helper(nums , 0 , nums.size()); &#125; TreeNode* helper(vector&lt;int&gt; &amp;nums , int left , int right) &#123; if (left &gt;= right) return NULL; int mid = (left+right)/2; TreeNode* node = new TreeNode(nums[mid]); node-&gt;left = helper(nums , left , mid); node-&gt;right = helper(nums , mid+1 , right); return node; &#125;&#125;; 12345678910111213141516171819202122232425262728// 109题代码class Solution &#123;public: TreeNode* sortedListToBST(ListNode* head) &#123; if (head == NULL) return NULL; return helper(head , NULL); &#125; TreeNode* helper(ListNode *left , ListNode *right) // 表示一种左闭右开 &#123; if (left == right) return NULL; ListNode *slow , *fast; slow = fast = left; while (1) &#123; if (fast == right || fast-&gt;next == right) break; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; TreeNode *ans = new TreeNode(slow-&gt;val); ans-&gt;left = helper(left , slow); ans-&gt;right = helper(slow-&gt;next , right); return ans; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-51-52 经典回溯问题","slug":"LeetCode-51-52","date":"2020-02-08T06:51:13.000Z","updated":"2020-02-10T12:45:09.166Z","comments":true,"path":"2020/02/08/LeetCode-51-52/","link":"","permalink":"http://codebiluo.cn/2020/02/08/LeetCode-51-52/","excerpt":"","text":"一、思路N皇后问题可以说是最经典的回溯问题，经典到刚接触C语言的时候，就有讲到这个问题。现在重新看这个问题，就会比较熟练：问题是在模拟摆放皇后，使他们满足皇后之间不可互相攻击这个条件。 国际象棋中，皇后可以横、直、斜着走，步数不受限制，但不能越子。如对国际象棋感兴趣可以自己在 https://lichess.org/ 这个网站上自己玩。 如果将棋盘分成行、列、斜三种情况（斜这种情况其实还包含了45°和-45°两种），那么就需要我们对已经存在皇后的行、列、斜进行标记，标记的方法再好不过就是对他们编号，然后某一个位置有皇后之后，就将其对应行、列、斜编号的位置置为1（表示这些行、列、斜已经放置过皇后，不应该再放），用于之后新皇后是否能放在某个位置的判断。行列的编号很简单，重点是在斜的情况编号，我使用的是找到他们行列号与斜编号的关系。易知，一个方向的斜应该有2N-1个，我是假想了一种映射，将同一个斜上的所有皇后，都映射到行号为0或者是列号为零的行、列上。图示如下： 下面就是找规律的游戏，最终我得到的斜编号与行列编号之间的关系是：*45°斜编号 = c+r; -45°斜编号 = n+r-c;（r为行编号，c为列编号，n为棋盘大小）** 二、代码123456789101112131415161718192021222324252627282930313233343536373839// 51题代码class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt; vector&lt;string&gt; &gt; ans; vector&lt;bool&gt; flagR(n , 0); vector&lt;bool&gt; flagX1(2*n , 0); vector&lt;bool&gt; flagX2(2*n , 0); vector&lt;string&gt; tem(n , string(n , '.')); helper(ans , tem , 0 , n , flagR , flagX1 , flagX2); return ans; &#125; void helper(vector&lt;vector&lt;string&gt;&gt; &amp;ans , vector&lt;string&gt; tem , int c , int n , vector&lt;bool&gt; &amp;flagR , vector&lt;bool&gt; &amp;flagX1 , vector&lt;bool&gt; &amp;flagX2) &#123; if (c == n) // 递归终点，所有列都遍历完了 &#123; ans.push_back(tem); return; &#125; for (int r = 0 ; r &lt; n ; ++r) // 遍历行号 &#123; int x1 = c+r; int x2 = n+r-c; if (flagR[r] == 0 &amp;&amp; flagX1[x1] == 0 &amp;&amp; flagX2[x2] == 0) &#123; flagR[r] = flagX1[x1] = flagX2[x2] = 1; tem[r][c] = 'Q'; helper(ans , tem , c+1 , n , flagR , flagX1 , flagX2); flagR[r] = flagX1[x1] = flagX2[x2] = 0; tem[r][c] = '.'; &#125; &#125; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435// 52题代码class Solution &#123;public: int totalNQueens(int n) &#123; int ans = 0; vector&lt;bool&gt; flagR(n , 0); vector&lt;bool&gt; flagX1(2*n , 0); vector&lt;bool&gt; flagX2(2*n , 0); helper(ans , 0 , n , flagR , flagX1 , flagX2); return ans; &#125; void helper(int &amp;ans , int c , int n , vector&lt;bool&gt; &amp;flagR , vector&lt;bool&gt; &amp;flagX1 , vector&lt;bool&gt; &amp;flagX2) &#123; if (c == n) // 递归终点，所有列都遍历完了 &#123; ans++; return; &#125; for (int r = 0 ; r &lt; n ; ++r) // 遍历行号 &#123; int x1 = c+r; int x2 = n+r-c; if (flagR[r] == 0 &amp;&amp; flagX1[x1] == 0 &amp;&amp; flagX2[x2] == 0) &#123; flagR[r] = flagX1[x1] = flagX2[x2] = 1; helper(ans , c+1 , n , flagR , flagX1 , flagX2); flagR[r] = flagX1[x1] = flagX2[x2] = 0; &#125; &#125; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-94 莫里斯中序遍历","slug":"LeetCode-94","date":"2020-02-07T08:23:52.000Z","updated":"2020-02-07T08:26:22.387Z","comments":true,"path":"2020/02/07/LeetCode-94/","link":"","permalink":"http://codebiluo.cn/2020/02/07/LeetCode-94/","excerpt":"","text":"中序遍历常见的是递归和用栈辅助遍历两种方法，这两种方法网上很常见，故我不再赘述。在看题解的时候，我看到一种莫里斯中序遍历，很有意思，就在写了一份关于这个的代码。 一、思路首先是莫里斯中序遍历的过程： 对于当前节点node来说，如果node的左子树是空的，那么就将node的值压入输出序列中，并更新node的值为其右指针；否则，将node左子树最右端节点的右指针指向node（这一步的目的之后会说），并更新node的值为其左指针； 从这个过程中可以看到，压入输出序列的时间是当node左子树为空的时候。为了使左子树变空，那么就需要对不空的情况进行处理：易知，node节点压入输入序列一定是在其左子树压入输入序列之后，而一棵树中，最右侧的节点一定是最后压入的，所以将node节点放到其左子树最右端的右指针上，就能构造一个同时满足这两点，又不会改变树的输出序列的另一棵二叉树。思路就是这样，在编写代码的时候，还需要注意一个问题：当node作为其左子树最右端节点的右指针的时候，还需要处理此时node的左指针，否则这棵树就会出现闭环，不再是二叉树。 二、代码1234567891011121314151617181920212223242526272829// 莫里斯中序遍历class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ans; TreeNode *node = root; while (node != NULL) &#123; if (node-&gt;left == NULL) // 左子树空 &#123; ans.push_back(node-&gt;val); node = node-&gt;right; &#125; else // 左子树未空 &#123; TreeNode *scan = node-&gt;left; while (scan-&gt;right != NULL) // 搜索左节点向右遍历最右侧的节点 scan = scan-&gt;right; scan-&gt;right = node; TreeNode *tem = node; node = node-&gt;left; tem-&gt;left = NULL; &#125; &#125; return ans; &#125;&#125;; 时间复杂度：o(n)空间复杂度：o(n) 123456789101112131415161718// 中序遍历的递归形式class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ans; dfs(root , ans); return ans; &#125; void dfs(TreeNode *node , vector&lt;int&gt; &amp;ans) &#123; if (node == NULL) return; dfs(node-&gt;left , ans); ans.push_back(node-&gt;val); dfs(node-&gt;right , ans); &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-103 双端队列","slug":"LeetCode-103","date":"2020-02-06T04:49:13.000Z","updated":"2020-02-06T04:58:41.408Z","comments":true,"path":"2020/02/06/LeetCode-103/","link":"","permalink":"http://codebiluo.cn/2020/02/06/LeetCode-103/","excerpt":"","text":"一、思路的诞生这个问题是在层次遍历的基础上做了延伸，寻找锯齿型的层次遍历。与一般层次遍历的单方向不同，锯齿形遍历是奇数层从左向右遍历，偶数层从右向左遍历（视根节点在奇数层）。这种对称的操作让我们想到了对层次遍历的数据结构队列进行改变，变为对称的双端队列（然鹅我并没有想到，我的想法还是使用队列，在入栈的顺序上做一些变化，后面会继续探讨这个想法不正确的地方。但是思路就是这样，把遍历的对称性作为突破口）。 二、主要思路在确定了使用双端队列之后，接下来的问题就是具体每一层的入队、出队的位置是怎样的：基本的原则是：同一层入队和出队的方向不同；相邻层入队方向不同，出队方向也不同基于这个原则，自己模拟一颗树的遍历过程会更加清晰的，我接下来给出我的模拟：假设：奇数层从队尾入，则偶数层从队头入初始化双端队列设为：d = [ 3 ]第一层（根节点）：根节点从队头出；因为偶数层从队头入，队尾出，为了满足从右向左的遍历顺序，所以根节点的右节点先入，左节点后入；同时将根节点的值压入该层的遍历结果中。此时d = [ 9 , 20]；第二层：20 出队后，因为其子节点位于奇数层，所以将其子节点先左后右压入队尾。9 如果有子节点也是同样的道理。压队的同时，将20 9按顺序压入该层的遍历结果中。此时d = [ 15 , 7]；第三层：15 和 7 没有子节点，故没有压队的步骤，只需将其按顺序压入该层的遍历结果即可。此时队列为空，故遍历结束，返回总体遍历结果；注意：1、问题要求返回的结果是分层保存的，故我们需要将不同层的遍历结果放在不同的一维数组中，然后再将他们放到一个二维数组中；2、每一层的遍历，我们都需要知道哪些是该层的节点（不能单纯的使用下一层节点数是上一层的二倍，因为这不一定是一颗满树），我使用的方法是建了一个和保存节点的双端队列完全相同的双端队列，操作和树节点入队出队完全对应。（当然还有别的方法，暂时还能想到的是使用哈希表） 三、代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt; vector&lt;int&gt; &gt; ans; vector&lt;int&gt; tem; deque&lt;int&gt; d1; &#x2F;&#x2F;存放节点的层数 deque&lt;TreeNode*&gt; d2; &#x2F;&#x2F;存放节点 if (root &#x3D;&#x3D; NULL) &#x2F;&#x2F; 空树 return ans; d1.push_back(1); d2.push_back(root); int depth &#x3D; 1; while (!d1.empty()) &#123; if (depth % 2 &#x3D;&#x3D; 1) &#123; while (1) &#123; int nowD &#x3D; d1.front(); TreeNode* node &#x3D; d2.front(); if (nowD !&#x3D; depth) &#x2F;&#x2F;将这一层的所有节点弹出来 break; tem.push_back(node-&gt;val); &#x2F;&#x2F; 将左右节点压队列（先左后右） d1.pop_front(); d2.pop_front(); if (node-&gt;left) &#123; d1.push_back(nowD+1); d2.push_back(node-&gt;left); &#125; if (node-&gt;right) &#123; d1.push_back(nowD+1); d2.push_back(node-&gt;right); &#125; &#125; &#125; else &#123; while (1) &#123; int nowD &#x3D; d1.back(); TreeNode* node &#x3D; d2.back(); if (nowD !&#x3D; depth) break; tem.push_back(node-&gt;val); &#x2F;&#x2F; 将右左节点压队列（先右后左） d1.pop_back(); d2.pop_back(); if (node-&gt;right) &#123; d1.push_front(nowD+1); d2.push_front(node-&gt;right); &#125; if (node-&gt;left) &#123; d1.push_front(nowD+1); d2.push_front(node-&gt;left); &#125; &#125; &#125; ans.push_back(tem); tem.clear(); depth++; &#125; return ans; &#125;&#125;; 时间复杂度：o(n)（遍历所有节点）","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"Unity+ARFoundation","slug":"Unity-ARFoundation","date":"2020-02-04T04:46:26.000Z","updated":"2020-02-05T11:21:21.924Z","comments":true,"path":"2020/02/04/Unity-ARFoundation/","link":"","permalink":"http://codebiluo.cn/2020/02/04/Unity-ARFoundation/","excerpt":"","text":"前两天想要上手Unity来AR方面的项目软件 ，探索过程中出现了各种各样的问题，现在将这个过程中遇到的各种各样问题梳理一下，希望后来者能开开心心上手Unity+AR。注意：这是一篇踩坑博客，具体搭建还请自行百度。 一、ARFoundation or ARCore or ARKitUnity作为一个平台，不直接提供XR（包括VR、AR和MR）的开发包，这时就需要其他公司提供各种各样的SDK工具包，国外有苹果公司的ARKit、谷歌公司的ARCore、Unity的ARFoundation，还有最近发现的OpenCVForUnity，而国内有EasyAR这些SDK工具包。ARKit是针对于IOS开发，ARCore是针对于Android开发，而我使用的是ARFoundation，这是Unity将ARKit和ARCore进一步整合的工作平台。（这里就要说到一个应该知道的问题，IOS开发一定需要Mac，或者是电脑装双系统，据望网友可靠信息，如果使用虚拟机，龟速运行不说， 还会有很多Bug。） 二、Android JDK &amp; NDK1、解决方法这是搭建环境过程遇到的最让我头疼的问题，直接原因就是我对进度条的不信任。当你进行Android开发时，需要将项目打包成apk，这时就需要Android JDK &amp; NDK工具包，这时你有两种选择①、自行下载SDK manager和NDK；（这条路让我感受到世界的恶意）②、使用Unity Hub直接下载Unity 2019.3.0f6 (64-bit)，这样可以直接添加各种模块； 2、方法①（想要较好解决方法的同学可以直接看方法②）SDK和NDK下载可以直接从官网下载，建议使用Goole浏览器的迅雷插件，这样可以快一点。SDK：https://www.androiddevtools.cn/NDK：https://developer.android.google.cn/ndk/downloads/下载SDK Tools后打开SDK manager再下载需要的对应工具，尽量下载最新版本。下载NDK之后，就会遇到一个第一个问题：NDK版本不正确令人震惊的是，Unity要求的NDK版本的小版本号怎么这么长！（黑人问号脸）还能把所有小版本都发布吗！这就导致我花费了大量时间在下载NDK，大版本错完小版本错，小版本错完之后还有错。 3、方法②对比之下，方法②就非常好。下载了Unity Hub之后，添加Android Build Support以及其分目录的模块后，直接下载Unity 2019.3.0f6 (64-bit)或者是Unity 2019.2.20f1 (64-bit)。下载的过程比较漫长，需要耐心等待，但是面包总会有的。下载到五分之四的时候，进度条就会卡住，而由于我对进度条的不信任，我就直接取消下载转到方法一。。。所以使用这个方法你只要相信进度条即可。 三、Mininum API Level配置环境的过程，有一个步骤时设置Mininum API Level，而我想的是设置的小一些，一定不会有问题，但事实不是如此。当我将其设置为最小的API Level 19：在编译运行的时候，会出现报错：这时需要将Mininum API Level设置的大一些，比如我设置的是API Level 24，就可以成功编译。 四、Building Gradle Project最终编译的时候，进度条再一次卡住/(ㄒoㄒ)/~~，这时编译进行到Building Gradle Project，Unity会直接卡死。 Gradle是一个基于JVM的构建工具，是一款通用灵活的构建工具，支持maven， Ivy仓库，支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml配置文件，基于Groovy，build脚本使用Groovy编写。——百度百科 而编译卡在这里的原因由于本地并没有Gradle，所以编译时需要下载，而外网资源下载速度我不用再提，据网友信息，他编译数小时后成功了！ 真是很短的时间呢！但我采取了其他的方法：预先下载Gradle。我下载的是gradle-5.4.1，之后在Edit-&gt;Preferences中将下载内容的地址输入到Gradle中。辛苦一整天，遇到诸多艰难，所幸克服，没有放弃，坚持走下去咯！","categories":[{"name":"Unity","slug":"Unity","permalink":"http://codebiluo.cn/categories/Unity/"}],"tags":[{"name":"AR","slug":"AR","permalink":"http://codebiluo.cn/tags/AR/"}]},{"title":"LeetCode-102 层次遍历","slug":"LeetCode-102","date":"2020-02-01T08:58:43.000Z","updated":"2020-02-01T09:02:52.820Z","comments":true,"path":"2020/02/01/LeetCode-102/","link":"","permalink":"http://codebiluo.cn/2020/02/01/LeetCode-102/","excerpt":"","text":"一、思路这道题使用的是二叉树的广度优先遍历，也就是层次遍历。与单纯的层次遍历不同的地方在于，这个问题要求返回的遍历结果是一个二维数组，一行代表树的一层。但是总的思路还是和层次遍历没有区别。为了知道二叉树中每一个节点位于书的哪一层的问题，需要标识每一个节点所在的层数，并根据层次遍历时的节点，对其子节点进行标识。在这里我想到的方法有两种：第一种是建一个队列保存节点的层数，与层次遍历的队列保持一一对应；第二种是建一个哈希表，来实现每一个节点和其层数之间的对应关系。这里的标识方法甚至都可以使用线性表，但是考虑到查找的效率太低，故不使用线性表。 二、代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; queue&lt;int&gt; qDepth; vector&lt; vector&lt;int&gt; &gt; ans; if (root == NULL) return ans; vector&lt;int&gt; tem; q.push(root); qDepth.push(1); int nowDepth = 1; // 标记现在已经遍历到哪一层 while (!q.empty()) // 标准的层次遍历 &#123; TreeNode *node = q.front(); q.pop(); int depth = qDepth.front(); qDepth.pop(); if (node-&gt;left) &#123; q.push(node-&gt;left); qDepth.push(depth+1); &#125; if (node-&gt;right) &#123; q.push(node-&gt;right); qDepth.push(depth+1); &#125; if (depth == nowDepth) &#123; tem.push_back(node-&gt;val); &#125; else // 每当到达新的一层将上一层的节点压入ans数组中 &#123; nowDepth++; ans.push_back(tem); tem.clear(); tem.push_back(node-&gt;val); &#125; &#125; ans.push_back(tem); // 注意最后还需要再将再压一次ans // 假设层数为m，当到达m+1层的时候，会直接跳出循环 // 所以没有执行m层的压ans操作 return ans; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-99 二叉搜索树多往中序遍历去想","slug":"LeetCode-99","date":"2020-01-31T07:46:43.000Z","updated":"2020-01-31T07:47:34.886Z","comments":true,"path":"2020/01/31/LeetCode-99/","link":"","permalink":"http://codebiluo.cn/2020/01/31/LeetCode-99/","excerpt":"","text":"一、错误思路最开始的思路，是进行深搜，向左树走的时候节点 N 压入biggers栈中，向右树走的时候节点压入smallers栈中，当子树深搜结束后，再将栈顶的节点，也就是节点 N 弹出。然后每到一个节点 P，就判断该节点与biggers和smallers栈中所有元素之间的关系，如果该节点的值大于等于biggers数组中的某一个节点 Q1，或者是该节点的值小于等于smallers数组中的某一个节点 Q2，就说明 P 和 Q1/Q2 就是被交换的节点。但是这个方法的问题是，只考虑了任意节点与其一颗子树节点之间的关系，没有考虑两颗子树之间的关系，导致如果交换的节点是在两颗子树上，就无法找到交换的节点。 二、错误代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 错误代码！！class Solution &#123;public: void recoverTree(TreeNode* root) &#123; vector&lt;TreeNode*&gt; biggers , smallers; helper(root , biggers , smallers); &#125; // 返回值作为一种标记来表示是否已经找到被交换的节点 bool helper(TreeNode *node , vector&lt;TreeNode*&gt; biggers , vector&lt;TreeNode*&gt; smallers) &#123; if (node == NULL) return false; else &#123; for (auto bigger:biggers) // 检测node的值是否小于biggers中的所有元素的值 &#123; if (node-&gt;val &gt;= bigger-&gt;val) &#123; swap(node-&gt;val , bigger-&gt;val); return true; &#125; &#125; for (auto smaller:smallers) // 检测node的值是否大于smallers中的所有元素的值 &#123; if (node-&gt;val &lt;= smaller-&gt;val) &#123; swap(node-&gt;val , smaller-&gt;val); return true; &#125; &#125; // 向左子树移动时，node是作为比左子树大的节点，故放入biggers中 biggers.push_back(node); bool flag = helper(node-&gt;left , biggers , smallers); if (flag) // 搜索到想要找的问题就直接返回 return flag; biggers.pop_back(); // 向右子树移动时，node是作为比右子树大的节点，故放入smallers中 smallers.push_back(node); flag = helper(node-&gt;right , biggers , smallers); if (flag) return true; smallers.pop_back(); return false; // 当前node并不是被交换的节点 &#125; &#125;&#125;; 三、正确思路在处理二叉搜索树节点大小关系的问题时，都应该想到用中序遍历来处理问题。一个正确的二叉搜索树，他的中序遍历应该是一个递增的数组，把握这一点，就能解决这个问题。如果交换了两个节点，那么对应的中序遍历，就会出现两个位置有递减的情况。这样问题就变为：得到树中序遍历的结果，将两个递减位置的节点进行交换。举个例子可能会更加直观：这时一个正确的二叉搜索树，他的中序遍历是：1 2 3 4 5 6交换节点之后，变为：这是可以看到中序遍历变为：6 2 3 4 5 1，根据思路叙述，交换的位置应该是6 2和5 1，看到交换的节点是前一个递减对的前一个节点和后一个递减对的后一个节点。还需要注意的一点是，有可能只有一个递减对，那么就是直接交换递减对的两个节点。 四、正确代码1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void recoverTree(TreeNode* root) &#123; vector&lt;TreeNode*&gt; midL; helper(root , midL); TreeNode *n1 , *n2; n1 = n2 = NULL; for (int i = 0 ; i &lt; midL.size()-1 ; ++i) &#123; if (n1 == NULL &amp;&amp; midL[i]-&gt;val &gt; midL[i+1]-&gt;val) n1 = midL[i]; if (n1 != NULL &amp;&amp; midL[i]-&gt;val &gt; midL[i+1]-&gt;val) n2 = midL[i+1]; &#125; swap(n1-&gt;val , n2-&gt;val); &#125; void helper(TreeNode *node , vector&lt;TreeNode*&gt; &amp;midL) &#123; if (node == NULL) return; else &#123; helper(node-&gt;left , midL); midL.push_back(node); helper(node-&gt;right , midL); &#125; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-100 留心小问题即可","slug":"LeetCode-100","date":"2020-01-31T01:18:04.000Z","updated":"2020-01-31T01:19:02.530Z","comments":true,"path":"2020/01/31/LeetCode-100/","link":"","permalink":"http://codebiluo.cn/2020/01/31/LeetCode-100/","excerpt":"","text":"一、问题及注意点这道题主要是考察对节点为空的情况时的考虑，想要访问某一个节点的内容，第一个需要解决的问题就是排除节点空的情况。剩下的就是编写类似深搜的代码。 二、具体代码123456789101112131415161718192021class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; return helper(p , q); &#125; bool helper(TreeNode* p , TreeNode* q) &#123; if ((p == NULL &amp;&amp; q != NULL) || (p != NULL &amp;&amp; q == NULL)) // 判断只有一者空的情况 return false; else if (p == NULL &amp;&amp; q == NULL) // 判断出现节点都空的情况 return true; else &#123; if (p-&gt;val != q-&gt;val) return false; bool flag1 = helper(p-&gt;left , q-&gt;left); bool flag2 = helper(p-&gt;right , q-&gt;right); return flag1*flag2; &#125; &#125;&#125;; 时间复杂度：o(n)（n为树节点个数）","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-4 超多方法;找到多个变量之间的关系来减少变量个数","slug":"LeetCode-4","date":"2020-01-29T15:39:59.000Z","updated":"2020-01-29T15:40:59.907Z","comments":true,"path":"2020/01/29/LeetCode-4/","link":"","permalink":"http://codebiluo.cn/2020/01/29/LeetCode-4/","excerpt":"","text":"一、直接顺序遍历到所求位置所谓求中位数，实际上就是求两个数组排序后的第 tar 个元素（当两数组长度之和m+n为奇数时，tar1 = (m+n)/2，当为偶数时，tar1 = (m+n)/2，tar2 = tar1+1）。可以想到归并排序时归并的操作，cnt1和cnt2分别指向两个数组当前遍历到的位置，选择两数组中较小的元素，将其对应遍历指针cnt加一。在这里需要注意的是，有可能出现 nums1 = {1,2}nums2 = {3,4,5,6,7,8} 这样的情况，这时就需要对下边进行判断，当一个遍历指针已经越界的时候，就直接将另一个遍历指针加一。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int len1 = nums1.size(); int len2 = nums2.size(); int tar1 = (len1+len2)/2; int tar2 = tar1+1; int cnt1 , cnt2; cnt1 = cnt2 = 0; int ans1 , ans2; ans1 = ans2 = 0; for (int i = 1 ; i &lt;= tar2 ; ++i) &#123; if (cnt2 &gt;= len2 || (cnt1 &lt; len1 &amp;&amp; nums1[cnt1] &lt; nums2[cnt2])) &#123; if (i == tar1) ans1 = nums1[cnt1]; if (i == tar2) ans2 = nums1[cnt1]; cnt1++; &#125; else &#123; if (i == tar1) ans1 = nums2[cnt2]; if (i == tar2) ans2 = nums2[cnt2]; cnt2++; &#125; &#125; if ((len1+len2) % 2 == 0) return (ans1+ans2)/2.0; else return ans2; &#125;&#125;; 时间复杂度：o(m+n)没有达到题目的要求，还需要再进行优化 二、查找第tar个数第一种方法使用顺序遍历的方式查找第tar个数字，时间复杂度必然无法达到log(m+n)，想要优化，第一个想到的就是用二分查找的方式加速查找，这时需要思考的问题就是： 用什么作为二分的标准？一种方法是将查找第tar数字进行二分，每一次确定 tar/2 个一定在中位数之前的数字；另一种方法是将下标作为二分的标准，找到两个数组分块位置之间的关系，对一个数组进行标准的二分； 第一种方法是通过一定的判断，将数组舍去一部分，假设两个数组为 nums1 = {1,3,5,6};nums2 = {2,4,9,10,12}; 可知：tar这时是等于4，则 tar/2 等于2，这时比较两个数组中第二个元素，由于 3&lt;4 所以可以确定nums1中的 {1,3}一定是小于最后的中位数。也就是第tar数，新数组变为 nums1 = {5,6};nums2 = {2,4,9,10,12}; 我们的tar也就变成 4-2=2 然后进行新一轮的处理。 在代码中，用k来代替tar 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int len1 = nums1.size() , len2 = nums2.size(); int len = len1+len2; if (len % 2 == 0) // 需要探查查两次 &#123; int ans1 = helper(nums1 , nums2 , len/2); int ans2 = helper(nums1 , nums2 , len/2+1); return (1.0*ans1+ans2)/2; &#125; else //只要探查一次 &#123; int ans = helper(nums1 , nums2 , len/2+1); return ans; &#125; &#125; int helper(vector&lt;int&gt; nums1 , vector&lt;int&gt; nums2 , int k) &#123; if (nums1.size() == 0) &#123; return nums2[k-1]; &#125; else if (nums2.size() == 0) &#123; return nums1[k-1]; &#125; else if (k == 1) &#123; return nums1[0]&gt;nums2[0]?nums2[0]:nums1[0]; &#125; int k_2 = k/2; int p1 = k_2&gt;nums1.size()?nums1.size():k_2; int p2 = k_2&gt;nums2.size()?nums2.size():k_2; if (nums1[p1-1] &gt; nums2[p2-1]) &#123; return helper(nums1 , vector&lt;int&gt;(nums2.begin()+p2,nums2.end()) , k-p2); &#125; else &#123; return helper(vector&lt;int&gt;(nums1.begin()+p1,nums1.end()) , nums2 , k-p1); &#125; &#125;&#125;; 时间复杂度：o(log(m+n))（在代码中实际是o(log(k))，因为k=(m+n)/2，故时间复杂度也就是o(log(m+n))） 三、二分查找1、心路历程当我看到题目中要求的复杂度有 log 的时候，第一个想到的就是二分查找，由于二分查找是作用于一个数组，所以我的想法就是分别有left1、right1、left2、right2来表示两个数组的边界。同时，注意到中位数的定义，决定了我们最后要找的数字，两个数组的分界线两边的元素个数应该是相同的（在长度和为奇数的情况下），这样也就约束了二分查找时的递归条件。而中位数的定义决定了，位于中位数左边的元素一定是小于位于它右边的元素，这样就约束了递归出口条件。但是由于这个方法引入了两个分界线，虽然知道它们之间的关系，但是在编写代码时还是容易产生混乱，然后，我最后没有把这个思路编成代码（手动狗头），望有缘人能完成它。 2、解题思路根据两个数组的分界线两边的元素个数应该是相同的（在长度和为奇数的情况下），假设分界线为p1和p2，需要注意的是，上面思路中，是将下标作为分界线，而这里是将两个下标之间的位置假象为分界线，故 当len1+len2为偶数时∵ p1 + p2 = len1-p1 + len2-p2∴ p2 = (len1+len2) / 2 - p1;当len1+len2为奇数时∵ p1 + p2 = len1-p1 + len2-p2 + 1∴ p2 = (len1+len2 + 1) / 2 - p1; 注意：①、因为代码中下标都为整型，所以偶数情况等价于 p2= (len1 + len2 + 1) / 2 - p1②、因为分界线一定是非负的，所以 p1 应该是长度较小数组的分界线（以 p1 作为二分查找的中点时） 为了写题解方便，暂时不考虑边界条件（p1 != 0 , p1 != len1 , p2 != 0 , p2 != len2）根据位于中位数左边的元素一定是小于位于它右边的元素，由于同一个数组元素已经有序，需要判断的就是不同数组分界线处元素的大小关系。 假设某一次迭代两数组分解情况如下nums1 = { …… 4 | 5 …… }nums2 = { …… 2 | 3 …… }很容易就能发现，如果将这种分界情况作为答案，一定是不可行的：因为 4&lt;3 ，分界线左端元素不满足恒小于分界线端元素。这时为了得到合理的分界情况，就希望 nums1 的分界线向左移，nums2 的分界线会随之移动。同时还有②nums1 = { …… 2 | 3 …… }nums2 = { …… 4 | 5 …… }这种情况，这时就希望 nums1 的分界线向右移动 因为使用二分查找，所以分界线的移动都是通过端点的移动来进行：向左移，就将右端点赋值为 p1-1;向右移，就将左端点赋值为 p1+1; 大致思路完成后，就需要考虑端点的情况，通过示例，能知道需要处理那些边界条件，这些边界条件不仅在递归过程中，还会在最后的递归出口用到： 比较两端元素时，分界线已经到端点位置①nums1 = { | …… }nums2 = { …… | …… }②nums1 = { …… | …… }nums2 = { | …… }③nums1 = { …… | }nums2 = { …… | …… }④nums1 = { …… | …… }nums2 = { …… | } 3、具体代码12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int len1 = nums1.size(); int len2 = nums2.size(); if (len1 &gt; len2) return findMedianSortedArrays(nums2 , nums1); int left = 0 , right = len1; while (1) &#123; int p1 = (left+right+1) / 2; int p2 = (len1+len2+1)/2-p1; if (p1 != 0 &amp;&amp; p2 != len2 &amp;&amp; nums1[p1-1] &gt; nums2[p2]) // 还需要将查找区间向左移 right = p1-1; else if (p1 != len1 &amp;&amp; p2 != 0 &amp;&amp; nums2[p2-1] &gt; nums1[p1]) left = p1+1; else &#123; int maxLeft = 0; if (p1 == 0) &#123; maxLeft = nums2[p2-1]; &#125; else if (p2 == 0) &#123; maxLeft = nums1[p1-1]; &#125; else &#123; maxLeft = max(nums1[p1-1], nums2[p2-1]); &#125; if ( (len1 + len2) % 2 == 1 ) &#123; return maxLeft; &#125; // 奇数的话不需要考虑右半部分 int minRight = 0; if (p1 == len1) &#123; minRight = nums2[p2]; &#125; else if (p2 == len2) &#123; minRight = nums1[p1]; &#125; else &#123; minRight = min(nums2[p2], nums1[p1]); &#125; return (maxLeft + minRight) / 2.0; //如果是偶数的话返回结果 &#125; &#125; &#125;&#125;; 时间复杂度：o( log(min{m , n}) )（m，n为两数组长度）","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-97 指数型增长的暴力果然不可行","slug":"LeetCode-97","date":"2020-01-28T02:41:56.000Z","updated":"2020-01-28T02:45:09.365Z","comments":true,"path":"2020/01/28/LeetCode-97/","link":"","permalink":"http://codebiluo.cn/2020/01/28/LeetCode-97/","excerpt":"","text":"题目分析这个题要求判断两个字符串s1、s2，是否能通过某种方式，将他们的字符任意排列，从而组成字符串s3，也就是题目所说的s1、s2交错组成s3。 思路分析1、暴力法首先想到的是简单的暴力法，对问题进行递归。按字符顺序递归。假设某一层递归s1，s2，s3分别到达下标p1，p2，p3，问题变成分别尝试s3[p3]取s1[p1]和s2[p2]（取的规则是字符要求相同）并继续递归。 1234567891011121314151617181920212223242526class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if (s1.size() + s2.size() != s3.size()) return false; return helper(s1 , 0 , s2 , 0 , s3 , 0); &#125; bool helper(string s1 , int p1 , string s2 , int p2 , string s3 , int p3) &#123; if (p3 == s3.size()) return true; bool flag1 , flag2; flag1 = flag2 = 0; // 用s1[p1]作为s3[p3] if (p1 &lt; s1.size() &amp;&amp; s1[p1] == s3[p3]) flag1 = helper(s1 , p1+1 , s2 , p2 , s3 , p3+1); // 用s2[p2]作为s3[p3] if (p2 &lt; s2.size() &amp;&amp; s2[p2] == s3[p3]) flag2 = helper(s1 , p1 , s2 , p2+1 , s3 , p3+1); if (flag1 == true || flag2 == true) return true; else return false; &#125;&#125;; 时间复杂度：o(2^m * (m-n))（m为s1、s2中长度较长者）注意：由于这个方法是指数爆炸增长的复杂度，cpp代码会超时。 2、动态规划使用二维布尔数组dp用于表示两数组某一位的交错情况：dp[i][j]==1表示s1的前i位和s2的前j位可以交错组成s3的前i+j位。知道dp数组表示的含义，问题也就迎刃而解。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; int len1 = s1.size() , len2 = s2.size() , len3 = s3.size(); if (len1+len2 != len3) return false; vector&lt;vector&lt;bool&gt;&gt; dp(len1+1 , vector&lt;bool&gt;(len2+1 , false)); dp[0][0] = 1; // 初始化第一行 for (int i = 1 ; i &lt;= len2 ; ++i) &#123; if (dp[0][i-1] == true &amp;&amp; s2[i-1] == s3[i-1]) dp[0][i] = true; &#125; // 初始化第一列 for (int i = 1 ; i &lt;= len1 ; ++i) &#123; if (dp[i-1][0] == true &amp;&amp; s1[i-1] == s3[i-1]) dp[i][0] = true; &#125; for (int i = 1 ; i &lt;= len1 ; ++i) &#123; for (int j = 1 ; j &lt;= len2 ; ++j) &#123; if ((dp[i-1][j] == true &amp;&amp; s1[i-1] == s3[i+j-1]) || (dp[i][j-1] == true &amp;&amp; s2[j-1] == s3[i+j-1])) dp[i][j] = true; else dp[i][j] = false; &#125; &#125; // for (int i = 0 ; i &lt; len1 ; ++i) // 显示dp数组 // &#123; // copy(dp[i].begin() , dp[i].end() , ostream_iterator&lt;bool&gt;(cout , \" \")); // cout &lt;&lt; endl; // &#125; return dp[len1][len2]; &#125;&#125;; 时间复杂度：o(m*n)（m，n为s1，s2数组的长度）","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"Django-4","slug":"Django-4","date":"2020-01-27T13:50:46.000Z","updated":"2020-01-27T13:51:05.717Z","comments":true,"path":"2020/01/27/Django-4/","link":"","permalink":"http://codebiluo.cn/2020/01/27/Django-4/","excerpt":"","text":"• 编写一个用于问题显示的表单（form）form是HTML的一个元素，修改polls/detail.html 12345678910&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&#123;% if error_message %&#125;&lt;p&gt;&lt;strong&gt;&#123;&#123; error_message &#125;&#125;&lt;/strong&gt;&lt;/p&gt;&#123;% endif %&#125;&lt;form action=\"&#123;% url 'polls:vote' question.id %&#125;\" method=\"post\"&gt;&#123;% csrf_token %&#125;&#123;% for choice in question.choice_set.all %&#125; &lt;input type=\"radio\" name=\"choice\" id=\"choice&#123;&#123; forloop.counter &#125;&#125;\" value=\"&#123;&#123; choice.id &#125;&#125;\"&gt; &lt;label for=\"choice&#123;&#123; forloop.counter &#125;&#125;\"&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/label&gt;&lt;br&gt;&#123;% endfor %&#125;&lt;input type=\"submit\" value=\"Vote\"&gt;&lt;/form&gt; 这部分涉及HTML相关内容，不再赘述 • 添加投票界面的相关内容添加关于polls/views.py的vote()函数的相关实现： 12345678910111213141516171819202122from django.http import HttpResponse, HttpResponseRedirectfrom django.shortcuts import get_object_or_404, renderfrom django.urls import reversefrom .models import Choice, Question# ...def vote(request, question_id): question = get_object_or_404(Question, pk=question_id) try: selected_choice = question.choice_set.get(pk=request.POST['choice']) except (KeyError, Choice.DoesNotExist): # Redisplay the question voting form. return render(request, 'polls/detail.html', &#123; 'question': question, 'error_message': \"You didn't select a choice.\", &#125;) else: selected_choice.votes += 1 selected_choice.save() # Always return an HttpResponseRedirect after successfully dealing # with POST data. This prevents data from being posted twice if a # user hits the Back button. return HttpResponseRedirect(reverse('polls:results', args=(question.id,))) 相关内容说明：1、request.POST是类似于字典的对象，可让您通过键名访问提交的数据。在这种情况下， request.POST[‘choice’]以字符串形式返回所选选项的ID。request.POST值始终是字符串。 请注意，Django还提供request.GET了以相同方式访问GET数据的方法-但我们request.POST在代码中明确使用，以确保仅通过POST调用更改数据。 2、如果没有提供POST数据，那么就会产生KEYERROR异常，重新显示问题表单。 3、在此示例reverse()中，我们在HttpResponseRedirect构造函数中使用该函数 。此功能有助于避免在视图功能中对URL进行硬编码。它提供了我们想要将控制权传递给的视图的名称，以及指向该视图的URL模式的可变部分。在这种情况下，使用我们在教程3中设置的URLconf ，此reverse()调用将返回一个字符串，例如’/polls/3/results/‘，其中3是的值question.id。然后，此重定向的URL将调用‘results’视图以显示最后一页。 • 投票结果页面相关内容进行投票之后，vote()视图将重定向到该问题的结果页面，故编写视图在views.py： 1234from django.shortcuts import get_object_or_404, renderdef results(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/results.html', &#123;'question': question&#125;) 同时创建polls/results.html模板： 1234567&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&lt;ul&gt;&#123;% for choice in question.choice_set.all %&#125; &lt;li&gt;&#123;&#123; choice.choice_text &#125;&#125; -- &#123;&#123; choice.votes &#125;&#125; vote&#123;&#123; choice.votes|pluralize &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt;&lt;a href=\"&#123;% url 'polls:detail' question.id %&#125;\"&gt;Vote again?&lt;/a&gt; 现在可以运行服务器，来看一看问题页面、投票页面和投票结果显示页面， • 使用通用视图来减少代码量在 detail() 和 results() 的视图函数是非常短并且相似，所以重复的代码是冗余的。这些视图代表了基本Web开发的一种常见情况：根据URL中传递的参数从数据库获取数据，加载模板并返回渲染的模板。因为这很常见，所以Django提供了一个捷径，称为“通用视图”系统。为了转换为通用视图系统，需要经过一些步骤： 1. 转换URLconf。 2. 删除一些旧的不需要的视图。 3. 根据Django的通用视图介绍新视图。 修改URL配置首先对polls/urls.py的URLconf进行修改： 123456789from django.urls import pathfrom . import viewsapp_name = 'polls'urlpatterns = [ path('', views.IndexView.as_view(), name='index'), path('&lt;int:pk&gt;/', views.DetailView.as_view(), name='detail'), path('&lt;int:pk&gt;/results/', views.ResultsView.as_view(), name='results'), path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 修改的是将更改为。 修改视图将polls/views.py修改为： 12345678910111213141516171819from django.http import HttpResponseRedirectfrom django.shortcuts import get_object_or_404, renderfrom django.urls import reversefrom django.views import genericfrom .models import Choice, Questionclass IndexView(generic.ListView): template_name = 'polls/index.html' context_object_name = 'latest_question_list'def get_queryset(self): \"\"\"Return the last five published questions.\"\"\" return Question.objects.order_by('-pub_date')[:5]class DetailView(generic.DetailView): model = Question template_name = 'polls/detail.html'class ResultsView(generic.DetailView): model = Question template_name = 'polls/results.html'def vote(request, question_id): ... # same as above, no changes needed. 在这里使用了两个通用视图ListView和DetailView，分别抽象了“显示对象列表”和“显示特定类型的对象的详细信息页面”的概念。","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"}]},{"title":"LeetCode-95 合理利用返回值","slug":"LeetCode-95","date":"2020-01-27T13:48:24.000Z","updated":"2020-01-30T07:30:02.669Z","comments":true,"path":"2020/01/27/LeetCode-95/","link":"","permalink":"http://codebiluo.cn/2020/01/27/LeetCode-95/","excerpt":"","text":"一、思路最开始做这道题的时候，我把题目理解成了值为1到n的二叉搜索树有几颗，而不是这些树分别是什么。但这两个问题的关联度较大，问题的关键在于想到：当我们确定了根节点的值是什么，那么他左右子树的取值范围就已经很明确了。若根节点的取值是在[left , right]中的一个值k，由二叉搜索树的定义可知，左子树的值在[left , k-1]，右子树的值在[k+1 , right]。假设我们已经求出左右子树（注意求出的应该是一组树，而不是一个树），所以我们用两重循环遍历所有左右子树搭配的可能，也就求出根节点值为k、取值范围在[left , right]间的所有树，遍历即可求出值为[left , right]的所有树。这样问题就形成了递归，自然也就解决。 二、注意：在最开始的时候，我将helper()（代码中的函数）的返回值设置成void，虽然想到根节点确定，左右子树范围确定这一点，但是一直不知道该怎么转换成代码。（当时冒出的想法是，一棵树如果已经完整（有n个节点），那么就将他push_back到结果中，但是没有实现） 三、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if (n == 0) &#123; vector&lt;TreeNode*&gt; ans; return ans; &#125; return helper(1 , n); &#125; vector&lt;TreeNode*&gt; helper(int left , int right) &#123; vector&lt;TreeNode*&gt; ans; if (left &gt; right) &#123; ans.push_back(NULL); return ans; &#125; for (int i = left ; i &lt;= right ; ++i) &#123; vector&lt;TreeNode*&gt; leftTrees = helper(left , i-1); vector&lt;TreeNode*&gt; rightTrees = helper(i+1 , right); for (auto leftTree : leftTrees) &#123; for (auto rightTree : rightTrees) &#123; TreeNode* root = new TreeNode(i); root-&gt;left = leftTree; root-&gt;right = rightTree; ans.push_back(root); &#125; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-92 哨位节点的重要性","slug":"LeetCode-92","date":"2020-01-26T04:38:42.000Z","updated":"2020-01-28T02:47:03.792Z","comments":true,"path":"2020/01/26/LeetCode-92/","link":"","permalink":"http://codebiluo.cn/2020/01/26/LeetCode-92/","excerpt":"","text":"一、解题思路这个问题其实等同于反转链表，只是将问题变成了子链表。在反转链表的时候，是引入了prev，scan，next三个指针，分别表示当前节点的前一个节点，当前节点，当前节点的后一个节点。遍历的过程只需要将scan-&gt;next赋值为prev。最后处理头节点即可。回到这个问题，其实就是在反转m至n号节点，将最后处理头节点的过程变成处理这一段链表两端节点。 二、具体流程首先需要先找到第m个节点，然后反转m至n号节点，然后将m号节点的next指针指向第n+1号节点，再将m-1号节点的next指针指向m-1号节点。 三、重点问题在处理的过程中会有这么几个问题：eg：1-&gt;2-&gt;3-&gt;4-&gt;NULL1、考虑m=1，n=2的情况，这种情况导致m-1号节点为空，如果直接对给定链表操作，会导致代码中不断地在考虑特殊情况，所以我们添加哨位节点，这样代码实现的难度直线下降。2、考虑m=3，n=4的情况，这种情况会在next进行迭代的时候出现空指针访问的情况。所以在迭代的时候需要充分考虑空指针。 四、代码12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; ListNode *prev , *scan , *next; ListNode *tem = new ListNode(0); tem-&gt;next = head; head = tem; //添加一个哨位节点 // 遍历找第m个节点 scan = head; for (int i = 1 ; i &lt; m ; ++i) scan = scan-&gt;next; ListNode *m_1Node = scan; ListNode *mNode = scan-&gt;next; // 反转m至n号节点 prev = mNode; scan = mNode-&gt;next; next = mNode-&gt;next==NULL?NULL:mNode-&gt;next-&gt;next; //考虑翻转最后一个节点的可能 for (int i = m ; i &lt; n ; ++i) &#123; scan-&gt;next = prev; prev = scan; scan = next; next = next==NULL?NULL:next-&gt;next; // 考虑n号节点之后再没有节点 &#125; // 连接两端 m_1Node-&gt;next = prev; mNode-&gt;next = scan; return head-&gt;next; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-3 官方题解的优化滑动窗口","slug":"LeetCode-3","date":"2020-01-26T03:39:48.000Z","updated":"2020-01-30T07:30:03.879Z","comments":true,"path":"2020/01/26/LeetCode-3/","link":"","permalink":"http://codebiluo.cn/2020/01/26/LeetCode-3/","excerpt":"","text":"一、子问题解决这道题之前，可以先思考一个重要的问题，就是给定的一段字符串，如何判断它是否有重复的字符。法一、容易想到的是遍历每一个字符，判断在它之后是否出现相同字符，时间复杂度o(n^2)。法二、同LeetCode-1，用哈希表进行搜索加速：维护一个数组作为哈希表，初始化为0。遍历字符串，并将每个字符对应位置（eg：‘f’-‘a’ = 5，‘f’对应下标为5）置为1，如果该位置已经置1，那么就说明出现重复字符。这个方法只需要一次遍历，时间复杂度o(n)。 二、问题思路解决子问题之后，我们知道可以用哈希表来进行加速。维护一个数组作为哈希表，初始化内容为-1（不初始化为0是因为之后哈希表中保存的会是字符下标），遍历整个字符串，将每一个字符对应位置保存当前字符的下标。遍历至下标n处，如果该位置对应哈希表内容为m（m != -1），则说明 [m,n) 是无重复字符子串，[m,n]会出现重复字符。计算当前无重复子串长度后，保存较大者。之后重置哈希表，再进行之后字符串的遍历。这个方法也就是官方题解中的优化滑动窗口。 三、代码1234567891011121314151617181920212223242526272829303132int lengthOfLongestSubstring(char * s)&#123; int from , to; //当前最长子串起止下标 from = to = 0; int ans = 0; int hash[256]; //每个字符的键值对 memset(hash , -1 , sizeof(hash)); while (s[to] != '\\0') &#123; if (hash[s[to]] == -1) &#123; hash[s[to]] = to; to++; &#125; else if (hash[s[to]] &lt; from) //重复的不是当前最长子串 &#123; hash[s[to]] = to; to++; &#125; else //当前最长子串出现重复，更新from的值为重复字符（前面的那个）位置加1 &#123; ans = ans &gt; (to - from) ? ans : (to - from); from = hash[s[to]] + 1; hash[s[to]] = to; to++; &#125; &#125; ans = ans &gt; (to - from) ? ans : (to - from); return ans;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-2 需要考虑周全的问题","slug":"LeetCode-2","date":"2020-01-23T02:54:44.000Z","updated":"2020-01-28T02:47:21.417Z","comments":true,"path":"2020/01/23/LeetCode-2/","link":"","permalink":"http://codebiluo.cn/2020/01/23/LeetCode-2/","excerpt":"","text":"一次遍历这个问题主要考察的是链表的操作和出现特殊情况的处理。1、当两个链表一样长的时候，问题比较好处理，直接挨个相加即可；2、当两个链表不一样的时候，就需要对遍历节点进行判断，不能出现再访问属性val的语句；3、由于一条链有可能为空这种极端情况，所以不能简单的采用原地算法；4、问题有一个小坑，就是有可能最后还有一位进位，对这个情况要考虑在内；5、可以通过添加一个哑节点来减少代码； 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *scan1 = l1; ListNode *scan2 = l2; ListNode *head = new ListNode(0); //这是哑节点 ListNode *scan = head; int flag = 0; //标记进位 while (1) &#123; if (scan1 == NULL &amp;&amp; scan2 == NULL) break; int n1 = scan1!=NULL?scan1-&gt;val:0; int n2 = scan2!=NULL?scan2-&gt;val:0; scan-&gt;next = new ListNode((n1+n2+flag)%10); flag = (n1+n2+flag)/10; if (scan1 != NULL) scan1 = scan1-&gt;next; if (scan2 != NULL) scan2 = scan2-&gt;next; scan = scan-&gt;next; &#125; if (flag) //如果最后还有进位 scan-&gt;next = new ListNode(1); return head-&gt;next; &#125;&#125;; 时间复杂度：O(MAX{m,n})空间复杂度：O(MAX{m,n})","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-1 利用哈希表进行查找加速","slug":"LeetCode-1","date":"2020-01-23T02:30:11.000Z","updated":"2020-01-28T02:47:29.179Z","comments":true,"path":"2020/01/23/LeetCode-1/","link":"","permalink":"http://codebiluo.cn/2020/01/23/LeetCode-1/","excerpt":"","text":"问题可以转换为，已有一个ele（为数组中的任意元素），需要在数组中寻找另一个元素等于target-ele 1、暴力遍历法最直观的想法遍历每一个元素，再对该元素进行遍历，查看是否有满足条件的其他元素，使得他们两的加和为target。 1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for (int i = 0 ; i &lt; nums.size() ; ++i) &#123; for (int j = i+1 ; j &lt; nums.size() ; ++j) &#123; if (nums[i]+nums[j] == target) return &#123;i , j&#125;; &#125; &#125; return &#123;-1 , -1&#125;; &#125;&#125;; 时间复杂度：O(n^2)空间复杂度：O(1) 2、一遍hash这个方法的想法主要是利用哈希表来进行查找加速。遍历数组元素ele，将ele放入哈希表中（ele值作为外键，ele下标作为內键），同时判断target-ele是否在哈希表中：如果在，那么搜索结束，直接返回；如果不在，继续遍历，直到结尾； 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; m; for (int i = 0 ; i &lt; nums.size() ; ++i) &#123; if (m.count(target-nums[i]) == 1) &#123; return &#123;m[target-nums[i]] , i&#125;; &#125; m[nums[i]] = i; &#125; return &#123;-1, -1&#125;; &#125;&#125;; 时间复杂度：O(n)空间复杂度：O(n)","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"Django-3","slug":"Django-3","date":"2020-01-22T11:46:05.000Z","updated":"2020-01-22T14:11:18.794Z","comments":true,"path":"2020/01/22/Django-3/","link":"","permalink":"http://codebiluo.cn/2020/01/22/Django-3/","excerpt":"","text":"• 视图视图其实是视图函数的简称，视图是Django应用程序中网页的“类型”，通常具有特定功能并具有特定模板。在Django中，网页和其他内容是通过视图传递的。每个视图均由Python函数（或方法（对于基于类的视图而言））表示。Django将通过检查所请求的URL（准确地说，是域名之后的URL部分）来选择视图。 • URLURL即统一资源定位符，是每一个信息资源都有统一的且在网上唯一的地址。URLconfs即URL模式，是URL的一般形式Django提供了更加优雅的URL模式，例如： 1/newsarchive/&lt;year&gt;/&lt;month&gt;/ • 添加更多的视图更改views.py： 1234567def detail(request, question_id): return HttpResponse(\"You're looking at question %s.\" % question_id)def results(request, question_id): response = \"You're looking at the results of question %s.\" return HttpResponse(response % question_id)def vote(request, question_id): return HttpResponse(\"You're voting on question %s.\" % question_id) 并更改polls.urls.py： 123456789101112from django.urls import pathfrom . import viewsurlpatterns = [ # ex: /polls/ path('', views.index, name='index'), # ex: /polls/5/ path('&lt;int:question_id&gt;/', views.detail, name='detail'), # ex: /polls/5/results/ path('&lt;int:question_id&gt;/results/', views.results, name='results'), # ex: /polls/5/vote/ path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 根据输入的URL地址，通过遍历的方式寻找匹配的URL模式串，并调用相对应的视图函数，相应相对应的网页。比如说，当有人从网站请求页面时，例如“ / polls / 34 /”，Django将加载mysite.urls的Python模块，因为该ROOT_URLCONF设置指向该模块 。它找到名为的变量urlpatterns并按顺序遍历模式。在找到匹配项之后’polls/‘，它将剥离匹配的文本（”polls/“），并将其余文本–发送 “34/“到’polls.urls’URLconf进行进一步处理。在那里匹配’int:question_id/‘，从而导致对detail()视图的调用，如下所示：detail(request=, question_id=34) • 编写更强大的视图每个视图负责执行以下两项操作之一：返回HttpResponse包含所请求页面内容的对象，或者引发诸如之类的异常Http404。HttpResponse需要自己对其进行填充，而HttpRequest是Django自己生成。视图可以从数据库中读取记录，也可以使用Django等模板系统，也可以不使用第三方Python模板系统。它还可以使用所需的任何Python库生成PDF文件，输出XML，或即时创建ZIP文件。在view.py添加代码： 123456from .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] output = ', '.join([q.question_text for q in latest_question_list]) return HttpResponse(output) # Leave the rest of the views (detail, results, vote) unchanged • 将模板与视图创建的硬编码分开首先，在目录templates中创建一个polls目录。Django将在那里寻找模板。您的项目TEMPLATES置描述了Django如何加载和呈现模板。默认设置文件配置一个DjangoTemplates 后端，其APP_DIRS选项设置为 True。按照惯例DjangoTemplates，在每个文件夹中都会寻找一个“模板”子目录INSTALLED_APPS。在polls/templates/polls/添加一个模板： 123456789&#123;% if latest_question_list %&#125; &lt;ul&gt; &#123;% for question in latest_question_list %&#125; &lt;li&gt;&lt;a href=\"/polls/&#123;&#123; question.id &#125;&#125;/\"&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&#123;% else %&#125; &lt;p&gt;No polls are available.&lt;/p&gt;&#123;% endif %&#125; 现在运行服务器之后，可以子项/polls来加载一个“最新消息”列表。 • 快捷方式加载模板，填充上下文并使用渲染后的模板的结果返回对象HttpResponse是一种非常常见的用法。同时，Django提供了一种快捷方式。重写index()： 123456from django.shortcuts import renderfrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] context = &#123;'latest_question_list': latest_question_list&#125; return render(request, 'polls/index.html', context) 该render()函数将请求对象作为其第一个参数，将模板名称作为其第二个参数，并将字典作为其可选的第三个参数。它返回使用HttpResponse 给定上下文呈现的给定模板的对象。 • 404错误在views.py中添加代码： 12345678910from django.http import Http404from django.shortcuts import renderfrom .models import Question# ...def detail(request, question_id): try: question = Question.objects.get(pk=question_id) except Question.DoesNotExist: raise Http404(\"Question does not exist\") return render(request, 'polls/detail.html', &#123;'question': question&#125;) 为了快速使示例正常工作，对应模板polls/templates/polls/detail.html中只添加： 1&#123;&#123; question &#125;&#125; 现在运行服务器，可以看到更完整的polls网页 • 404的快捷方式重写detail()函数： 1234567from django.shortcuts import get_object_or_404, renderfrom .models import Question# ...def detail(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/detail.html', &#123;'question': question&#125;) • 使用模板系统polls/detail.html改写为： 123456&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&lt;ul&gt;&#123;% for choice in question.choice_set.all %&#125; &lt;li&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 模板系统使用点查找语法来访问变量属性。在的示例中，首先Django在对象上进行字典查找。如果失败，它将尝试属性查找-在这种情况下可以工作。如果属性查找失败，它将尝试进行列表索引查找。 • 命名空间URL名称在实际的Django项目中，可能有很多个应用程序，Django如何区分它们之间的URL名称呢？答案是将名称空间添加到URLconf中。在polls/urls.py中添加app_name以设置为应用程序名称空间： 123456789from django.urls import patfrom . import viewsapp_name = 'polls'urlpatterns = [ path('', views.index, name='index'), path('&lt;int:question_id&gt;/', views.detail, name='detail'), path('&lt;int:question_id&gt;/results/', views.results, name='results'), path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 这样可以区分多个应用程序的URL名称。","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"}]},{"title":"Django-2","slug":"Django-2","date":"2020-01-19T12:37:53.000Z","updated":"2020-01-22T11:46:23.853Z","comments":true,"path":"2020/01/19/Django-2/","link":"","permalink":"http://codebiluo.cn/2020/01/19/Django-2/","excerpt":"","text":"• 数据库设置默认使用SQLite，相关的设置都在setting.py文件中进行。 setting,py中还有其他设置：INSTALLED_APPS文件顶部的设置。该名称包含在此Django实例中激活的所有Django应用程序的名称。其中包含一些默认的应用程序。不需要时可以在INSTALLED_APPS中删去。 1python manage.py migrate 该migrate命令将查看该INSTALLED_APPS设置，并根据mysite/settings.py文件中的数据库设置以及应用程序随附的数据库迁移来创建任何必要的数据库表。 • 创建模型模型是相关数据的唯一、确定的事实来源。它包含要存储数据的基本字段和行为。也就是一个包含各种属性（数据）和方法（行为）的类。比如说：在民意调查应用中，我们将创建两个模型：Question和Choice。Question有一个问题和出版日期。Choice有两个字段：选择的文本和投票提示。每个Choice都与关联Question。 在polls/models.py文件中添加代码 12345678from django.db import modelsclass Question(models.Model): question_text &#x3D; models.CharField(max_length&#x3D;200) pub_date &#x3D; models.DateTimeField(&#39;date published&#39;)class Choice(models.Model): question &#x3D; models.ForeignKey(Question, on_delete&#x3D;models.CASCADE) choice_text &#x3D; models.CharField(max_length&#x3D;200) votes &#x3D; models.IntegerField(default&#x3D;0) 在这里，==每个模型都是django.db.models.Model的子类==。每个模型都有许多类变量，每个类变量代表模型中的数据库字段。==每一个字段都是一个Field的实例==，不同的Field代表了不同类型的数据。 • 激活模型为了包含应用，需要将应用的引用添加在设置的INSTALLED_APPS中，也就是将polls.apps.PollsConfig添加到INSTALLED_APPS中 123456789INSTALLED_APPS &#x3D; [ &#39;polls.apps.PollsConfig&#39;, &#39;django.contrib.admin&#39;, &#39;django.contrib.auth&#39;, &#39;django.contrib.contenttypes&#39;, &#39;django.contrib.sessions&#39;, &#39;django.contrib.messages&#39;, &#39;django.contrib.staticfiles&#39;,] 1python manage.py makemigrations polls 表示对模型进行了一些修改，称之为迁移（migration），会生成一个polls/migrations/0001_initial.py文件，可以进行人工编辑。 1python manage.py sqlmigrate polls 0001 可以看到SQL中，进行了那些迁移操作。 注：1、数据表的名称是将应用名称和模型名称的小写组合起来自动生成的；2、Django将附加”_id”到外键字段名称。3、该sqlmigrate命令==实际上并未在数据库上运行迁移-而是将其打印到屏幕上==，以便您可以查看SQL Django认为需要的内容。这对于检查Django将要执行的操作或是否有需要SQL脚本进行更改的数据库管理员很有用。 1python manage.py check 检查项目中是否存在任何问题，而无需进行迁移或接触数据库 1python manage.py migrate 获取所有尚未应用的迁移，并针对数据库来运行它们，实际上就是根据之前的修改来改变数据库。 模型更改的三步： • 更改模型（在models.py中）。 • 运行为这些更改创建迁移 python manage.py makemigrations • 运行以将那些更改应用到数据库 python manage.py migrate Django Admin介绍admin是作为网站管理员存在 • 创建管理员用户1python manage.py createsuperuser 之后按提示信息输入内容（在输入密码的时候，可能会有密码无回显的情况，只需正常输入，不会有其他影响，我的环境是Python3.8+Django3.0） 然后运行服务器，输入http://127.0.0.1:8000/admin/会显示管理员登录界面： 注意这里输入的不是，这个网页出现的会是错误页面：修改polls/admin.py之后，应用就可以出现在管理员页面上。 123from django.contrib import adminfrom .models import Questionadmin.site.register(Question) 之后可以通过管理员界面对Question数据库进行修改。","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"}]},{"title":"Django-1","slug":"Django-1","date":"2020-01-19T09:39:15.000Z","updated":"2020-01-19T12:59:47.525Z","comments":true,"path":"2020/01/19/Django-1/","link":"","permalink":"http://codebiluo.cn/2020/01/19/Django-1/","excerpt":"","text":"• 创建项目1django-admin startproject mysite 创建了mysite目录： 12345678mysite&#x2F; manage.py #一个命令行实用程序，可让您以各种方式与该Django项目进行交互。 mysite&#x2F; __init__.py settings.py #此Django项目的设置&#x2F;配置。 urls.py #此Django项目的URL声明；Django支持的网站的“目录”。 asgi.py wsgi.py • 运行服务器1Python manage.py runserver 在浏览器中搜索http://127.0.0.1:8000/，就能看到Django火箭： • 创建应用程序（polls应用）项目和应用之间有什么区别？应用程序是执行某项操作的Web应用程序，例如Weblog系统，公共记录数据库或小型民意调查应用程序。项目是特定网站的配置和应用程序的集合。一个项目可以包含多个应用程序。一个应用程序可以在多个项目中。 1python manage.py startapp polls 创建了polls目录 123456789polls&#x2F; __init__.py admin.py apps.py migrations&#x2F; __init__.py models.py tests.py views.py • 第一个视图函数每一个请求的url地址，都对应着一个函数，叫视图函数，由视图函数处理请求后，再返回页面内容给浏览器显示。在polls/views.py中添加代码 1234from django.http import HttpResponsedef index(request): Return HttpResponse(&quot;Hello,world.You&#39;reatthepollsindex.&quot;) • 创建URL关系polls目录中创建URLconf，即创建一个urls.py文件，包含如下代码 1234567from django.urls import pathfrom . import viewsurlpatterns&#x3D;[path(&#39;&#39;, views.index, name&#x3D;&#39;index&#39;),] 在项目之下的urls.py文件（mysite/urls.py）中加入代码 1234567from django.contrib import adminfrom django.urls import include,pathurlpatterns&#x3D;[path(&#39;polls&#x2F;&#39;,include(&#39;polls.urls&#39;)),path(&#39;admin&#x2F;&#39;,admin.site.urls),] 重点：项目和应用之下urls.py文件的不同 123456# 项目下的urls.pyurlpatterns &#x3D; [ ... # 包含应用下的urls.py文件 url(正则表达式, include(&#39;应用名.urls&#39;))] 123456789101112131415# 应用下的urls.pyurlpatterns &#x3D; [ # 该path()函数传递了四个参数，两个是必需的 route和view， # 以及两个可选的kwargs和name。 path(route , view , kwargs , name), # route：route是包含URL模式的字符串。在处理请求时， # Django从第一个模式开始，urlpatterns然后沿列表向下移动， # 将请求的URL与每个模式进行比较，直到找到匹配的URL。 # view：当Django找到匹配的模式时，使用HttpRequest对象作为第一个参数， # 并将路线中所有“捕获的”值作为关键字参数，调用指定的view函数。 # name：命名URL可以使您在Django中的其他地方（尤其是在模板内部） # 明确地引用它。这项强大的功能可让您仅触摸单个文件 # 即可对项目的URL模式进行全局更改。]","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"}]}]}