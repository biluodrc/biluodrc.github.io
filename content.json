{"meta":{"title":"Biluo","subtitle":"There is nothing permanent except change","description":"","author":"Biluo","url":"http://codebiluo.cn","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-01-19T12:44:36.954Z","updated":"2020-01-19T12:44:36.954Z","comments":true,"path":"404.html","permalink":"http://codebiluo.cn/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"毕罗不是我的名字！","date":"2020-02-15T07:06:10.458Z","updated":"2020-02-15T07:06:10.458Z","comments":true,"path":"about/index.html","permalink":"http://codebiluo.cn/about/index.html","excerpt":"","text":"There‘s nothing permanent except CHANGE! 我是一个爱电影的成长期程序员，这里是我自己搭建的博客（用的是hexo+主题Material-X）。我会在这里分享技术、发布题解（然而我并不是ACM大佬，目前发布的都是一些LeetCode的题解），我还会聊一聊电影，写一些影评。望有缘人能有所收获，找到自己！！！ 由于题解过多，让博客显得臃肿，所以我将题解移到了GitBook上，这样大家看起来也可以更加方便！–（就是不知道有没有人看）–http://codebiluo.cn/myLeetCode/ 技术只是手段，兴趣才会带来改变，希望探索各种新鲜的事物（不仅只是技术哦）能成为各位永恒的兴趣。"},{"title":"link","date":"2020-01-19T07:41:07.000Z","updated":"2020-01-19T07:41:07.248Z","comments":true,"path":"link/index.html","permalink":"http://codebiluo.cn/link/index.html","excerpt":"","text":""},{"title":"朋友们","date":"2020-02-05T11:20:43.255Z","updated":"2020-02-05T11:20:43.255Z","comments":true,"path":"friends/index.html","permalink":"http://codebiluo.cn/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-01-19T09:05:44.000Z","updated":"2020-01-22T14:22:02.769Z","comments":true,"path":"categories/index.html","permalink":"http://codebiluo.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-19T09:32:34.000Z","updated":"2020-01-22T14:20:28.669Z","comments":true,"path":"tags/index.html","permalink":"http://codebiluo.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-08T06:52:48.354Z","updated":"2020-04-08T06:52:11.818Z","comments":true,"path":"connect6.html","permalink":"http://codebiluo.cn/connect6.html","excerpt":"","text":"很多版代码之后，当前x.y版codebiluo终于可以和我来一局焦灼的对局了！！！ 这一次的课设题目是自动六子棋，理解题目之后我就直接投身到论文的海洋，看了一段时间论文之后，初步确定自己先使用基于“路”的博弈树搜索，之后会详细讨论论文中出现的几种方法，以及我眼中各个方法之间的优劣。这篇博客主要是叙述（也是自己复习，毕竟我连α-β剪枝都打错了😭）代码中用到的新知识、论文中涉及的方法以及阅读顺序建议。 一、简述问题与思路六子棋对战是一个棋手双方博弈的过程，最终的目的就是根据当前的棋局确定下一步着法。一般首先想到的是遍历每一种着棋组合，对其评估，然后得到较优的解，这也是一般人下棋的策略；但是高手往往能知道对手的想法，预判对手的着棋，甚至是预判对手的预判。做到这一点，就是通过博弈树来实现。 知道了博弈树，就要了解该如何对博弈树进行搜索的问题。博弈树一般使用极大极小搜索方法或者是α-β搜索方法，后者是对前者的优化。我在编写代码时先编写了前者，到后者的改变实际只有四行代码。 博弈树中的每一个节点，对应了一个棋局，想要完成博弈，人类是通过对棋局进行感性的分析，而机器则是需要得到一个理性的结果，这个理性的结果就是对棋局的评估值，由评估函数得到。 想要评估棋局，最重要的是确定通过怎样的方式的到棋局的特征。在六子棋中，主要有基于“路”和基于“连珠”两种方式，我对二者的评价是：前者代码编写更容易，但只是得到了局部棋局的特征；后者分析棋局更加全面，与前者博弈时或许胜率会更高。所以我使用了基于“路”的方法😂。 以上加粗字，是截至4.8，connect6程序所使用的基本方法，下文中将对这些新知识进行介绍。 二、评估函数不同的棋局有着不一样的特征，我们需要通过分析棋局的特征，确定当前棋局对自己的有利程度，以及着棋之后棋局对自己的有利程度，从而得出该如何着棋。人类感性的评价计算机无法实现，我们需要做的是将感性的认识转换为理性的分析，从而评估一个棋局。 相关文献中从两个角度分析棋局，“路”与“连珠”，两个角度各有优劣，下面进行介绍， （一）基于”路“的评估函数所谓“路”就是指在棋盘上存在连续6个可能连成一线的点位[1]。也就是说，在水平、竖直、斜45°、斜135°的某个方向上，连续六个交叉点中黑子/白子的棋形称为“路”。 关于“路”的定义并不是很清晰，转化为代码的实现会更容易理解，从某一个交叉点开始，向四个个方向分别遍历六个交叉点（包括起点），记录黑子与白子的个数为B与W，分类讨论B和W的大小：如B、W都不为0，即两种棋子在这六个交叉点中同时出现，则将这一路定义为空路；如B、W都为0，即六个交叉点中没有任意一种棋子，则将这一路定义为空路；如B、W中不为0的一方的棋子数目为S，颜色为C，则将这一路定义为C S路，如白三路，黑四路。 根据“路”的定义，分析棋局可以知道，水平、竖直方向上共有19·(19-5)条路，斜45°、斜135°方向上共有(19-5)·(19-5)条路，也就是说六子棋19x19交叉点棋局进行全局扫描的总路数是924。这个数据在之后介绍局面的局部扫描时还会提到。 路的颜色为黑/白/空，路的数目为1、…、6，参考文献[2]中给出了基于“路”的评估函数：$$Score=Σ{i=1}^6(MyRoadNum[i]*RoadScore[i])-Σ{i=1}^6(OpRoadNum[i]*RoadScore[i])$$Score为对当前局面的评估值，MyRoadNum[i]为棋局中C为执棋方棋子颜色，S=i的路的总数，OpRoadNum[i]为棋局中C为对手棋子颜色，S=i的路的总数，RoadScore[i]为S=i的路所对应的在棋局中的权重。下面分析权重系数以及评估函数： 不同的路对棋局的影响是不同的，易知，S越大，C S路对棋局的影响越大。为了在评估函数中表现出这一点，使用的方法就是S越大，对应的权重系数越大，通过经验得到初步的权重系数：{1,5,10,25,35,10000}。权重系数的作用就是表现对应种类的路对棋局的影响。 分析评估函数之前，首先假定，对于当前执棋方，评估值Score越大，表明当前棋局对自己更有利。在此基础上，评估函数就可以用下面的一段话来理解：执棋方颜色的路越多、对应权重系数大的路越多，则评估函数中前一个求和项的数值更大，表明棋局对执棋方更加有利；对手方颜色的路越少、对应权重系数大的路越少，则评估函数中后一个求和项的数值更大，表明棋局对执棋方更加不利。（最开始阅读论文的时候我并不理解这个评估函数，一直想不通为什么对手方的权重系数也是递增的，直到有一天下午灵光一现，理解了这个评估函数的意义） （二）基于”连珠“的评估函数在一个区间中,所有的同色的交叉点构成的序列,称为连珠。连珠是与一般人思考方式相近的一种棋局特征的表达，比如在五子棋中有活三、眠3等术语，对应了不同的着棋策略。五子棋中的策略可以类比到六子棋，比如对于着棋方的活四或活五，应采取直接落子在活四两端；对手方的活三，倾向于在其一端落下一子，将其转换为眠三，这样就算对手想要继续在这一连珠做文章，最多也只能达到眠5…… 连珠可以表现某一棋形的连通程度、对手的威胁以及棋形的进攻防守能力，基于这三方面，可以将连珠进行分类。除此之外，连珠还有很重要的一点就是不同种类连珠之间的演化，比如上面举出的眠三落两子变为眠五，活四落两子可以冲六等等，记录他们之间的演化可以加快对局面的分析，从而加速搜索。 参考文献[3]详细介绍了基于连珠模式的六子棋博弈系统，其中提到连珠形状共有1048512种，通过上面三种方面可以将连珠分成12种类型，并通过一个经过论证的hash函数，可以完成连珠形状搜索的加速。这篇论文中还涉及很多本文中没有提到的搜索方法以及一些优化策略，十分建议阅读，但是伴随的问题是论文涉及的技术太多，想要短时间复现代码实在困难，所以在部分阅读之后我没有选择基于“连珠”的方法。 基于”连珠“的评估函数也可以使用与基于“路”的评估函数相同的方法，即评估值等于不同类型连珠的加权和。但是参考文献[3]中先从三个方面对局面进行评估：首先是开局阶段对于静态位置的评估，这一点是根据经验，先脱离双方激烈拼杀区域者将处于劣势，故设置第一枚落子一定在天元，同时添加一个位置偏移表，来保证棋局以中心开局；其次考虑不同连珠的权重，还是使用类似“路”估值函数的加权和形式，但是作者使用了先对第一个落子进行评估，然后根据第一个落子下落后的局面评估值，指导第二个落子的下落，其他论文都是采用两枚棋子落下之后的局面进行评估，下文α-β搜索方法中会说明这么做的意义；最后一点是动态因素的估值，这部分在我看来是个性化的判断，比如说本来已经要赢了，但是偏偏不下在终结棋局的位置，反而落子到其他位置，略略略，其实是我并不太理解动态因素的估值。同时论文中还提到基于交叉点的评估，这一步是将可选点进行桶排序，每一次博弈从有序着棋点序列中选择着棋点，这个方法可以对搜索进行极大的优化，我可能会在之后的优化中使用这个方法。 （三）基于“路”的局部扫描方式上文提到六子棋19x19交叉点棋局进行全局扫描的总路数是924，乍一看这并不是一个很大的数字，因为总共访问的交叉点个数也就是924(路)·4(方向数)·6(每个方向访问的交叉点数目)=22176个交叉点。但是当考虑到其庞大的子节点个数的时候，这个数字就变得非常恐怖。参考文献[4]就提出了基于“路”的局部扫描方式，这个方法是从当前局面出发，对不同的着棋点进行模拟落子，在新的局面中，模拟落子只会影响它四个方向上的各条路。假设父节点原本的评估值为Vtotal，受影响的路原本的评估值为Vbefor，受影响的路落子后的评估值为Vafter，落子后局面的评估值Vtotal’也就是：$$V_{total}’=V_{total}-V_{befor}+V_{after}$$全局扫描不难，按照定义逐个方向扫描即可，只需要注意不要重复计算同一个路即可。 三、博弈树及其搜索方法（一）博弈树最开始在论文中看到博弈树，我想起之前学过的决策树，这两者之间的关系可以用下面这段话来表示： 决策树适用于一个人面临各种选择时的描述分析，而博弈树则适用于多个参与者在一场策略博弈中的决策次序的描述分析。 完整的博弈树，考虑到从开局落下第一个子，到最终无论是和局，还是输赢的所有过程，想象这样一个画面，确定第一个落子为天元，开局局面为根节点，之后的落子为任意的两个交叉点，第二层就有大约19^4个节点，这仅仅是第二层，第二层每个节点之下又会有大约19^4个节点，完整的博弈树，是无法想象的庞大（当然只是笼统的统计）。所以实际编程时，我们实际是生成一颗搜索树——博弈树的子树。（但下文有时仍然使用博弈树，但需要知道，下文的博弈树仅仅是完整博弈树的一个小小子树） 博弈树中用树的各层来表示对弈双方：第一层为初始局面，表示着棋方，第二层也就是对手，以此类推，也就是奇数层代表着棋方，偶数层代表对手。树的节点来表示各种棋局，节点之间的连线可以想象成着棋的动作。最终目标是着棋方选择从初始局面（第一层）转换到第二层中的哪一个局面；为更好的达到这一个目标，就需要通过分析自己落子之后，对手会如何落子（从第二层到第三层）；更进一步，还要分析在对手落子之后，我还会怎么做（第三层到第四层）；以此类推，这样的过程有些像博弈论中的共同知识——我知道，你知道，我知道你知道，你知道我知道你知道…… 对于着棋方而言，希望能放大自己的优势，或者是缩小自己的劣势；对于对手而言，希望能缩小着棋方的优势，后者是放大着棋方的优势，这些都是通过对比不同落子的局面评估值之间的关系来实现的。着棋方（奇数层）遍历自己的各种着棋可能，计算他们的评估值，并将自己的评估值更新为子节点评估值中的最大值，故称奇数层为MAX层；而对手（偶数层）也是遍历自己的各种着棋可能，计算他们的评估值，并将自己的评估值更新为子节点评估值中的最小值，称为MIN层。 通过上面这个概念，也就引出了博弈树的一种搜索方法——极大极小搜索。 （二）极大极小搜索极大极小搜索的过程类似于深搜，只不过前者给每一层节点添加了一个MAX/MIN的属性，根据这个属性决定自己节点的值（除了叶节点）。具体的过程如下： 对一颗树进行深搜，叶节点的值也就是原本节点中对应的数；非叶节点的值，是根据自己的MAX/MIN属性，选择其子节点中最大/最小的数。 通过过程图示会更好理解这个极大极小搜索： 这是一个已经搜索完成的搜索树，其中矩形节点表示MAX节点，椭圆形节点表示MIN节点。 搜索的过程可以表现为 （二）α-β剪枝α-β剪枝是对极大极小搜索的优化，优化的效果十分明显。α-β剪枝分为α剪枝和β剪枝： 1、α剪枝α剪枝是基于根节点为MAX节点，对第三层节点进行剪枝，α值保存了已被搜索的第二层节点中目前的最大值，即局部搜索最优结果。初始化α值为-∞，搜索时不断更新，当第二层某个节点的子节点评估值比α值小时，那么就没有必要对第二层的这个节点剩下的子节点进行搜索，因为搜索的结果无论如何不会超过当前的子节点评估值。 2、β剪枝β剪枝是基于根节点为MIN节点，对第三层节点进行剪枝，β值保存了已被搜索的第二层节点中目前的最小值，即局部搜索最差结果。初始化β值为+∞，搜索时不断更新，当第二层某个节点的子节点评估值比β值大时，那么就没有必要对第二层的这个节点剩下的子节点进行搜索，因为搜索的结果无论如何不会小于当前的子节点评估值。 需要注意的是，剪枝并不是只能发生在这样的只有三层的树中，实际上对于搜索树中每一个三层的子树都可以完成对第三层（其实也是对第二层）的剪枝。 （三）剪枝的效率问题回到（一）中给定的搜索树，手动跑一遍α剪枝，可以发现根本就没有剪枝，这是为什么呢？剪枝是出现过的对根节点较优的值，对之后出现的不如该值优越的子节点的剪枝，所以将能产生较优结果的节点（或者说是着棋方式）放在前面，优先遍历，才能更好的对之后的节点进行剪枝。 四、未使用的方法（一）同型表评估函数是对局面进行评估，落子的顺序对其并没有影响，搜索时，可能会产生已经搜索过的子节点，这时可以直接将该子节点连到当前父节点上。这个方法是搜索加速的一种方法。 （二）开局库参考文献[3]中指出，在国际象棋、中国象棋、西洋跳棋中,其计算机程序几乎都采用了开局库。事实证明,开局库的存在大大提高了程序的对弈水平。然而不同的棋类中,开局库的重要程度也有所不同。在六子棋中,由于广泛地存在着决定胜负的迫着,所以开局很重要,因为开局时的“一着错”可能马上就导致了“满盘输”。文献中采用”枚举+迫着搜索“的方法，生成开局库。之后可能会添加这个方法，待续。 （三）迭代加深搜索这也是深搜的一种，与深搜的主要区别是 这个算法理解不够深，但使用它的原因是开局时棋子太少，没必要进行太深的搜索，所以先使用较浅的搜索，并且还可以对之后的搜索有”历史启发“。 （四）双评价参数评估函数这个方法是[2]中提到的，除了上文中所说的评价函数之外，还引入一个阈值，用于区别当前的局面对对手更优，还是对自己更优，并且对手与自己的路的权值不同。局面对自己更优时，己方路的权值相对大一些；局面对地方更优时，对方路的权值相对大一些。 五、优化添加的优化方式，是进行候选着棋点的排序，用以增强α-β剪枝的效率。 这一点很多论文中步骤都有，但没有找到特别详细的说明，编写代码的时候忽然想到将简单的连珠模式判断加入候选点的排序中，具体步骤如下： （1）生成候选着棋点对序列； （2）以着棋点为中心向两边扩展，并保存端点两侧交叉点颜色（对手颜色或者是空）； （3）如为死棋（两侧都为对手颜色），直接继续遍历其他方向；之后将连珠大致分为活/眠2/3/4/5以及killer6，并赋予一定权重{1，2，3，4，5，6，7，8，9，10，100}； （4）根据候选点周围连珠类型的加权和对候选点序列进行排序； 六、参考文献[1]闵文杰. 六子棋计算机博弈关键技术研究[D].重庆交通大学,2010. [2]齐祎霏. 六子棋中基于路的双评价参数评估函数的研究与应用[D].北京工业大学,2018. [3]徐长明. 基于连珠模式的六子棋机器博弈关键技术研究[D].东北大学,2010. [4]李学俊,王小龙,吴蕾,刘慧婷.六子棋中基于局部“路”扫描方式的博弈树生成算法[J].智能系统学报,2015,10(02):267-272. 如果使用连珠模式的机器博弈，那么阅读[3]即可，再辅助搜索相关概念，有时一些博客里的的讲解更加清晰，毕竟论文还是有很多复杂的证明…… 如果使用路模式的机器博弈，可以先认真阅读[4]，这样对整体的方法会有一个了解；然后[2]引入了一些新的方法，用于优化系统；最后[1]和[3]都是非常详细的介绍了相关算法和一些启发式方法。"}],"posts":[{"title":"Auto Minesweeper","slug":"connect6","date":"2020-04-08T06:56:25.000Z","updated":"2020-04-08T07:01:19.646Z","comments":true,"path":"2020/04/08/connect6/","link":"","permalink":"http://codebiluo.cn/2020/04/08/connect6/","excerpt":"","text":"很多版代码之后，当前x.y版codebiluo终于可以和我来一局焦灼的对局了！！！ 这一次的课设题目是自动六子棋，理解题目之后我就直接投身到论文的海洋，看了一段时间论文之后，初步确定自己先使用基于“路”的博弈树搜索，之后会详细讨论论文中出现的几种方法，以及我眼中各个方法之间的优劣。这篇博客主要是叙述（也是自己复习，毕竟我连α-β剪枝都打错了😭）代码中用到的新知识、论文中涉及的方法以及阅读顺序建议。 一、简述问题与思路六子棋对战是一个棋手双方博弈的过程，最终的目的就是根据当前的棋局确定下一步着法。一般首先想到的是遍历每一种着棋组合，对其评估，然后得到较优的解，这也是一般人下棋的策略；但是高手往往能知道对手的想法，预判对手的着棋，甚至是预判对手的预判。做到这一点，就是通过博弈树来实现。 知道了博弈树，就要了解该如何对博弈树进行搜索的问题。博弈树一般使用极大极小搜索方法或者是α-β搜索方法，后者是对前者的优化。我在编写代码时先编写了前者，到后者的改变实际只有四行代码。 博弈树中的每一个节点，对应了一个棋局，想要完成博弈，人类是通过对棋局进行感性的分析，而机器则是需要得到一个理性的结果，这个理性的结果就是对棋局的评估值，由评估函数得到。 想要评估棋局，最重要的是确定通过怎样的方式的到棋局的特征。在六子棋中，主要有基于“路”和基于“连珠”两种方式，我对二者的评价是：前者代码编写更容易，但只是得到了局部棋局的特征；后者分析棋局更加全面，与前者博弈时或许胜率会更高。所以我使用了基于“路”的方法😂。 以上加粗字，是截至4.8，connect6程序所使用的基本方法，下文中将对这些新知识进行介绍。 二、评估函数不同的棋局有着不一样的特征，我们需要通过分析棋局的特征，确定当前棋局对自己的有利程度，以及着棋之后棋局对自己的有利程度，从而得出该如何着棋。人类感性的评价计算机无法实现，我们需要做的是将感性的认识转换为理性的分析，从而评估一个棋局。 相关文献中从两个角度分析棋局，“路”与“连珠”，两个角度各有优劣，下面进行介绍， （一）基于”路“的评估函数所谓“路”就是指在棋盘上存在连续6个可能连成一线的点位[1]。也就是说，在水平、竖直、斜45°、斜135°的某个方向上，连续六个交叉点中黑子/白子的棋形称为“路”。 关于“路”的定义并不是很清晰，转化为代码的实现会更容易理解，从某一个交叉点开始，向四个个方向分别遍历六个交叉点（包括起点），记录黑子与白子的个数为B与W，分类讨论B和W的大小：如B、W都不为0，即两种棋子在这六个交叉点中同时出现，则将这一路定义为空路；如B、W都为0，即六个交叉点中没有任意一种棋子，则将这一路定义为空路；如B、W中不为0的一方的棋子数目为S，颜色为C，则将这一路定义为C S路，如白三路，黑四路。 根据“路”的定义，分析棋局可以知道，水平、竖直方向上共有19·(19-5)条路，斜45°、斜135°方向上共有(19-5)·(19-5)条路，也就是说六子棋19x19交叉点棋局进行全局扫描的总路数是924。这个数据在之后介绍局面的局部扫描时还会提到。 路的颜色为黑/白/空，路的数目为1、…、6，参考文献[2]中给出了基于“路”的评估函数：$$Score=Σ{i=1}^6(MyRoadNum[i]*RoadScore[i])-Σ{i=1}^6(OpRoadNum[i]*RoadScore[i])$$Score为对当前局面的评估值，MyRoadNum[i]为棋局中C为执棋方棋子颜色，S=i的路的总数，OpRoadNum[i]为棋局中C为对手棋子颜色，S=i的路的总数，RoadScore[i]为S=i的路所对应的在棋局中的权重。下面分析权重系数以及评估函数： 不同的路对棋局的影响是不同的，易知，S越大，C S路对棋局的影响越大。为了在评估函数中表现出这一点，使用的方法就是S越大，对应的权重系数越大，通过经验得到初步的权重系数：{1,5,10,25,35,10000}。权重系数的作用就是表现对应种类的路对棋局的影响。 分析评估函数之前，首先假定，对于当前执棋方，评估值Score越大，表明当前棋局对自己更有利。在此基础上，评估函数就可以用下面的一段话来理解：执棋方颜色的路越多、对应权重系数大的路越多，则评估函数中前一个求和项的数值更大，表明棋局对执棋方更加有利；对手方颜色的路越少、对应权重系数大的路越少，则评估函数中后一个求和项的数值更大，表明棋局对执棋方更加不利。（最开始阅读论文的时候我并不理解这个评估函数，一直想不通为什么对手方的权重系数也是递增的，直到有一天下午灵光一现，理解了这个评估函数的意义） （二）基于”连珠“的评估函数在一个区间中,所有的同色的交叉点构成的序列,称为连珠。连珠是与一般人思考方式相近的一种棋局特征的表达，比如在五子棋中有活三、眠3等术语，对应了不同的着棋策略。五子棋中的策略可以类比到六子棋，比如对于着棋方的活四或活五，应采取直接落子在活四两端；对手方的活三，倾向于在其一端落下一子，将其转换为眠三，这样就算对手想要继续在这一连珠做文章，最多也只能达到眠5…… 连珠可以表现某一棋形的连通程度、对手的威胁以及棋形的进攻防守能力，基于这三方面，可以将连珠进行分类。除此之外，连珠还有很重要的一点就是不同种类连珠之间的演化，比如上面举出的眠三落两子变为眠五，活四落两子可以冲六等等，记录他们之间的演化可以加快对局面的分析，从而加速搜索。 参考文献[3]详细介绍了基于连珠模式的六子棋博弈系统，其中提到连珠形状共有1048512种，通过上面三种方面可以将连珠分成12种类型，并通过一个经过论证的hash函数，可以完成连珠形状搜索的加速。这篇论文中还涉及很多本文中没有提到的搜索方法以及一些优化策略，十分建议阅读，但是伴随的问题是论文涉及的技术太多，想要短时间复现代码实在困难，所以在部分阅读之后我没有选择基于“连珠”的方法。 基于”连珠“的评估函数也可以使用与基于“路”的评估函数相同的方法，即评估值等于不同类型连珠的加权和。但是参考文献[3]中先从三个方面对局面进行评估：首先是开局阶段对于静态位置的评估，这一点是根据经验，先脱离双方激烈拼杀区域者将处于劣势，故设置第一枚落子一定在天元，同时添加一个位置偏移表，来保证棋局以中心开局；其次考虑不同连珠的权重，还是使用类似“路”估值函数的加权和形式，但是作者使用了先对第一个落子进行评估，然后根据第一个落子下落后的局面评估值，指导第二个落子的下落，其他论文都是采用两枚棋子落下之后的局面进行评估，下文α-β搜索方法中会说明这么做的意义；最后一点是动态因素的估值，这部分在我看来是个性化的判断，比如说本来已经要赢了，但是偏偏不下在终结棋局的位置，反而落子到其他位置，略略略，其实是我并不太理解动态因素的估值。同时论文中还提到基于交叉点的评估，这一步是将可选点进行桶排序，每一次博弈从有序着棋点序列中选择着棋点，这个方法可以对搜索进行极大的优化，我可能会在之后的优化中使用这个方法。 （三）基于“路”的局部扫描方式上文提到六子棋19x19交叉点棋局进行全局扫描的总路数是924，乍一看这并不是一个很大的数字，因为总共访问的交叉点个数也就是924(路)·4(方向数)·6(每个方向访问的交叉点数目)=22176个交叉点。但是当考虑到其庞大的子节点个数的时候，这个数字就变得非常恐怖。参考文献[4]就提出了基于“路”的局部扫描方式，这个方法是从当前局面出发，对不同的着棋点进行模拟落子，在新的局面中，模拟落子只会影响它四个方向上的各条路。假设父节点原本的评估值为Vtotal，受影响的路原本的评估值为Vbefor，受影响的路落子后的评估值为Vafter，落子后局面的评估值Vtotal’也就是：$$V_{total}’=V_{total}-V_{befor}+V_{after}$$全局扫描不难，按照定义逐个方向扫描即可，只需要注意不要重复计算同一个路即可。 三、博弈树及其搜索方法（一）博弈树最开始在论文中看到博弈树，我想起之前学过的决策树，这两者之间的关系可以用下面这段话来表示： 决策树适用于一个人面临各种选择时的描述分析，而博弈树则适用于多个参与者在一场策略博弈中的决策次序的描述分析。 完整的博弈树，考虑到从开局落下第一个子，到最终无论是和局，还是输赢的所有过程，想象这样一个画面，确定第一个落子为天元，开局局面为根节点，之后的落子为任意的两个交叉点，第二层就有大约19^4个节点，这仅仅是第二层，第二层每个节点之下又会有大约19^4个节点，完整的博弈树，是无法想象的庞大（当然只是笼统的统计）。所以实际编程时，我们实际是生成一颗搜索树——博弈树的子树。（但下文有时仍然使用博弈树，但需要知道，下文的博弈树仅仅是完整博弈树的一个小小子树） 博弈树中用树的各层来表示对弈双方：第一层为初始局面，表示着棋方，第二层也就是对手，以此类推，也就是奇数层代表着棋方，偶数层代表对手。树的节点来表示各种棋局，节点之间的连线可以想象成着棋的动作。最终目标是着棋方选择从初始局面（第一层）转换到第二层中的哪一个局面；为更好的达到这一个目标，就需要通过分析自己落子之后，对手会如何落子（从第二层到第三层）；更进一步，还要分析在对手落子之后，我还会怎么做（第三层到第四层）；以此类推，这样的过程有些像博弈论中的共同知识——我知道，你知道，我知道你知道，你知道我知道你知道…… 对于着棋方而言，希望能放大自己的优势，或者是缩小自己的劣势；对于对手而言，希望能缩小着棋方的优势，后者是放大着棋方的优势，这些都是通过对比不同落子的局面评估值之间的关系来实现的。着棋方（奇数层）遍历自己的各种着棋可能，计算他们的评估值，并将自己的评估值更新为子节点评估值中的最大值，故称奇数层为MAX层；而对手（偶数层）也是遍历自己的各种着棋可能，计算他们的评估值，并将自己的评估值更新为子节点评估值中的最小值，称为MIN层。 通过上面这个概念，也就引出了博弈树的一种搜索方法——极大极小搜索。 （二）极大极小搜索极大极小搜索的过程类似于深搜，只不过前者给每一层节点添加了一个MAX/MIN的属性，根据这个属性决定自己节点的值（除了叶节点）。具体的过程如下： 对一颗树进行深搜，叶节点的值也就是原本节点中对应的数；非叶节点的值，是根据自己的MAX/MIN属性，选择其子节点中最大/最小的数。 通过过程图示会更好理解这个极大极小搜索： 这是一个已经搜索完成的搜索树，其中矩形节点表示MAX节点，椭圆形节点表示MIN节点。 搜索的过程可以表现为 （二）α-β剪枝α-β剪枝是对极大极小搜索的优化，优化的效果十分明显。α-β剪枝分为α剪枝和β剪枝： 1、α剪枝α剪枝是基于根节点为MAX节点，对第三层节点进行剪枝，α值保存了已被搜索的第二层节点中目前的最大值，即局部搜索最优结果。初始化α值为-∞，搜索时不断更新，当第二层某个节点的子节点评估值比α值小时，那么就没有必要对第二层的这个节点剩下的子节点进行搜索，因为搜索的结果无论如何不会超过当前的子节点评估值。 2、β剪枝β剪枝是基于根节点为MIN节点，对第三层节点进行剪枝，β值保存了已被搜索的第二层节点中目前的最小值，即局部搜索最差结果。初始化β值为+∞，搜索时不断更新，当第二层某个节点的子节点评估值比β值大时，那么就没有必要对第二层的这个节点剩下的子节点进行搜索，因为搜索的结果无论如何不会小于当前的子节点评估值。 需要注意的是，剪枝并不是只能发生在这样的只有三层的树中，实际上对于搜索树中每一个三层的子树都可以完成对第三层（其实也是对第二层）的剪枝。 （三）剪枝的效率问题回到（一）中给定的搜索树，手动跑一遍α剪枝，可以发现根本就没有剪枝，这是为什么呢？剪枝是出现过的对根节点较优的值，对之后出现的不如该值优越的子节点的剪枝，所以将能产生较优结果的节点（或者说是着棋方式）放在前面，优先遍历，才能更好的对之后的节点进行剪枝。 四、未使用的方法（一）同型表评估函数是对局面进行评估，落子的顺序对其并没有影响，搜索时，可能会产生已经搜索过的子节点，这时可以直接将该子节点连到当前父节点上。这个方法是搜索加速的一种方法。 （二）开局库参考文献[3]中指出，在国际象棋、中国象棋、西洋跳棋中,其计算机程序几乎都采用了开局库。事实证明,开局库的存在大大提高了程序的对弈水平。然而不同的棋类中,开局库的重要程度也有所不同。在六子棋中,由于广泛地存在着决定胜负的迫着,所以开局很重要,因为开局时的“一着错”可能马上就导致了“满盘输”。文献中采用”枚举+迫着搜索“的方法，生成开局库。之后可能会添加这个方法，待续。 （三）迭代加深搜索这也是深搜的一种，与深搜的主要区别是 这个算法理解不够深，但使用它的原因是开局时棋子太少，没必要进行太深的搜索，所以先使用较浅的搜索，并且还可以对之后的搜索有”历史启发“。 （四）双评价参数评估函数这个方法是[2]中提到的，除了上文中所说的评价函数之外，还引入一个阈值，用于区别当前的局面对对手更优，还是对自己更优，并且对手与自己的路的权值不同。局面对自己更优时，己方路的权值相对大一些；局面对地方更优时，对方路的权值相对大一些。 五、优化添加的优化方式，是进行候选着棋点的排序，用以增强α-β剪枝的效率。 这一点很多论文中步骤都有，但没有找到特别详细的说明，编写代码的时候忽然想到将简单的连珠模式判断加入候选点的排序中，具体步骤如下： （1）生成候选着棋点对序列； （2）以着棋点为中心向两边扩展，并保存端点两侧交叉点颜色（对手颜色或者是空）； （3）如为死棋（两侧都为对手颜色），直接继续遍历其他方向；之后将连珠大致分为活/眠2/3/4/5以及killer6，并赋予一定权重{1，2，3，4，5，6，7，8，9，10，100}； （4）根据候选点周围连珠类型的加权和对候选点序列进行排序； 六、参考文献[1]闵文杰. 六子棋计算机博弈关键技术研究[D].重庆交通大学,2010. [2]齐祎霏. 六子棋中基于路的双评价参数评估函数的研究与应用[D].北京工业大学,2018. [3]徐长明. 基于连珠模式的六子棋机器博弈关键技术研究[D].东北大学,2010. [4]李学俊,王小龙,吴蕾,刘慧婷.六子棋中基于局部“路”扫描方式的博弈树生成算法[J].智能系统学报,2015,10(02):267-272. 如果使用连珠模式的机器博弈，那么阅读[3]即可，再辅助搜索相关概念，有时一些博客里的的讲解更加清晰，毕竟论文还是有很多复杂的证明…… 如果使用路模式的机器博弈，可以先认真阅读[4]，这样对整体的方法会有一个了解；然后[2]引入了一些新的方法，用于优化系统；最后[1]和[3]都是非常详细的介绍了相关算法和一些启发式方法。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://codebiluo.cn/categories/Algorithm/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://codebiluo.cn/tags/basic/"}]},{"title":"HTML初探笔记","slug":"HTMLfirstExploration","date":"2020-03-05T07:12:34.000Z","updated":"2020-03-11T05:19:24.800Z","comments":true,"path":"2020/03/05/HTMLfirstExploration/","link":"","permalink":"http://codebiluo.cn/2020/03/05/HTMLfirstExploration/","excerpt":"","text":"这篇文章不作为分享，只是我学习前端的笔记，摘抄网上关于HTML的教程。如想学习这方面的知识，十分不建议看这样的摘要式笔记！ 一、代码解读123456789101112131415161718192021222324&lt;html&gt;&lt;body style=\"background-color: PowderBlue\"&gt; &lt;h1 align=\"center\"&gt; 标题1 &lt;/h1&gt; &lt;h2&gt; 标题2 &lt;/h2&gt; &lt;h3&gt; 标题3 &lt;/h3&gt; &lt;h4&gt; 标题4 &lt;/h4&gt; &lt;p&gt; 段落1 &lt;/p&gt; &lt;hr /&gt; &lt;p&gt; 段落 2 &lt;/p&gt; &lt;!-- 这是注释 --&gt; &lt;a href = \"http://www.codebiluo.cn\"&gt;a link &lt;/a&gt; &lt;br /&gt; &lt;img src = \"https://ae01.alicdn.com/kf/Ueb18a569429c4c6eb8545b0f6f7fcbd5g.jpg\" width=\"200\" height=\"200\" /&gt; &lt;table border=15&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;6&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324251、&lt;html&gt; 与 &lt;&#x2F;html&gt; 之间的文本描述网页，定义了整个 HTML 文档。2、&lt;body&gt; 与 &lt;&#x2F;body&gt; 之间的文本是可见的页面内容。&lt;body bgcolor&#x3D;&quot;white&quot;&gt;中bgcolor属性更改了背景颜色。3、&lt;h1&gt; 与 &lt;&#x2F;h1&gt; 之间的文本被显示为标题，HTML 标题（Heading）是通过 &lt;h1&gt; - &lt;h6&gt; 等标签进行定义的。&lt;h1 align&#x3D;&quot;center&quot;&gt;中align属性使标题进行了居中排列。head的缩写4、&lt;p&gt; 与 &lt;&#x2F;p&gt; 之间的文本被显示为段落。paragraph的缩写5、HTML 链接是通过 &lt;a&gt; 标签进行定义的，在 href 属性中指定链接的地址。（在a link之前的空格都会被忽略）（这里的www.codebiluo.cn是不可访问的，他是以当前文本所在路径进行相对路径访问）anchor text的缩写，锚文本6、HTML 图像是通过 &lt;img&gt; 标签进行定义的，图像的名称和尺寸是以属性的形式提供的。7、&lt;br&gt;就是没有关闭标签的空元素（&lt;br&gt; 标签定义换行）。在开始标签中添加斜杠，比如 &lt;br &#x2F;&gt;，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。即使&lt;br&gt;在所有浏览器中都是有效的，但使用&lt;br &#x2F;&gt;其实是更长远的保障。barter rabbet的缩写8、&lt;hr&#x2F;&gt;标签在 HTML 页面中创建水平线。horizontal rule的缩写9、&lt;!-- --&gt;用于添加注释。10、表格由 &lt;table&gt; 标签来定义。每个表格均有若干行（由 &lt;tr&gt; 标签定义），每行被分割为若干单元格（由 &lt;td&gt; 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。表格的表头使用 &lt;th&gt; 标签进行定义。 二、HTML元素HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。开始标签常被称为开放标签（opening tag），结束标签常称为闭合标签（closing tag）。 元素语法 HTML 元素以开始标签起始 HTML 元素以结束标签终止 （包括标签都是元素的一部分） 元素的内容是开始标签与结束标签之间的内容 某些 HTML 元素具有空内容（empty content）（在HTML元素中，没有内容的 HTML 元素被称为空元素。） 空元素在开始标签中进行关闭（以开始标签的结束而结束） 大多数 HTML 元素可拥有属性 大多数 HTML 元素可以嵌套（可以包含其他 HTML 元素）。 三、HTML 属性HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。 属性总是以名称/值对的形式出现，比如：name=”value”。 属性总是在 HTML 元素的开始标签中规定。 属性值应该始终被包括在引号内。双引号是最常用的，不过使用单引号也没有问题。在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如： 1name='Bill \"HelloWorld\" Gates' 全局属性，可用于所有的HTML 元素！！ 属性 描述 accesskey 规定激活元素的快捷键。用Alt+“ ”来快捷访问。 class 规定元素的一个或多个类名（引用样式表中的类）。 contenteditable 规定元素内容是否可编辑。 contextmenu 规定元素的上下文菜单。上下文菜单在用户点击元素时显示。 data-* 用于存储页面或应用程序的私有定制数据。 dir 规定元素中内容的文本方向。rtl：文本从左往右；ltr：文本从右往左。 draggable 规定元素是否可拖动。链接和图像默认是可拖动的。draggable 属性常用在拖放操作中。 dropzone 规定在拖动被拖动数据时是否进行复制、移动或链接。 hidden 规定元素仍未或不再相关。hidden 属性也可用于防止用户查看元素，直到匹配某些条件（比如选择了某个复选框）。然后，JavaScript 可以删除 hidden 属性，以使此元素可见。 id 规定元素的唯一 id。id 属性可用作链接锚（link anchor），通过 JavaScript（HTML DOM）或通过 CSS 为带有指定 id 的元素改变或添加样式。 lang 规定元素内容的语言。 spellcheck 规定是否对元素进行拼写和语法检查。 style 规定元素的行内 CSS 样式。style 属性规定元素的行内样式（inline style）。style 属性将覆盖任何全局的样式设定，例如在style标签或在外部样式表中规定的样式。 tabindex 规定元素的 tab 键次序。 title 规定有关元素的额外信息。这些信息通常会在鼠标移到元素上时显示一段工具提示文本（tooltip text）。title 属性常与 form 以及 a 元素一同使用，以提供关于输入格式和链接目标的信息。同时它也是 abbr 和 acronym 元素的必需属性。 translate 规定是否应该翻译元素内容。 四、HTML 标题浏览器会自动地在标题的前后添加空行。 默认情况下，HTML 会自动地在块级元素前后添加一个额外的空行，比如段落、标题元素前后。 用&lt;hr/&gt; 标签在 HTML 页面中创建水平线。（注意这里标签需要闭合，中间不能有空格）（好像看到这东西不建议使用，但想想也确实，一个网页中那么多需要有那么多需要考虑格式的地方，如果单纯的只用这些标签来完成，是不现实的,实际上是用级联样式表CSS完成的）（随便打开一个网页，里面根本没使用 &lt;hr&gt; &lt;br&gt;这样的标签，注释的方式倒是很多） 五、HTML 段落浏览器会自动地在段落的前后添加空行。虽然闭合标签不加浏览器也能识别，但还是一定要注意添加。 如果您希望在不产生一个新段落的情况下进行换行（新行），可以使用 &lt;br&gt;标签： 1&lt;p&gt;This is&lt;br /&gt;a para&lt;br /&gt;graph with line breaks&lt;/p&gt; 额外空行/空格会被处理为一个空格！ 对于 HTML，您无法通过在 HTML 代码中添加额外的空格或换行来改变输出的效果。 当显示页面时，浏览器会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。需要注意的是，HTML 代码中的所有连续的空行（换行）也被显示为一个空格。（包括段落里的内容）这时可以使用 pre 预格式文本，这样可以保留空格和换行。 六、HTML 样式这个应该才是html中调整布局、形状 、颜色的属性，之前Django中的静态文件中经常见到这个 style 属性的作用：提供了一种改变所有 HTML 元素的样式的通用方法。 样式是 HTML 4 引入的，它是一种新的首选的改变 HTML 元素样式的方式。通过 HTML 样式，能够通过使用 style 属性直接将样式添加到 HTML 元素，或者间接地在独立的样式表中（CSS 文件）进行定义。 应该避免使用下面这些标签和属性： 1234&lt;center&gt;：定义居中的内容。&lt;font&gt;和&lt;basefont&gt;：定义HTML字体。&lt;s&gt;和&lt;strike&gt;：定义删除线文本&lt;u&gt;：定义下划线文本 属性 描述 align 定义文本的对齐方式 bgcolor 定义背景颜色 color 定义文本颜色 为什么 &lt;hrml&gt;会有一部风标签被废除?因为html只有一个作用,就是用来添加语义的,早期一些html标签是没有语义的,是用来修改样式的,所以这部分标签就被淘汰了 样式实例： 功能 属性 背景颜色 background-color 字体 front-family 文本颜色 color 文本尺寸 font-size 文本对齐 text-align ！！！请记住这些物理样式标签对紧接的文本产生的强烈效果。要实现在整个文档范围内对文本显示的全面控制，请使用样式表。 七、HTML 文本格式化（1）文本格式化标签1234567891011121314 标签 描述&lt;b&gt; 定义粗体文本。&lt;big&gt; 定义大号字。&lt;em&gt; 定义着重文字。&lt;i&gt; 定义斜体字。&lt;small&gt; 定义小号字。&lt;strong&gt; 定义加重语气。&lt;sub&gt; 定义下标字。&lt;sup&gt; 定义上标字。&lt;ins&gt; 定义插入字。&lt;del&gt; 定义删除字。&lt;s&gt; 不赞成使用。使用 &lt;del&gt; 代替。&lt;strike&gt; 不赞成使用。使用 &lt;del&gt; 代替。&lt;u&gt; 不赞成使用。使用样式（style）代替。 （2）“计算机输出”标签12345678910 标签 描述&lt;code&gt; 定义计算机代码。&lt;code&gt;元素不保留多余的空格和折行。如需保留则用&lt;pre&gt;包围代码。&lt;kbd&gt; 定义键盘码。&lt;samp&gt; 定义计算机代码样本。&lt;tt&gt; 定义打字机代码。&lt;var&gt; 定义变量。&lt;pre&gt; 定义预格式文本。&lt;listing&gt; 不赞成使用。使用 &lt;pre&gt; 代替。&lt;plaintext&gt; 不赞成使用。使用 &lt;pre&gt; 代替。&lt;xmp&gt; 不赞成使用。使用 &lt;pre&gt; 代替。 （3）引用、引用和术语定义123456789 标签 描述&lt;abbr&gt; 定义缩写。（鼠标放在指定词上后，显示其他内容，这个内容是用title属性定义在 abbr中）显示为带下划线的字符串。&lt;acronym&gt; 定义首字母缩写。&lt;address&gt; 定义地址。&lt;bdo&gt; 定义文字方向。&lt;blockquote&gt; 定义长的引用。（进行缩进处理）&lt;q&gt; 定义短的引用语。&lt;cite&gt; 定义引用、引证。&lt;dfn&gt; 定义一个定义项目。显示为斜体字，并且可以和abbr形成嵌套结构。 对缩写进行标记能够为浏览器、翻译系统以及搜索引擎提供有用的信息。 八、HTML CSS（1）外部样式表当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。 123&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"&gt;&lt;/head&gt; （2）内部样式表当单个文件需要特别样式时，就可以使用内部样式表。你可以在 head 部分通过 标签定义内部样式表。 1234567&lt;head&gt;&lt;style type=\"text/css\"&gt;body &#123;background-color: red&#125;p &#123;margin-left: 20px&#125;&lt;/style&gt;&lt;/head&gt; （3）内联样式当特殊的样式需要应用到个别元素时，就可以使用内联样式。 使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距。 123&lt;p style=\"color: red; margin-left: 20px\"&gt;This is a paragraph&lt;/p&gt; 12345标签 描述&lt;style&gt; 定义样式定义。&lt;link&gt; 定义资源引用。&lt;div&gt; 定义文档中的节或区域（块级）。&lt;span&gt; 定义文档中的行内的小块或区域。 九、HTML 链接有两种使用 &lt;a&gt; 标签的方式： 通过使用 href 属性 - 创建指向另一个文档的链接（hrfe是Hypertext Reference的缩写） 通过使用 name 属性 - 创建文档内的书签 “链接文本” 不必一定是文本。图片或其他 HTML 元素都可以成为链接。 使用 Target 属性，你可以定义被链接的文档在何处显示。 下面的这行会在新窗口打开文档： 1&lt;a href=\"http://www.w3school.com.cn/\" target=\"_blank\"&gt;Visit W3School!&lt;/a&gt; 可以使用 name 属性创建 HTML 页面中的书签。书签不会以任何特殊方式显示，它对读者是不可见的。当使用命名锚（named anchors）时，我们可以创建直接跳至该命名锚（比如页面中某个小节）的链接，跳转还是使用 &lt;a&gt; 标签的 href 属性，在锚名称之前加#即可。eg： 12&lt;a name=\"tips\"&gt;基本的注意事项 - 有用的提示&lt;/a&gt;&lt;a href=\"#tips\"&gt;有用的提示&lt;/a&gt; 有用的提示就会跳转到name对应位置。 假如浏览器找不到已定义的命名锚，那么就会定位到文档的顶端。不会有错误发生。 请始终将正斜杠添加到子文件夹。假如这样书写链接：href=”http://www.w3school.com.cn/html&quot;，就会向服务器产生两次 HTTP 请求。这是因为服务器会添加正斜杠到这个地址，然后创建一个新的请求，就像这样：href=”http://www.w3school.com.cn/html/&quot;。为了效率考虑。 创建邮件链接或者其他需要中间加空格的地方，应该使用 %20 来替换单词之间的空格，这样浏览器就可以正确地显示文本了。 十、HTML 图像&lt;img&gt; 标签是空标签，它只包含属性，并且没有闭合标签。用源属性src来显示图像： 1&lt;img src=\"url\" /&gt; 使用alt属性可以进行文本替换（当浏览器不能载入图片，那么就会使用这段替换文本） &lt;area&gt; 这个标签可以说很有意思，可以实现点击图片完成一定的交互，内容比较多，但是这个标签感觉可以展开很多，并且能够完成很多有趣的事情。 area 标签 123456789101112131415&lt;html&gt;&lt;body&gt; &lt;img src=\"https://upload-images.jianshu.io/upload_images/5547112-914acbfbc1ddbb76.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/896/format/webp\" alt=\"supergitman\" usemap=\"#supergitman\" width=200 height=200&gt; &lt;map name=\"supergitman\" id=\"supergitman\"&gt; &lt;area shape=\"circle\" coords=\"100,100,30\" href=\"https://www.codebiluo.cn\" target =\"_blank\" alt=\"homeSite\"&gt; &lt;/map&gt;&lt;/body&gt;&lt;/html&gt; &lt;area&gt; 标签定义图像映射中的区域（注：图像映射指得是带有可点击区域的图像）。**area 元素总是嵌套在 &lt;map&gt; 标签之中。 可选的属性： 属性 值 描述 coords 坐标值 定义可点击区域（对鼠标敏感的区域）的坐标。 href URL 定义此区域的目标 URL。 nohref nohref 从图像映射排除某个区域。 shape default、rect、circ、poly 定义区域的形状。 target _blank _parent _self _top 规定在何处打开 href 属性指定的目标 URL。 shape属性与coords属性： 值 描述 x1,y1,x2,y2 如果 shape 属性设置为 “rect”，则该值规定矩形左上角和右下角的坐标。 x,y,radius 如果 shape 属性设置为 “circ”，则该值规定圆心的坐标和半径。 x1,y1,x2,y2,..,xn,yn 如果 shape 属性设置为 “poly”，则该值规定多边形各边的坐标。如果第一个坐标和最后一个坐标不一致，那么为了关闭多边形，浏览器必须添加最后一对坐标。 注意： 1、如果某个 &lt;area&gt; 标签中的坐标和其他区域发生了重叠，会优先采用最先出现的 area 标签。浏览器会忽略超过图像边界范围之外的坐标。 2、在 HTML 中，&lt;area&gt; 没有结束标签。在 XHTML 中，&lt;area&gt; 必须正确地关闭。 3、&lt;img&gt; 中的 usemap 属性可引用 &lt;map&gt; 中的 id 或 name 属性（由浏览器决定），所以我们需要同时向 &lt;map&gt; 添加 id 和 name 两个属性。 十一、HTML表格 表格由 &lt;table&gt; 标签来定义。每个表格均有若干行（由 &lt;tr&gt; 标签定义），每行被分割为若干单元格（由 &lt;td&gt; 标签定义）。 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。 表格的表头使用 &lt;th&gt; 标签进行定义。 一个格子里没有内容，如果直接不加东西或者填几个空格，那么这个格子的边框也不会显示。这时可以使用空格占位符&amp;nbsp（后面再加个;）。 在html代码中&amp;nbsp和空格的区别： 在html代码中每输入一个转义字符&amp;nbsp就表示一个空格，输入十个&amp;nbsp，页面中就显示10个空格位置。 而在html代码中输入空格，不管输入多少个空格，最终在页面中显示的空格位置只有一个。 例如：hmtl代码中，在两个字之间输入十个空格与输入十个转义字符&amp;nbsp的效果对比。 是Non-Breaking Space的缩写 1234567891011表格 描述&lt;table&gt; 定义表格&lt;caption&gt; 定义表格标题。caption 标签必须紧随 table 标签之后。您只能对每个表格定义一个标题。通常这个 标题会被居中于表格之上。&lt;th&gt; 定义表格的表头。&lt;tr&gt; 定义表格的行。&lt;td&gt; 定义表格单元。&lt;thead&gt; 定义表格的页眉。&lt;tbody&gt; 定义表格的主体。&lt;tfoot&gt; 定义表格的页脚。&lt;col&gt; 定义用于表格列的属性。&lt;colgroup&gt; 定义表格列的组。 十二、HTML 列表（1） 无序列表无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。 无序列表始于 &lt;ul&gt; 标签。每个列表项始于 &lt;li&gt;。 （2）有序列表同样，有序列表也是一列项目，列表项目使用数字进行标记。 有序列表始于 &lt;ol&gt; 标签。每个列表项始于 &lt;li&gt; 标签。 ul是unordered lists的缩写，ol是ordered lists的缩写，li是list item的缩写。 ul中可以用type属性来指定列表开头样式 十三、HTML 块大多数 HTML 元素被定义为块级元素或内联元素。 “块级元素”译为 block level element，“内联元素”译为 inline element。 块级元素在浏览器显示时，通常会以新行来开始（和结束）。内联元素在显示时通常不会以新行开始。 （1）&lt;div&gt; 元素HTML &lt;div&gt; 元素是块级元素，它是可用于组合其他 HTML 元素的容器。 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。 如果与 CSS 一同使用，div 元素可用于对大的内容块设置样式属性。 &lt;div&gt; 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 table 元素进行文档布局不是表格的正确用法。table 元素的作用是显示表格化的数据。 如果用 id 或 class 来标记 ，那么该标签的作用会变得更加有效。 （2）&lt;span&gt; 元素HTML &lt;span&gt; 元素是内联元素，可用作文本的容器。 &lt;span&gt; 元素也没有特定的含义。 当与 CSS 一同使用时，&lt;span&gt; 元素可用于为部分文本设置样式属性。 可以对同一个 &lt;span&gt; 元素应用 class 或 id 属性，但是更常见的情况是只应用其中一种。这两者的主要差异是，class 用于元素组（类似的元素，或者可以理解为某一类元素），而 id 用于标识单独的唯一的元素。 这两个标签与 CSS 一起一起使用总是会见到。","categories":[{"name":"前端","slug":"前端","permalink":"http://codebiluo.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"http://codebiluo.cn/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://codebiluo.cn/tags/basic/"}]},{"title":"Auto Minesweeper","slug":"minesweeper","date":"2020-02-28T03:56:25.000Z","updated":"2020-03-10T11:23:27.740Z","comments":true,"path":"2020/02/28/minesweeper/","link":"","permalink":"http://codebiluo.cn/2020/02/28/minesweeper/","excerpt":"","text":"数据结构课设要求完成扫雷游戏的自动扫雷功能。问题是从游戏中来，使用的方法自然也就是我在玩游戏时的思路。思路其实很简单，阅读下文中的引用就能理解。如果是想体验一下整个思考的过程，阅读下文中加粗斜体部分或许能给你一些启发。 一、心路历程首先给出我在思考这个问题后列出的大概提纲，也就是代码中需要做什么事情（只是大纲，所以写的有些不通顺，但是如果get到这个点，就没必要看下面的具体思路了😂） 首先找可以确定的地雷的位置，生成一个数组然后找周围地雷数等于这个节点值的位置，将它周围没有点的位置加入到一个数组中，这个数组中的点就是一定可以点的位置 是的，非常简短的思路，有了这个大致思路，问题也就很明了。 上面的是最开始的心路历程，两周过去，发生了很多事情。现在对这道题又有了更深入的认识： 上面的方法，是从那个方块一定有地雷的角度去思考，正常人解决扫雷问题也是以这个方法来进行，最终可以在2020，50个地雷的棋盘中，达到50%左右的胜率。但是还是有可能出现*没有可确定的地雷、没有可以得到的可选点**。遇到这两种情况直接随机即可，但是实际上还是有一些决策的余地的。先给出决策的提纲，具体为什么做在之后的后期优化讲解： ① 没有可以确定的地雷时，优先选择四个角，四条边上的未点方块； ② 没有可选点时，比较每个未点方块爆雷的概率， 二、具体思路（一）确定地雷位置首先明确我们现在有什么，根据最后封装的函数： void machine(int GamePanel[30][30], int n, int m, int &amp;x, int &amp;y); 我们现在有的是一个棋盘GamePanel，知道已经点开的方块，以及该店周围的地雷数量；以及未点开的方块，用-1来表示。 地雷的位置是根据已经点开的点所确定。在这里可以先不看下面的内容，根据这个提示想想如何确定地雷位置。 遍历棋盘中已经点开的方块p，统计方块p周围没有点开的方块的数量，如果为点开的方块数量等于方块p周围的地雷数量k，那么就说明这些未点开的方块都是地雷。 这时所得到的地雷都是显式的，我们在游戏中就能够一眼看出来的地雷，这时无法确定的地雷，之后有可能根据之后点出的点然后找出来，但也有可能根本无法确定，对于无法寻找地雷的探讨放在最后的结果分析。 （二）确定可选点位置现在知道了一些地雷的位置，接下来就是根据这些地雷，找出那些点是下一个可选点。 思路和确定地雷位置相同，根据已知地雷位置来去确定可选点位置。还是根据提示想想如何实现。 遍历棋盘中已经点开的方块P，统计方块P周围没有点开的方块数x，以及方块p周围确定的地雷数y。如果未点开的方块数x大于方块P周围已经确定的地雷数y，那么就说明方块P周围得方块，除去周围的地雷，剩下的都是可选点。 这时确定的可选点不止一个，之后需要选择其中的一个点作为返回值。个人认为在选择可选点的时候，除了直接随机一个可选点之外，可以思考一种选择的策略，这个可能是后期优化的一个点吧。 （三）后期优化这里大致给出几个我认为可能会对胜率以及步数有提升的点： 1、上文中提到的选择可选点时的优化，除了直接随机一个可选点之外，可以思考一种选择的策略，现在已经已经有策略咯！！！！！； 2、后文胜率分析中会有对于扫雷失败的分析，通过分析我们可以看到，最终剩下的未点方块和地雷数都是很少的，瀚汶带佬提出的分析特定的方块组合范式（相邻几个方块以一种规律排列，比如比如 1 2 1 、3 3 3 、4 3），根据分析可以得到地雷的位置。但是，这种分析并不是万能的，有些范式会对应多解，具体内容下文讨论。 3、没有确定地雷，或者是没有可选点怎么办。最开始的时候，我是直接选择了最左上角的方块，此时我统计出的步数平均值稳定在92步左右，后来将他改成从未选点中随机一个方块，这时步数平均值稳定在89步左右（提升或许有些小） ……（希望有缘人还能找到更多优化的方法） 三、结果分析测试使用的是要求的20*20棋盘，50颗地雷。 首先给出进行10000次自动扫雷的统计结果： 从数据中可以看到，第一步就爆雷的比例非常大（按匿名同学所说，就是50/400=12.5%左右），这是因为第一步你没有任何点开的方块，算法的决策没有依据，只能随机一个可选点。这个随机出的点完全取决于个人的脸黑程度，与算法的效率无关，故我在统计胜率时将这部分失败的样本舍去。 首先分析为什么会输。在得出大概思路的时候，我认为优化的方向应该只是如何让赢的步数降低，但是没想到，每一次测试，会有那么多扫雷失败的情况。这时我就想到了自己在游戏时找不到地雷只能蒙的场景：或许这个就是为什么胜率如此低的原因。给出一个例子勾起大家的回忆（例子仍从匿名群友处获得）： 此时还有三部分没有解决，右下角根据交涉某个位置有地雷来分析出地雷的位置如下： 左边和右上角的部分是死局，无法解决，我们来分析这两个部分是如何导致死局的。这两部分都是由左右两个方块组成的，同时看到，当前还有6个雷没有找出，问题就出在左右两个方块无论假设哪一个是地雷都能使局面成立。这就是不唯一解的由来。 接下来分析胜局的步数情况。统计步数后，转换为统计图： 横坐标为胜局步数，纵坐标为此步数胜局数。非常明显，这是一个高斯分布，最终进行测试的时候，大家的统计情况也就是这样，所以最终成绩的分布自然也是符合高斯分布。 这个问题也就解决了，之后如还有优化还会继续添加，如果有还得优化方案也欢迎大家联系我！ 四、后期优化完成machine函数之后，为了模拟老师最终测试的形式，编写了一份模拟1000次老师测试（每一次随机十个棋盘进行自动游戏），最后，满分的比例稳定在71%。作为最后的结果，明显是不够好的。之后的几天总会思考优化的问题，就如我之前所说的优化方法，我尝试从这些方向找到可行的办法，其中1和3是针对于步数的优化， 2是针对于胜率的优化，并且3已经实现。所以最后剩下对步数的优化只有方法1，并且我得到了一种确实可行的优化方法：原本程序中确定可选点，是从可选点数组中随机挑选一个。但是在实际的游戏中，在选取可选点的时候，我们总会趋向于选择周围有更多未点开的方块的可选点，因为如果点下这样的方块很有可能会扩展出很多的方块，也就是有可能增加了更多的点开方块。相比于将边界方块（周围地雷数大于0的方块）一个一个点开，点开一个内部周围地雷数为0的方块，总会是更优的选择。这也就是我们新的可选点决策方案。 具体的实施方案是，判断每个可选点周围未点开的方块个数，将未点开方块个数最多的可选点作为最终的决策方块。 这样一来，平均步数稳定在83步，测试得到满分的比例稳定在86%，提升了15%，可以说是很大的提升了！ 老师用了新的测评方法，根据最终的测评方案给出优化方案。 新的测评方案很公平，随机测试1000局游戏，计算平均成绩和胜率。使用原本的暴力算法，最终平均分为55分，胜率为51%。可以说是很不好，现在回头看，也觉得自己之后不好好优化滑水是真的🐕。 使用各种优化方法之后，最终平均分（原始平均分）达到63分，胜率为71%。下面分条叙述优化的方法： ①、挑选最终返回的可选点。原本程序中确定可选点，是从可选点数组中随机挑选一个。但是在实际的游戏中，在选取可选点的时候，我们总会趋向于选择周围有更多未点开的方块的可选点，因为如果点下这样的方块很有可能会扩展出很多的方块，也就是有可能增加了更多的点开方块。相比于将边界方块（周围地雷数大于0的方块）一个一个点开，点开一个内部周围地雷数为0的方块，总会是更优的选择。 ②、没有确定的地雷时直接四个角与四周的地雷优先。开局的时候，已点方块是很稀疏的，无法找到确定的地雷。棋盘中每个方块爆雷的概率都是相同的的，所以这时要考虑点开某个方块对之后的棋局的有利程度。四个角上的方块，周围地雷数有1，2，3三种可能，只有1/3的可能，方块周围地雷数为3时，下一次才一定会找到确定地雷。而棋盘中的大部分方块，周围地雷数有8种可能，只有1/8的下一次才一定会找到确定地雷。选择四周的方块也可以根据这个方法思考其对之后有利程度进行选择。 ③、没有可选点时，计算每个方块爆雷的概率，选择爆雷概率最小的方块。将没有点的方块分为两类，一类是周围没有已点方块，一类是周围有已点方块。前者爆雷的概率是没有找到的地雷数除以没有点开的方块数。后者爆雷的概率是通过，遍历周围所有的已点方块，其周围没有找出的地雷数除以周围总的未点开方块数作为爆雷概率，遍历过程中，每个未点开方块的爆雷概率的最大值作为其爆雷概率。 五、具体代码……之后会有代码查重，避嫌我就暂时不添加进来，提交之后有兴趣的同学可以回来康康具体代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278////////////////////////////////////bool isLegalPlace(int n , int m , int x, int y)&#123; if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) return false; return true;&#125;int surroundMineNum(int GamePanel[30][30], int n, int m , int x, int y) // 用于初步探测&#123; int surround[8][2] = &#123; &#123;0,1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;1,1&#125;,&#123;-1,-1&#125; , &#123;1,-1&#125; ,&#123;-1,1&#125; &#125;; // 表示周围八个位置与中间位置的坐标差 int mineNum = 0; for (int i = 0; i &lt; 8; ++i) if (isLegalPlace(n, m, x + surround[i][0], y + surround[i][1]) &amp;&amp; GamePanel[x + surround[i][0]][y + surround[i][1]] == -1) mineNum++; return mineNum;&#125;int surroundMineNum_toFindPath(int mineFlags[30][30], int n, int m, int x, int y) // 用于找下一个可点位置&#123; int surround[8][2] = &#123; &#123;0,1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;1,1&#125;,&#123;-1,-1&#125; , &#123;1,-1&#125; ,&#123;-1,1&#125; &#125;; // 表示周围八个位置与中间位置的坐标差 int mineNum = 0; for (int i = 0; i &lt; 8; ++i) if (isLegalPlace(n, m, x + surround[i][0], y + surround[i][1]) &amp;&amp; mineFlags[x + surround[i][0]][y + surround[i][1]] == 1) mineNum++; return mineNum;&#125;int surroundNotPointed(int GamePanel[30][30], int mineFlags[30][30], int n, int m, int x, int y) // 确定(x,y)周围没有点的方块个数&#123; int surround[8][2] = &#123; &#123;0,1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;1,1&#125;,&#123;-1,-1&#125; , &#123;1,-1&#125; ,&#123;-1,1&#125; &#125;; // 表示周围八个位置与中间位置的坐标差 int cnt = 0; for (int i = 0; i &lt; 8; ++i) &#123; int newX = x + surround[i][0]; int newY = y + surround[i][1]; if (isLegalPlace(n , m , newX , newY) &amp;&amp; GamePanel[newX][newY] == -1 &amp;&amp; mineFlags[newX][newY] == 0) cnt++; &#125; return cnt;&#125;int surroundSureMine(int mineFlags[30][30], int n, int m, int x, int y) // 确定(x,y)周围确定的地雷个数&#123; int surround[8][2] = &#123; &#123;0,1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;1,1&#125;,&#123;-1,-1&#125; , &#123;1,-1&#125; ,&#123;-1,1&#125; &#125;; // 表示周围八个位置与中间位置的坐标差 int cnt = 0; for (int i = 0; i &lt; 8; ++i) &#123; int newX = x + surround[i][0]; int newY = y + surround[i][1]; if (isLegalPlace(n , m , newX , newY) &amp;&amp; mineFlags[newX][newY] == 1) cnt++; &#125; return cnt;&#125; bool noPointed(int GamePanel[30][30], int n, int m)&#123; for (int i = 0 ; i &lt; n ; ++i) for (int j = 0 ; j &lt; m ; ++j) if (GamePanel[i][j] != -1) return false; return true;&#125;bool surroundByPointed(int GamePanel[30][30] , int x , int y)&#123; int surround[8][2] = &#123; &#123;0,1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;1,1&#125;,&#123;-1,-1&#125; , &#123;1,-1&#125; ,&#123;-1,1&#125; &#125;; // 表示周围八个位置与中间位置的坐标差 for (int i = 0 ; i &lt; 8 ; ++i) if (GamePanel[x+surround[i][0]][y+surround[i][1]] != -1) return true; return false;&#125;double randPoint(int GamePanel[30][30] , int mineFlags[30][30] , int n , int m) // 随机点未开方块爆炸的概率 &#123; int mineNotFindNum = 0; int notPointedNum = 0; for (int i = 0 ; i &lt; n ; ++i) for (int j = 0 ; j &lt; m ; ++j) &#123; if (mineFlags[i][j] == 0 &amp;&amp; GamePanel[i][j] == -1) mineNotFindNum++; if (GamePanel[i][j] == -1) notPointedNum++; &#125; return 1.0*mineNotFindNum/notPointedNum;&#125;void machine(int GamePanel[30][30], int n, int m, int &amp;x, int &amp;y)&#123;// if (noPointed(GamePanel,n,m) == true)// &#123;// x = 0;// y = 0;// return;// &#125; int surround[8][2] = &#123; &#123;0,1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;1,1&#125;,&#123;-1,-1&#125; , &#123;1,-1&#125; ,&#123;-1,1&#125; &#125;; // 表示周围八个位置与中间位置的坐标差 int mineNum = 0; // 可确定炸弹数量 int mineFlags[30][30]; // 用于地雷去重 for (int i = 0 ; i &lt; 30 ; ++i)// 0表示这里不是炸弹，1表示这里是炸弹 for (int j = 0 ; j &lt; 30 ; ++j) mineFlags[i][j] = 0; int pathX[400], pathY[400]; int pathNum = 0; for (int i = 0; i &lt; n; ++i) // 寻找可以确定的地雷位置 &#123; for (int j = 0; j &lt; m; ++j) &#123; if (GamePanel[i][j] &lt;= 0) continue; if (surroundMineNum(GamePanel, n, m, i, j) == GamePanel[i][j]) &#123; for (int k = 0; k &lt; 8; ++k) &#123; if (isLegalPlace(n, m, i + surround[k][0], j + surround[k][1]) &amp;&amp; GamePanel[i + surround[k][0]][j + surround[k][1]] == -1 &amp;&amp; mineFlags[i + surround[k][0]][j + surround[k][1]] == 0) &#123; mineFlags[i + surround[k][0]][j + surround[k][1]] = 1; mineNum++; &#125; &#125; &#125; &#125; &#125; if (mineNum == 0) // 当前没有可以确定的地雷 &#123; // 点四周的方块对之后更有利 if (GamePanel[0][0] == -1) &#123; x = y = 0; return; &#125; if (GamePanel[0][m-1] == -1) &#123; x = 0; y = m-1; return; &#125; if (GamePanel[n-1][0] == -1) &#123; x = n-1; y = 0; return; &#125; if (GamePanel[n-1][m-1] == -1) &#123; x = n-1; y = m-1; return; &#125; for (int i = 0 ; i &lt; m ; ++i) if (GamePanel[0][y] == -1) &#123; x = 0; y = rand()%m; return; &#125; for (int i = 0 ; i &lt; m ; ++i) if (GamePanel[n-1][y] == -1) &#123; x = n-1; y = rand()%m; return; &#125; for (int i = 0 ; i &lt; n ; ++i) if (GamePanel[x][0]== -1) &#123; x = rand()%n; y = 0; return; &#125; for (int i = 0 ; i &lt; n ; ++i) if (GamePanel[x][m-1] == -1) &#123; x = rand()%n; y = m-1; return; &#125; x = rand() % n; y = rand() % m; while (GamePanel[x][y] != -1) &#123; x = rand() % n; y = rand() % m; &#125; &#125; else &#123; for (int i = 0; i &lt; n; ++i) // 找下一个落脚点 &#123; for (int j = 0; j &lt; m; ++j) &#123; if (GamePanel[i][j] &lt;= 0) continue; int tem; if ((tem = surroundMineNum_toFindPath(mineFlags, n, m, i, j)) == GamePanel[i][j]) // 逻辑是遍历所有点，如果这个点周围的炸弹树等于这个点的标记数， // 则他周围所有没有被标记为炸弹的点是可选点 &#123; //cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; \" \" &lt;&lt; tem &lt;&lt; endl; for (int k = 0; k &lt; 8; ++k) &#123; if (isLegalPlace(n, m, i + surround[k][0], j + surround[k][1]) &amp;&amp; GamePanel[i + surround[k][0]][j + surround[k][1]] == -1 &amp;&amp; mineFlags[i + surround[k][0]][j + surround[k][1]] == 0) &#123; pathX[pathNum] = i + surround[k][0]; pathY[pathNum] = j + surround[k][1]; pathNum++; &#125; &#125; &#125; &#125; &#125; // 这里暂时将path中的第一个位置作为返回位置，我觉得在这里还能有所思考 if (pathNum) &#123; // 选择周围未点开方块最多的 int tem = 0; for (int i = 0; i &lt; pathNum; ++i) &#123; if (surroundNotPointed(GamePanel, mineFlags, n, m, pathX[tem], pathY[tem]) &lt; surroundNotPointed(GamePanel, mineFlags, n, m, pathX[i], pathY[i])) tem = i; &#125; x = pathX[tem]; y = pathY[tem]; &#125; else // 没有可选点 &#123; // 分析随机点还是按概率点 double prob[30][30]; //double randProb = randPoint; for (int i = 0 ; i &lt; n ; ++i) for (int j = 0 ; j &lt; m ; ++j) &#123; if (GamePanel[i][j] != -1 || mineFlags[i][j]) // 当这个点已经点开，或者已经确定是炸弹，那么可以说他是炸弹的概率为1 prob[i][j] = 1; else // 如果随机点每个方块爆炸的概率 prob[i][j] = 0; &#125; for (int i = 0 ; i &lt; n ; ++i) for (int j = 0 ; j &lt; m ; ++j) &#123; int surroundMineNum = surroundSureMine(mineFlags , n , m , i , j); int surroundnotPointedNum = surroundNotPointed(GamePanel , mineFlags , n , m , i , j); double probOfRandijSurround = 1.0*(GamePanel[i][j]-surroundMineNum)/surroundnotPointedNum; // 随机点(i,j)周围的点爆雷的概率 for (int k = 0 ; k &lt; 8 ; ++k) &#123; int newX = i+surround[k][0]; int newY = j+surround[k][1]; if (isLegalPlace(n , m , newX , newY)) prob[newX][newY] = probOfRandijSurround&gt;prob[newX][newY]?probOfRandijSurround:prob[newX][newY]; &#125; &#125; double minProb = 1; for (int i = 0 ; i &lt; n ; ++i) // 寻找此时爆炸概率最低的方块 for (int j = 0 ; j &lt; m ; ++j) if (minProb &gt; prob[i][j]) &#123; x = i; y = j; minProb = prob[i][j]; &#125; &#125; &#125;&#125;//////////////////////////////// 时间复杂度：O(n) 空间复杂度：O(n)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://codebiluo.cn/categories/Algorithm/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://codebiluo.cn/tags/basic/"}]},{"title":"Django2与Django3之间的不同","slug":"Django-error-2-3","date":"2020-02-15T07:19:13.000Z","updated":"2020-02-16T09:54:21.448Z","comments":true,"path":"2020/02/15/Django-error-2-3/","link":"","permalink":"http://codebiluo.cn/2020/02/15/Django-error-2-3/","excerpt":"","text":"最近在复现别人django的一个电商系统项目，他用的是django2，而我使用的是django3。在调试的过程中，由于这两个版本之间某些语法或者是要求的不同，出现了很多bug。 从现在开始，这篇博文会写一些我在探索过程中对django2和django3不同点的总结。 一、url()与path()url()和path()都是用于实例化urlpatterns的函数。url()是在django1、django2中使用，并且在API文档中明确指出，在将来的版本中可能不推荐使用，他还有一个别名为re_path()。path()是django3中使用的函数，是url()的替代品。 首先需要知道几个问题： 1、urlpatterns是url配置URLconf中的一个列表，网站生成的请求会遍历urlpartterns寻找匹配的链接，遇到第一个会停下来。然后调用对应的view函数，返回对应的页面。 2、URLconf指的是默认生成的urls.py文件，在项目初始化（startproject）和应用初始化（startapp）时分别生成。 *path(route , view , kwargs = None , name = None)* path()函数返回要包含在urlpatterns中的元素。 route参数应该是一个字符串，包含了一个URL模式。该字符串可能包含尖括号（eg：&lt; username &gt;），以捕获URL的一部分并将其作为关键字参数发送到view。尖括号可包含转换器规范（eg：&lt; int:year &gt;），该规范限制了匹配的字符，还可以更改传递给视图的变量的类型。例如，&lt; int : year&gt;匹配一串十进制数字并将该值转换为int。 view参数是一个视图函数或是结果为基于类的视图的as_view()。它也可以是一个django.urls.include()。 include()函数是在调用项目中应用的URLconf（也就是对应应用下的urls.py文件）。 kwargs参数可以将其他参数以字典的形式传递给视图函数。route参数中匹配的关键字、转换器规范转换的匹配字符都是通过kwargs参数来传递。这个参数不是关键参数，可以忽略。 name参数可以给这个url取一个合适的名字。通过给url取名字，以后在view或者模板中使用这个url，就只需要通过这个名字就可以了。这样做的原因是防止url更改，会导致其他用了这个url的地方都需要更改，但是如果取名字了，就不要做任何改动了。这个参数不是关键参数，可以忽略。 附：在python编码中，使用 url = reverse(name) 进行查找 name 对应的url，然后可以用 redirect(url) 进行重定向。 re_path(route, view, kwargs=None, name=None) / url(route, view, kwargs=None, name=None) url()函数也是返回要包含在urlpatterns中的元素。 其中view、kwargs、name参数与path的用法相同，不同点在于route参数的使用。 route参数是一个字符串参数，包含与Python的兼容的正则表达式 re 模块。字符串通常使用原始字符串语法（r&#39;&#39;），以便它们可以包含类似\\d的序列，而无需用另一个反斜杠转义反斜杠。进行匹配时，将从正则表达式中捕获的组传递给视图-如果组已命名，则作为命名参数，否则传递为位置参数。这些值将作为字符串传递，而不进行任何类型转换。这样就导致需要掌握正则表达式这个前导知识。 二、两个html语句12&#123;% load staticfiles %&#125;&#123;% load static %&#125; 这两个都是在html文件中的语句，具体的语法我不了解，但我认为应该是加载静态文件目录的语句。当我的html文件中有前一个语句的时候，网页会出现错误： 百度后得知，这是由于load staticfiles在django2.1就已经被弃用（不建议使用），并且在django3中直接移除，所以才会出现这样的错误。只需要将它改成load static就可以。 同样的， 123&#123;% load staticfiles %&#125;&#123;% load static from staticfiles %&#125;&#123;% load admin_static %&#125; 也是相同的情况，不能在django3中使用，都需要将他们的内容替换成load static。","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"},{"name":"advanced","slug":"advanced","permalink":"http://codebiluo.cn/tags/advanced/"}]},{"title":"百题总结-1","slug":"百题总结-1","date":"2020-02-11T03:37:40.000Z","updated":"2020-02-11T04:18:22.081Z","comments":true,"path":"2020/02/11/百题总结-1/","link":"","permalink":"http://codebiluo.cn/2020/02/11/%E7%99%BE%E9%A2%98%E6%80%BB%E7%BB%93-1/","excerpt":"","text":"一学期的努力，于2月5日完成了自己的第一百道题（虽然这一天为了实现一百道疯狂滑水8道简单😂）。这么长时间的刷题可以说是收获颇丰，我从以下几个角度谈一谈刷LeetCode的这个问题。 1、代码水平提高。这个方面是最重要，也是变化最大的一点，从一开始被各种问题打击，到现在对自己代码的自信；从刚开始提交无数次仍然报错，到现在很多题可以一遍过（提交无数次报错还是和题目有关系，有的题就是各种各样你想不到的情况，这些问题真的是要自己去尝试，很多问题当时就是想不到）；这些都是刷题的成长。 2、考虑问题更加全面。编写代码时难免会对问题考虑不全面，有时是问题理解错误，有时是由于代码细节的问题（比如说编写BFS，如果直接将根节点压入队列，而在BFS函数中，仅在节点压队时判断NULL的情况，那么如果根节点为空，那么访问它的子节点时就会报错）。刷题可以很好地解决这个问题，错多了再遇到自然也就有“肌肉记忆”了 3、督促自己。片段的时间可以做一道简单题，或者看看别人的题解（这一点极为关键）；中等题难度不一，都是和具体题目有关；大多数困难题都需要大块的时间来做，看题解、再写一遍，后面两步对我的提升非常大。刷LeetCode已经成了我闲下来的必备事情，有时闲着也是闲着，不如刷一刷LeetCode，AC带来的快乐又对刷题有能动的反作用。 4、锻炼手速（手动狗头）。打字速度飞速提升！ 希望不久之后就能有第二百道的总结！","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-over","slug":"LeetCode-over","date":"2020-02-10T16:50:37.000Z","updated":"2020-02-13T06:55:02.764Z","comments":true,"path":"2020/02/11/LeetCode-over/","link":"","permalink":"http://codebiluo.cn/2020/02/11/LeetCode-over/","excerpt":"","text":"这是关于LeetCode在本博客的最后一篇文章，让我们悼念那些让我的博客显得臃肿无比的题解们。但是令人开心的是：他们在新的地方获得新生，那就是使用GitBook做出的一个电子书（官方是这么形容的）。之后刷LeetCode的题解都会发布在这里，我也会将它做成一个专栏，也希望大家能从中有所收获！最后附上链接： http://codebiluo.cn/myLeetCode/ （初始加载会比较慢，请见谅）","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"Unity+ARFoundation","slug":"Unity-ARFoundation","date":"2020-02-04T04:46:26.000Z","updated":"2020-02-05T11:21:21.924Z","comments":true,"path":"2020/02/04/Unity-ARFoundation/","link":"","permalink":"http://codebiluo.cn/2020/02/04/Unity-ARFoundation/","excerpt":"","text":"前两天想要上手Unity来AR方面的项目软件 ，探索过程中出现了各种各样的问题，现在将这个过程中遇到的各种各样问题梳理一下，希望后来者能开开心心上手Unity+AR。注意：这是一篇踩坑博客，具体搭建还请自行百度。 一、ARFoundation or ARCore or ARKitUnity作为一个平台，不直接提供XR（包括VR、AR和MR）的开发包，这时就需要其他公司提供各种各样的SDK工具包，国外有苹果公司的ARKit、谷歌公司的ARCore、Unity的ARFoundation，还有最近发现的OpenCVForUnity，而国内有EasyAR这些SDK工具包。ARKit是针对于IOS开发，ARCore是针对于Android开发，而我使用的是ARFoundation，这是Unity将ARKit和ARCore进一步整合的工作平台。（这里就要说到一个应该知道的问题，IOS开发一定需要Mac，或者是电脑装双系统，据望网友可靠信息，如果使用虚拟机，龟速运行不说， 还会有很多Bug。） 二、Android JDK &amp; NDK1、解决方法这是搭建环境过程遇到的最让我头疼的问题，直接原因就是我对进度条的不信任。当你进行Android开发时，需要将项目打包成apk，这时就需要Android JDK &amp; NDK工具包，这时你有两种选择①、自行下载SDK manager和NDK；（这条路让我感受到世界的恶意）②、使用Unity Hub直接下载Unity 2019.3.0f6 (64-bit)，这样可以直接添加各种模块； 2、方法①（想要较好解决方法的同学可以直接看方法②）SDK和NDK下载可以直接从官网下载，建议使用Goole浏览器的迅雷插件，这样可以快一点。SDK：https://www.androiddevtools.cn/NDK：https://developer.android.google.cn/ndk/downloads/下载SDK Tools后打开SDK manager再下载需要的对应工具，尽量下载最新版本。下载NDK之后，就会遇到一个第一个问题：NDK版本不正确令人震惊的是，Unity要求的NDK版本的小版本号怎么这么长！（黑人问号脸）还能把所有小版本都发布吗！这就导致我花费了大量时间在下载NDK，大版本错完小版本错，小版本错完之后还有错。 3、方法②对比之下，方法②就非常好。下载了Unity Hub之后，添加Android Build Support以及其分目录的模块后，直接下载Unity 2019.3.0f6 (64-bit)或者是Unity 2019.2.20f1 (64-bit)。下载的过程比较漫长，需要耐心等待，但是面包总会有的。下载到五分之四的时候，进度条就会卡住，而由于我对进度条的不信任，我就直接取消下载转到方法一。。。所以使用这个方法你只要相信进度条即可。 三、Mininum API Level配置环境的过程，有一个步骤时设置Mininum API Level，而我想的是设置的小一些，一定不会有问题，但事实不是如此。当我将其设置为最小的API Level 19：在编译运行的时候，会出现报错：这时需要将Mininum API Level设置的大一些，比如我设置的是API Level 24，就可以成功编译。 四、Building Gradle Project最终编译的时候，进度条再一次卡住/(ㄒoㄒ)/~~，这时编译进行到Building Gradle Project，Unity会直接卡死。 Gradle是一个基于JVM的构建工具，是一款通用灵活的构建工具，支持maven， Ivy仓库，支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml配置文件，基于Groovy，build脚本使用Groovy编写。——百度百科 而编译卡在这里的原因由于本地并没有Gradle，所以编译时需要下载，而外网资源下载速度我不用再提，据网友信息，他编译数小时后成功了！ 真是很短的时间呢！但我采取了其他的方法：预先下载Gradle。我下载的是gradle-5.4.1，之后在Edit-&gt;Preferences中将下载内容的地址输入到Gradle中。辛苦一整天，遇到诸多艰难，所幸克服，没有放弃，坚持走下去咯！","categories":[{"name":"Unity","slug":"Unity","permalink":"http://codebiluo.cn/categories/Unity/"}],"tags":[{"name":"AR","slug":"AR","permalink":"http://codebiluo.cn/tags/AR/"}]},{"title":"Django-4","slug":"Django-4","date":"2020-01-27T13:50:46.000Z","updated":"2020-02-15T07:40:18.717Z","comments":true,"path":"2020/01/27/Django-4/","link":"","permalink":"http://codebiluo.cn/2020/01/27/Django-4/","excerpt":"","text":"• 编写一个用于问题显示的表单（form）form是HTML的一个元素，修改polls/detail.html 12345678910&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&#123;% if error_message %&#125;&lt;p&gt;&lt;strong&gt;&#123;&#123; error_message &#125;&#125;&lt;/strong&gt;&lt;/p&gt;&#123;% endif %&#125;&lt;form action=\"&#123;% url 'polls:vote' question.id %&#125;\" method=\"post\"&gt;&#123;% csrf_token %&#125;&#123;% for choice in question.choice_set.all %&#125; &lt;input type=\"radio\" name=\"choice\" id=\"choice&#123;&#123; forloop.counter &#125;&#125;\" value=\"&#123;&#123; choice.id &#125;&#125;\"&gt; &lt;label for=\"choice&#123;&#123; forloop.counter &#125;&#125;\"&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/label&gt;&lt;br&gt;&#123;% endfor %&#125;&lt;input type=\"submit\" value=\"Vote\"&gt;&lt;/form&gt; 这部分涉及HTML相关内容，不再赘述 • 添加投票界面的相关内容添加关于polls/views.py的vote()函数的相关实现： 12345678910111213141516171819202122from django.http import HttpResponse, HttpResponseRedirectfrom django.shortcuts import get_object_or_404, renderfrom django.urls import reversefrom .models import Choice, Question# ...def vote(request, question_id): question = get_object_or_404(Question, pk=question_id) try: selected_choice = question.choice_set.get(pk=request.POST['choice']) except (KeyError, Choice.DoesNotExist): # Redisplay the question voting form. return render(request, 'polls/detail.html', &#123; 'question': question, 'error_message': \"You didn't select a choice.\", &#125;) else: selected_choice.votes += 1 selected_choice.save() # Always return an HttpResponseRedirect after successfully dealing # with POST data. This prevents data from being posted twice if a # user hits the Back button. return HttpResponseRedirect(reverse('polls:results', args=(question.id,))) 相关内容说明：1、request.POST是类似于字典的对象，可让您通过键名访问提交的数据。在这种情况下， request.POST[‘choice’]以字符串形式返回所选选项的ID。request.POST值始终是字符串。 请注意，Django还提供request.GET了以相同方式访问GET数据的方法-但我们request.POST在代码中明确使用，以确保仅通过POST调用更改数据。 2、如果没有提供POST数据，那么就会产生KEYERROR异常，重新显示问题表单。 3、在此示例reverse()中，我们在HttpResponseRedirect构造函数中使用该函数 。此功能有助于避免在视图功能中对URL进行硬编码。它提供了我们想要将控制权传递给的视图的名称，以及指向该视图的URL模式的可变部分。在这种情况下，使用我们在教程3中设置的URLconf ，此reverse()调用将返回一个字符串，例如’/polls/3/results/‘，其中3是的值question.id。然后，此重定向的URL将调用‘results’视图以显示最后一页。 • 投票结果页面相关内容进行投票之后，vote()视图将重定向到该问题的结果页面，故编写视图在views.py： 1234from django.shortcuts import get_object_or_404, renderdef results(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/results.html', &#123;'question': question&#125;) 同时创建polls/results.html模板： 1234567&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&lt;ul&gt;&#123;% for choice in question.choice_set.all %&#125; &lt;li&gt;&#123;&#123; choice.choice_text &#125;&#125; -- &#123;&#123; choice.votes &#125;&#125; vote&#123;&#123; choice.votes|pluralize &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt;&lt;a href=\"&#123;% url 'polls:detail' question.id %&#125;\"&gt;Vote again?&lt;/a&gt; 现在可以运行服务器，来看一看问题页面、投票页面和投票结果显示页面， • 使用通用视图来减少代码量在 detail() 和 results() 的视图函数是非常短并且相似，所以重复的代码是冗余的。这些视图代表了基本Web开发的一种常见情况：根据URL中传递的参数从数据库获取数据，加载模板并返回渲染的模板。因为这很常见，所以Django提供了一个捷径，称为“通用视图”系统。为了转换为通用视图系统，需要经过一些步骤： 1. 转换URLconf。 2. 删除一些旧的不需要的视图。 3. 根据Django的通用视图介绍新视图。 修改URL配置首先对polls/urls.py的URLconf进行修改： 123456789from django.urls import pathfrom . import viewsapp_name = 'polls'urlpatterns = [ path('', views.IndexView.as_view(), name='index'), path('&lt;int:pk&gt;/', views.DetailView.as_view(), name='detail'), path('&lt;int:pk&gt;/results/', views.ResultsView.as_view(), name='results'), path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 修改的是将更改为。 修改视图将polls/views.py修改为： 12345678910111213141516171819from django.http import HttpResponseRedirectfrom django.shortcuts import get_object_or_404, renderfrom django.urls import reversefrom django.views import genericfrom .models import Choice, Questionclass IndexView(generic.ListView): template_name = 'polls/index.html' context_object_name = 'latest_question_list'def get_queryset(self): \"\"\"Return the last five published questions.\"\"\" return Question.objects.order_by('-pub_date')[:5]class DetailView(generic.DetailView): model = Question template_name = 'polls/detail.html'class ResultsView(generic.DetailView): model = Question template_name = 'polls/results.html'def vote(request, question_id): ... # same as above, no changes needed. 在这里使用了两个通用视图ListView和DetailView，分别抽象了“显示对象列表”和“显示特定类型的对象的详细信息页面”的概念。","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"},{"name":"basic","slug":"basic","permalink":"http://codebiluo.cn/tags/basic/"}]},{"title":"Django-3","slug":"Django-3","date":"2020-01-22T11:46:05.000Z","updated":"2020-02-15T07:40:17.525Z","comments":true,"path":"2020/01/22/Django-3/","link":"","permalink":"http://codebiluo.cn/2020/01/22/Django-3/","excerpt":"","text":"• 视图视图其实是视图函数的简称，视图是Django应用程序中网页的“类型”，通常具有特定功能并具有特定模板。在Django中，网页和其他内容是通过视图传递的。每个视图均由Python函数（或方法（对于基于类的视图而言））表示。Django将通过检查所请求的URL（准确地说，是域名之后的URL部分）来选择视图。 • URLURL即统一资源定位符，是每一个信息资源都有统一的且在网上唯一的地址。URLconfs即URL模式，是URL的一般形式Django提供了更加优雅的URL模式，例如： 1/newsarchive/&lt;year&gt;/&lt;month&gt;/ • 添加更多的视图更改views.py： 1234567def detail(request, question_id): return HttpResponse(\"You're looking at question %s.\" % question_id)def results(request, question_id): response = \"You're looking at the results of question %s.\" return HttpResponse(response % question_id)def vote(request, question_id): return HttpResponse(\"You're voting on question %s.\" % question_id) 并更改polls.urls.py： 123456789101112from django.urls import pathfrom . import viewsurlpatterns = [ # ex: /polls/ path('', views.index, name='index'), # ex: /polls/5/ path('&lt;int:question_id&gt;/', views.detail, name='detail'), # ex: /polls/5/results/ path('&lt;int:question_id&gt;/results/', views.results, name='results'), # ex: /polls/5/vote/ path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 根据输入的URL地址，通过遍历的方式寻找匹配的URL模式串，并调用相对应的视图函数，相应相对应的网页。比如说，当有人从网站请求页面时，例如“ / polls / 34 /”，Django将加载mysite.urls的Python模块，因为该ROOT_URLCONF设置指向该模块 。它找到名为的变量urlpatterns并按顺序遍历模式。在找到匹配项之后’polls/‘，它将剥离匹配的文本（”polls/“），并将其余文本–发送 “34/“到’polls.urls’URLconf进行进一步处理。在那里匹配’int:question_id/‘，从而导致对detail()视图的调用，如下所示：detail(request=, question_id=34) • 编写更强大的视图每个视图负责执行以下两项操作之一：返回HttpResponse包含所请求页面内容的对象，或者引发诸如之类的异常Http404。HttpResponse需要自己对其进行填充，而HttpRequest是Django自己生成。视图可以从数据库中读取记录，也可以使用Django等模板系统，也可以不使用第三方Python模板系统。它还可以使用所需的任何Python库生成PDF文件，输出XML，或即时创建ZIP文件。在view.py添加代码： 123456from .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] output = ', '.join([q.question_text for q in latest_question_list]) return HttpResponse(output) # Leave the rest of the views (detail, results, vote) unchanged • 将模板与视图创建的硬编码分开首先，在目录templates中创建一个polls目录。Django将在那里寻找模板。您的项目TEMPLATES置描述了Django如何加载和呈现模板。默认设置文件配置一个DjangoTemplates 后端，其APP_DIRS选项设置为 True。按照惯例DjangoTemplates，在每个文件夹中都会寻找一个“模板”子目录INSTALLED_APPS。在polls/templates/polls/添加一个模板： 123456789&#123;% if latest_question_list %&#125; &lt;ul&gt; &#123;% for question in latest_question_list %&#125; &lt;li&gt;&lt;a href=\"/polls/&#123;&#123; question.id &#125;&#125;/\"&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&#123;% else %&#125; &lt;p&gt;No polls are available.&lt;/p&gt;&#123;% endif %&#125; 现在运行服务器之后，可以子项/polls来加载一个“最新消息”列表。 • 快捷方式加载模板，填充上下文并使用渲染后的模板的结果返回对象HttpResponse是一种非常常见的用法。同时，Django提供了一种快捷方式。重写index()： 123456from django.shortcuts import renderfrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] context = &#123;'latest_question_list': latest_question_list&#125; return render(request, 'polls/index.html', context) 该render()函数将请求对象作为其第一个参数，将模板名称作为其第二个参数，并将字典作为其可选的第三个参数。它返回使用HttpResponse 给定上下文呈现的给定模板的对象。 • 404错误在views.py中添加代码： 12345678910from django.http import Http404from django.shortcuts import renderfrom .models import Question# ...def detail(request, question_id): try: question = Question.objects.get(pk=question_id) except Question.DoesNotExist: raise Http404(\"Question does not exist\") return render(request, 'polls/detail.html', &#123;'question': question&#125;) 为了快速使示例正常工作，对应模板polls/templates/polls/detail.html中只添加： 1&#123;&#123; question &#125;&#125; 现在运行服务器，可以看到更完整的polls网页 • 404的快捷方式重写detail()函数： 1234567from django.shortcuts import get_object_or_404, renderfrom .models import Question# ...def detail(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/detail.html', &#123;'question': question&#125;) • 使用模板系统polls/detail.html改写为： 123456&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&lt;ul&gt;&#123;% for choice in question.choice_set.all %&#125; &lt;li&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 模板系统使用点查找语法来访问变量属性。在的示例中，首先Django在对象上进行字典查找。如果失败，它将尝试属性查找-在这种情况下可以工作。如果属性查找失败，它将尝试进行列表索引查找。 • 命名空间URL名称在实际的Django项目中，可能有很多个应用程序，Django如何区分它们之间的URL名称呢？答案是将名称空间添加到URLconf中。在polls/urls.py中添加app_name以设置为应用程序名称空间： 123456789from django.urls import patfrom . import viewsapp_name = 'polls'urlpatterns = [ path('', views.index, name='index'), path('&lt;int:question_id&gt;/', views.detail, name='detail'), path('&lt;int:question_id&gt;/results/', views.results, name='results'), path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 这样可以区分多个应用程序的URL名称。","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"},{"name":"basic","slug":"basic","permalink":"http://codebiluo.cn/tags/basic/"}]},{"title":"Django-2","slug":"Django-2","date":"2020-01-19T12:37:53.000Z","updated":"2020-02-15T07:40:16.076Z","comments":true,"path":"2020/01/19/Django-2/","link":"","permalink":"http://codebiluo.cn/2020/01/19/Django-2/","excerpt":"","text":"• 数据库设置默认使用SQLite，相关的设置都在setting.py文件中进行。 setting,py中还有其他设置：INSTALLED_APPS文件顶部的设置。该名称包含在此Django实例中激活的所有Django应用程序的名称。其中包含一些默认的应用程序。不需要时可以在INSTALLED_APPS中删去。 1python manage.py migrate 该migrate命令将查看该INSTALLED_APPS设置，并根据mysite/settings.py文件中的数据库设置以及应用程序随附的数据库迁移来创建任何必要的数据库表。 • 创建模型模型是相关数据的唯一、确定的事实来源。它包含要存储数据的基本字段和行为。也就是一个包含各种属性（数据）和方法（行为）的类。比如说：在民意调查应用中，我们将创建两个模型：Question和Choice。Question有一个问题和出版日期。Choice有两个字段：选择的文本和投票提示。每个Choice都与关联Question。 在polls/models.py文件中添加代码 12345678from django.db import modelsclass Question(models.Model): question_text &#x3D; models.CharField(max_length&#x3D;200) pub_date &#x3D; models.DateTimeField(&#39;date published&#39;)class Choice(models.Model): question &#x3D; models.ForeignKey(Question, on_delete&#x3D;models.CASCADE) choice_text &#x3D; models.CharField(max_length&#x3D;200) votes &#x3D; models.IntegerField(default&#x3D;0) 在这里，==每个模型都是django.db.models.Model的子类==。每个模型都有许多类变量，每个类变量代表模型中的数据库字段。==每一个字段都是一个Field的实例==，不同的Field代表了不同类型的数据。 • 激活模型为了包含应用，需要将应用的引用添加在设置的INSTALLED_APPS中，也就是将polls.apps.PollsConfig添加到INSTALLED_APPS中 123456789INSTALLED_APPS &#x3D; [ &#39;polls.apps.PollsConfig&#39;, &#39;django.contrib.admin&#39;, &#39;django.contrib.auth&#39;, &#39;django.contrib.contenttypes&#39;, &#39;django.contrib.sessions&#39;, &#39;django.contrib.messages&#39;, &#39;django.contrib.staticfiles&#39;,] 1python manage.py makemigrations polls 表示对模型进行了一些修改，称之为迁移（migration），会生成一个polls/migrations/0001_initial.py文件，可以进行人工编辑。 1python manage.py sqlmigrate polls 0001 可以看到SQL中，进行了那些迁移操作。 注：1、数据表的名称是将应用名称和模型名称的小写组合起来自动生成的；2、Django将附加”_id”到外键字段名称。3、该sqlmigrate命令==实际上并未在数据库上运行迁移-而是将其打印到屏幕上==，以便您可以查看SQL Django认为需要的内容。这对于检查Django将要执行的操作或是否有需要SQL脚本进行更改的数据库管理员很有用。 1python manage.py check 检查项目中是否存在任何问题，而无需进行迁移或接触数据库 1python manage.py migrate 获取所有尚未应用的迁移，并针对数据库来运行它们，实际上就是根据之前的修改来改变数据库。 模型更改的三步： • 更改模型（在models.py中）。 • 运行为这些更改创建迁移 python manage.py makemigrations • 运行以将那些更改应用到数据库 python manage.py migrate Django Admin介绍admin是作为网站管理员存在 • 创建管理员用户1python manage.py createsuperuser 之后按提示信息输入内容（在输入密码的时候，可能会有密码无回显的情况，只需正常输入，不会有其他影响，我的环境是Python3.8+Django3.0） 然后运行服务器，输入http://127.0.0.1:8000/admin/会显示管理员登录界面： 注意这里输入的不是，这个网页出现的会是错误页面：修改polls/admin.py之后，应用就可以出现在管理员页面上。 123from django.contrib import adminfrom .models import Questionadmin.site.register(Question) 之后可以通过管理员界面对Question数据库进行修改。","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"},{"name":"basic","slug":"basic","permalink":"http://codebiluo.cn/tags/basic/"}]},{"title":"Django-1","slug":"Django-1","date":"2020-01-19T09:39:15.000Z","updated":"2020-02-15T07:39:45.764Z","comments":true,"path":"2020/01/19/Django-1/","link":"","permalink":"http://codebiluo.cn/2020/01/19/Django-1/","excerpt":"","text":"• 创建项目1django-admin startproject mysite 创建了mysite目录： 12345678mysite&#x2F; manage.py #一个命令行实用程序，可让您以各种方式与该Django项目进行交互。 mysite&#x2F; __init__.py settings.py #此Django项目的设置&#x2F;配置。 urls.py #此Django项目的URL声明；Django支持的网站的“目录”。 asgi.py wsgi.py • 运行服务器1Python manage.py runserver 在浏览器中搜索http://127.0.0.1:8000/，就能看到Django火箭： • 创建应用程序（polls应用）项目和应用之间有什么区别？应用程序是执行某项操作的Web应用程序，例如Weblog系统，公共记录数据库或小型民意调查应用程序。项目是特定网站的配置和应用程序的集合。一个项目可以包含多个应用程序。一个应用程序可以在多个项目中。 1python manage.py startapp polls 创建了polls目录 123456789polls&#x2F; __init__.py admin.py apps.py migrations&#x2F; __init__.py models.py tests.py views.py • 第一个视图函数每一个请求的url地址，都对应着一个函数，叫视图函数，由视图函数处理请求后，再返回页面内容给浏览器显示。在polls/views.py中添加代码 1234from django.http import HttpResponsedef index(request): Return HttpResponse(&quot;Hello,world.You&#39;reatthepollsindex.&quot;) • 创建URL关系polls目录中创建URLconf，即创建一个urls.py文件，包含如下代码 1234567from django.urls import pathfrom . import viewsurlpatterns&#x3D;[path(&#39;&#39;, views.index, name&#x3D;&#39;index&#39;),] 在项目之下的urls.py文件（mysite/urls.py）中加入代码 1234567from django.contrib import adminfrom django.urls import include,pathurlpatterns&#x3D;[path(&#39;polls&#x2F;&#39;,include(&#39;polls.urls&#39;)),path(&#39;admin&#x2F;&#39;,admin.site.urls),] 重点：项目和应用之下urls.py文件的不同 123456# 项目下的urls.pyurlpatterns &#x3D; [ ... # 包含应用下的urls.py文件 url(正则表达式, include(&#39;应用名.urls&#39;))] 123456789101112131415# 应用下的urls.pyurlpatterns &#x3D; [ # 该path()函数传递了四个参数，两个是必需的 route和view， # 以及两个可选的kwargs和name。 path(route , view , kwargs , name), # route：route是包含URL模式的字符串。在处理请求时， # Django从第一个模式开始，urlpatterns然后沿列表向下移动， # 将请求的URL与每个模式进行比较，直到找到匹配的URL。 # view：当Django找到匹配的模式时，使用HttpRequest对象作为第一个参数， # 并将路线中所有“捕获的”值作为关键字参数，调用指定的view函数。 # name：命名URL可以使您在Django中的其他地方（尤其是在模板内部） # 明确地引用它。这项强大的功能可让您仅触摸单个文件 # 即可对项目的URL模式进行全局更改。]","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"},{"name":"basic","slug":"basic","permalink":"http://codebiluo.cn/tags/basic/"}]}]}