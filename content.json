{"meta":{"title":"Biluo","subtitle":"There is nothing permanent except change","description":"","author":"Biluo","url":"http://codebiluo.cn","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-01-19T12:44:36.954Z","updated":"2020-01-19T12:44:36.954Z","comments":true,"path":"404.html","permalink":"http://codebiluo.cn/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-01-19T12:03:53.482Z","updated":"2020-01-19T12:03:53.482Z","comments":true,"path":"about/index.html","permalink":"http://codebiluo.cn/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-01-19T09:05:44.000Z","updated":"2020-01-22T14:22:02.769Z","comments":true,"path":"categories/index.html","permalink":"http://codebiluo.cn/categories/index.html","excerpt":"","text":""},{"title":"朋友们","date":"2020-01-19T12:02:15.604Z","updated":"2020-01-19T12:02:15.604Z","comments":true,"path":"friends/index.html","permalink":"http://codebiluo.cn/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-19T09:32:34.000Z","updated":"2020-01-22T14:20:28.669Z","comments":true,"path":"tags/index.html","permalink":"http://codebiluo.cn/tags/index.html","excerpt":"","text":""},{"title":"link","date":"2020-01-19T07:41:07.000Z","updated":"2020-01-19T07:41:07.248Z","comments":true,"path":"link/index.html","permalink":"http://codebiluo.cn/link/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode-92","slug":"LeetCode-92","date":"2020-01-26T04:38:42.000Z","updated":"2020-01-26T04:52:16.621Z","comments":true,"path":"2020/01/26/LeetCode-92/","link":"","permalink":"http://codebiluo.cn/2020/01/26/LeetCode-92/","excerpt":"","text":"一、解题思路这个问题其实等同于反转链表，只是将问题变成了子链表。在反转链表的时候，是引入了prev，scan，next三个指针，分别表示当前节点的前一个节点，当前节点，当前节点的后一个节点。遍历的过程只需要将scan-&gt;next赋值为prev。最后处理头节点即可。回到这个问题，其实就是在反转m至n号节点，将最后处理头节点的过程变成处理这一段链表两端节点。 二、具体流程首先需要先找到第m个节点，然后反转m至n号节点，然后将m号节点的next指针指向第n+1号节点，再将m-1号节点的next指针指向m-1号节点。 三、重点问题在处理的过程中会有这么几个问题：eg：1-&gt;2-&gt;3-&gt;4-&gt;NULL1、考虑m=1，n=2的情况，这种情况导致m-1号节点为空，如果直接对给定链表操作，会导致代码中不断地在考虑特殊情况，所以我们添加哨位节点，这样代码实现的难度直线下降。2、考虑m=3，n=4的情况，这种情况会在next进行迭代的时候出现空指针访问的情况。所以在迭代的时候需要充分考虑空指针。 四、代码12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; ListNode *prev , *scan , *next; ListNode *tem = new ListNode(0); tem-&gt;next = head; head = tem; //添加一个哨位节点 // 遍历找第m个节点 scan = head; for (int i = 1 ; i &lt; m ; ++i) scan = scan-&gt;next; ListNode *m_1Node = scan; ListNode *mNode = scan-&gt;next; // 反转m至n号节点 prev = mNode; scan = mNode-&gt;next; next = mNode-&gt;next==NULL?NULL:mNode-&gt;next-&gt;next; //考虑翻转最后一个节点的可能 for (int i = m ; i &lt; n ; ++i) &#123; scan-&gt;next = prev; prev = scan; scan = next; next = next==NULL?NULL:next-&gt;next; // 考虑n号节点之后再没有节点 &#125; // 连接两端 m_1Node-&gt;next = prev; mNode-&gt;next = scan; return head-&gt;next; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-3","slug":"leetcode/LeetCode-3","date":"2020-01-26T03:39:48.000Z","updated":"2020-01-26T03:52:36.207Z","comments":true,"path":"2020/01/26/leetcode/LeetCode-3/","link":"","permalink":"http://codebiluo.cn/2020/01/26/leetcode/LeetCode-3/","excerpt":"","text":"一、子问题解决这道题之前，可以先思考一个重要的问题，就是给定的一段字符串，如何判断它是否有重复的字符。法一、容易想到的是遍历每一个字符，判断在它之后是否出现相同字符，时间复杂度o(n^2)。法二、同LeetCode-1，用哈希表进行搜索加速：维护一个数组作为哈希表，初始化为0。遍历字符串，并将每个字符对应位置（eg：‘f’-‘a’ = 5，‘f’对应下标为5）置为1，如果该位置已经置1，那么就说明出现重复字符。这个方法只需要一次遍历，时间复杂度o(n)。 二、问题思路解决子问题之后，我们知道可以用哈希表来进行加速。维护一个数组作为哈希表，初始化内容为-1（不初始化为0是因为之后哈希表中保存的会是字符下标），遍历整个字符串，将每一个字符对应位置保存当前字符的下标。遍历至下标n处，如果该位置对应哈希表内容为m（m != -1），则说明 [m,n) 是无重复字符子串，[m,n]会出现重复字符。计算当前无重复子串长度后，保存较大者。之后重置哈希表，再进行之后字符串的遍历。这个方法也就是官方题解中的优化滑动窗口。 三、代码1234567891011121314151617181920212223242526272829303132int lengthOfLongestSubstring(char * s)&#123; int from , to; //当前最长子串起止下标 from = to = 0; int ans = 0; int hash[256]; //每个字符的键值对 memset(hash , -1 , sizeof(hash)); while (s[to] != '\\0') &#123; if (hash[s[to]] == -1) &#123; hash[s[to]] = to; to++; &#125; else if (hash[s[to]] &lt; from) //重复的不是当前最长子串 &#123; hash[s[to]] = to; to++; &#125; else //当前最长子串出现重复，更新from的值为重复字符（前面的那个）位置加1 &#123; ans = ans &gt; (to - from) ? ans : (to - from); from = hash[s[to]] + 1; hash[s[to]] = to; to++; &#125; &#125; ans = ans &gt; (to - from) ? ans : (to - from); return ans;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-2","slug":"leetcode/LeetCode-2","date":"2020-01-23T02:54:44.000Z","updated":"2020-01-26T03:34:57.997Z","comments":true,"path":"2020/01/23/leetcode/LeetCode-2/","link":"","permalink":"http://codebiluo.cn/2020/01/23/leetcode/LeetCode-2/","excerpt":"","text":"一次遍历这个问题主要考察的是链表的操作和出现特殊情况的处理。1、当两个链表一样长的时候，问题比较好处理，直接挨个相加即可；2、当两个链表不一样的时候，就需要对遍历节点进行判断，不能出现再访问属性val的语句；3、由于一条链有可能为空这种极端情况，所以不能简单的采用原地算法；4、问题有一个小坑，就是有可能最后还有一位进位，对这个情况要考虑在内；5、可以通过添加一个哑节点来减少代码； 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *scan1 = l1; ListNode *scan2 = l2; ListNode *head = new ListNode(0); //这是哑节点 ListNode *scan = head; int flag = 0; //标记进位 while (1) &#123; if (scan1 == NULL &amp;&amp; scan2 == NULL) break; int n1 = scan1!=NULL?scan1-&gt;val:0; int n2 = scan2!=NULL?scan2-&gt;val:0; scan-&gt;next = new ListNode((n1+n2+flag)%10); flag = (n1+n2+flag)/10; if (scan1 != NULL) scan1 = scan1-&gt;next; if (scan2 != NULL) scan2 = scan2-&gt;next; scan = scan-&gt;next; &#125; if (flag) //如果最后还有进位 scan-&gt;next = new ListNode(1); return head-&gt;next; &#125;&#125;; 时间复杂度：O(MAX{m,n})空间复杂度：O(MAX{m,n})","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"LeetCode-1","slug":"leetcode/LeetCode-1","date":"2020-01-23T02:30:11.000Z","updated":"2020-01-23T02:30:55.329Z","comments":true,"path":"2020/01/23/leetcode/LeetCode-1/","link":"","permalink":"http://codebiluo.cn/2020/01/23/leetcode/LeetCode-1/","excerpt":"","text":"问题可以转换为，已有一个ele（为数组中的任意元素），需要在数组中寻找另一个元素等于target-ele 1、暴力遍历法最直观的想法遍历每一个元素，再对该元素进行遍历，查看是否有满足条件的其他元素，使得他们两的加和为target。 1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for (int i = 0 ; i &lt; nums.size() ; ++i) &#123; for (int j = i+1 ; j &lt; nums.size() ; ++j) &#123; if (nums[i]+nums[j] == target) return &#123;i , j&#125;; &#125; &#125; return &#123;-1 , -1&#125;; &#125;&#125;; 时间复杂度：O(n^2)空间复杂度：O(1) 2、一遍hash这个方法的想法主要是利用哈希表来进行查找加速。遍历数组元素ele，将ele放入哈希表中（ele值作为外键，ele下标作为內键），同时判断target-ele是否在哈希表中：如果在，那么搜索结束，直接返回；如果不在，继续遍历，直到结尾； 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; m; for (int i = 0 ; i &lt; nums.size() ; ++i) &#123; if (m.count(target-nums[i]) == 1) &#123; return &#123;m[target-nums[i]] , i&#125;; &#125; m[nums[i]] = i; &#125; return &#123;-1, -1&#125;; &#125;&#125;; 时间复杂度：O(n)空间复杂度：O(n)","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"Django-3","slug":"Django/Django-3","date":"2020-01-22T11:46:05.000Z","updated":"2020-01-22T14:11:18.794Z","comments":true,"path":"2020/01/22/Django/Django-3/","link":"","permalink":"http://codebiluo.cn/2020/01/22/Django/Django-3/","excerpt":"","text":"• 视图视图其实是视图函数的简称，视图是Django应用程序中网页的“类型”，通常具有特定功能并具有特定模板。在Django中，网页和其他内容是通过视图传递的。每个视图均由Python函数（或方法（对于基于类的视图而言））表示。Django将通过检查所请求的URL（准确地说，是域名之后的URL部分）来选择视图。 • URLURL即统一资源定位符，是每一个信息资源都有统一的且在网上唯一的地址。URLconfs即URL模式，是URL的一般形式Django提供了更加优雅的URL模式，例如： 1/newsarchive/&lt;year&gt;/&lt;month&gt;/ • 添加更多的视图更改views.py： 1234567def detail(request, question_id): return HttpResponse(\"You're looking at question %s.\" % question_id)def results(request, question_id): response = \"You're looking at the results of question %s.\" return HttpResponse(response % question_id)def vote(request, question_id): return HttpResponse(\"You're voting on question %s.\" % question_id) 并更改polls.urls.py： 123456789101112from django.urls import pathfrom . import viewsurlpatterns = [ # ex: /polls/ path('', views.index, name='index'), # ex: /polls/5/ path('&lt;int:question_id&gt;/', views.detail, name='detail'), # ex: /polls/5/results/ path('&lt;int:question_id&gt;/results/', views.results, name='results'), # ex: /polls/5/vote/ path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 根据输入的URL地址，通过遍历的方式寻找匹配的URL模式串，并调用相对应的视图函数，相应相对应的网页。比如说，当有人从网站请求页面时，例如“ / polls / 34 /”，Django将加载mysite.urls的Python模块，因为该ROOT_URLCONF设置指向该模块 。它找到名为的变量urlpatterns并按顺序遍历模式。在找到匹配项之后’polls/‘，它将剥离匹配的文本（”polls/“），并将其余文本–发送 “34/“到’polls.urls’URLconf进行进一步处理。在那里匹配’int:question_id/‘，从而导致对detail()视图的调用，如下所示：detail(request=, question_id=34) • 编写更强大的视图每个视图负责执行以下两项操作之一：返回HttpResponse包含所请求页面内容的对象，或者引发诸如之类的异常Http404。HttpResponse需要自己对其进行填充，而HttpRequest是Django自己生成。视图可以从数据库中读取记录，也可以使用Django等模板系统，也可以不使用第三方Python模板系统。它还可以使用所需的任何Python库生成PDF文件，输出XML，或即时创建ZIP文件。在view.py添加代码： 123456from .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] output = ', '.join([q.question_text for q in latest_question_list]) return HttpResponse(output) # Leave the rest of the views (detail, results, vote) unchanged • 将模板与视图创建的硬编码分开首先，在目录templates中创建一个polls目录。Django将在那里寻找模板。您的项目TEMPLATES置描述了Django如何加载和呈现模板。默认设置文件配置一个DjangoTemplates 后端，其APP_DIRS选项设置为 True。按照惯例DjangoTemplates，在每个文件夹中都会寻找一个“模板”子目录INSTALLED_APPS。在polls/templates/polls/添加一个模板： 123456789&#123;% if latest_question_list %&#125; &lt;ul&gt; &#123;% for question in latest_question_list %&#125; &lt;li&gt;&lt;a href=\"/polls/&#123;&#123; question.id &#125;&#125;/\"&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&#123;% else %&#125; &lt;p&gt;No polls are available.&lt;/p&gt;&#123;% endif %&#125; 现在运行服务器之后，可以子项/polls来加载一个“最新消息”列表。 • 快捷方式加载模板，填充上下文并使用渲染后的模板的结果返回对象HttpResponse是一种非常常见的用法。同时，Django提供了一种快捷方式。重写index()： 123456from django.shortcuts import renderfrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] context = &#123;'latest_question_list': latest_question_list&#125; return render(request, 'polls/index.html', context) 该render()函数将请求对象作为其第一个参数，将模板名称作为其第二个参数，并将字典作为其可选的第三个参数。它返回使用HttpResponse 给定上下文呈现的给定模板的对象。 • 404错误在views.py中添加代码： 12345678910from django.http import Http404from django.shortcuts import renderfrom .models import Question# ...def detail(request, question_id): try: question = Question.objects.get(pk=question_id) except Question.DoesNotExist: raise Http404(\"Question does not exist\") return render(request, 'polls/detail.html', &#123;'question': question&#125;) 为了快速使示例正常工作，对应模板polls/templates/polls/detail.html中只添加： 1&#123;&#123; question &#125;&#125; 现在运行服务器，可以看到更完整的polls网页 • 404的快捷方式重写detail()函数： 1234567from django.shortcuts import get_object_or_404, renderfrom .models import Question# ...def detail(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/detail.html', &#123;'question': question&#125;) • 使用模板系统polls/detail.html改写为： 123456&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&lt;ul&gt;&#123;% for choice in question.choice_set.all %&#125; &lt;li&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 模板系统使用点查找语法来访问变量属性。在的示例中，首先Django在对象上进行字典查找。如果失败，它将尝试属性查找-在这种情况下可以工作。如果属性查找失败，它将尝试进行列表索引查找。 • 命名空间URL名称在实际的Django项目中，可能有很多个应用程序，Django如何区分它们之间的URL名称呢？答案是将名称空间添加到URLconf中。在polls/urls.py中添加app_name以设置为应用程序名称空间： 123456789from django.urls import patfrom . import viewsapp_name = 'polls'urlpatterns = [ path('', views.index, name='index'), path('&lt;int:question_id&gt;/', views.detail, name='detail'), path('&lt;int:question_id&gt;/results/', views.results, name='results'), path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 这样可以区分多个应用程序的URL名称。","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"}]},{"title":"Django-2","slug":"Django/Django-2","date":"2020-01-19T12:37:53.000Z","updated":"2020-01-22T11:46:23.853Z","comments":true,"path":"2020/01/19/Django/Django-2/","link":"","permalink":"http://codebiluo.cn/2020/01/19/Django/Django-2/","excerpt":"","text":"• 数据库设置默认使用SQLite，相关的设置都在setting.py文件中进行。 setting,py中还有其他设置：INSTALLED_APPS文件顶部的设置。该名称包含在此Django实例中激活的所有Django应用程序的名称。其中包含一些默认的应用程序。不需要时可以在INSTALLED_APPS中删去。 1python manage.py migrate 该migrate命令将查看该INSTALLED_APPS设置，并根据mysite/settings.py文件中的数据库设置以及应用程序随附的数据库迁移来创建任何必要的数据库表。 • 创建模型模型是相关数据的唯一、确定的事实来源。它包含要存储数据的基本字段和行为。也就是一个包含各种属性（数据）和方法（行为）的类。比如说：在民意调查应用中，我们将创建两个模型：Question和Choice。Question有一个问题和出版日期。Choice有两个字段：选择的文本和投票提示。每个Choice都与关联Question。 在polls/models.py文件中添加代码 12345678from django.db import modelsclass Question(models.Model): question_text &#x3D; models.CharField(max_length&#x3D;200) pub_date &#x3D; models.DateTimeField(&#39;date published&#39;)class Choice(models.Model): question &#x3D; models.ForeignKey(Question, on_delete&#x3D;models.CASCADE) choice_text &#x3D; models.CharField(max_length&#x3D;200) votes &#x3D; models.IntegerField(default&#x3D;0) 在这里，==每个模型都是django.db.models.Model的子类==。每个模型都有许多类变量，每个类变量代表模型中的数据库字段。==每一个字段都是一个Field的实例==，不同的Field代表了不同类型的数据。 • 激活模型为了包含应用，需要将应用的引用添加在设置的INSTALLED_APPS中，也就是将polls.apps.PollsConfig添加到INSTALLED_APPS中 123456789INSTALLED_APPS &#x3D; [ &#39;polls.apps.PollsConfig&#39;, &#39;django.contrib.admin&#39;, &#39;django.contrib.auth&#39;, &#39;django.contrib.contenttypes&#39;, &#39;django.contrib.sessions&#39;, &#39;django.contrib.messages&#39;, &#39;django.contrib.staticfiles&#39;,] 1python manage.py makemigrations polls 表示对模型进行了一些修改，称之为迁移（migration），会生成一个polls/migrations/0001_initial.py文件，可以进行人工编辑。 1python manage.py sqlmigrate polls 0001 可以看到SQL中，进行了那些迁移操作。 注：1、数据表的名称是将应用名称和模型名称的小写组合起来自动生成的；2、Django将附加”_id”到外键字段名称。3、该sqlmigrate命令==实际上并未在数据库上运行迁移-而是将其打印到屏幕上==，以便您可以查看SQL Django认为需要的内容。这对于检查Django将要执行的操作或是否有需要SQL脚本进行更改的数据库管理员很有用。 1python manage.py check 检查项目中是否存在任何问题，而无需进行迁移或接触数据库 1python manage.py migrate 获取所有尚未应用的迁移，并针对数据库来运行它们，实际上就是根据之前的修改来改变数据库。 模型更改的三步： • 更改模型（在models.py中）。 • 运行为这些更改创建迁移 python manage.py makemigrations • 运行以将那些更改应用到数据库 python manage.py migrate Django Admin介绍admin是作为网站管理员存在 • 创建管理员用户1python manage.py createsuperuser 之后按提示信息输入内容（在输入密码的时候，可能会有密码无回显的情况，只需正常输入，不会有其他影响，我的环境是Python3.8+Django3.0） 然后运行服务器，输入http://127.0.0.1:8000/admin/会显示管理员登录界面： 注意这里输入的不是，这个网页出现的会是错误页面：修改polls/admin.py之后，应用就可以出现在管理员页面上。 123from django.contrib import adminfrom .models import Questionadmin.site.register(Question) 之后可以通过管理员界面对Question数据库进行修改。","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"}]},{"title":"Django-1","slug":"Django/Django-1","date":"2020-01-19T09:39:15.000Z","updated":"2020-01-19T12:59:47.525Z","comments":true,"path":"2020/01/19/Django/Django-1/","link":"","permalink":"http://codebiluo.cn/2020/01/19/Django/Django-1/","excerpt":"","text":"• 创建项目1django-admin startproject mysite 创建了mysite目录： 12345678mysite&#x2F; manage.py #一个命令行实用程序，可让您以各种方式与该Django项目进行交互。 mysite&#x2F; __init__.py settings.py #此Django项目的设置&#x2F;配置。 urls.py #此Django项目的URL声明；Django支持的网站的“目录”。 asgi.py wsgi.py • 运行服务器1Python manage.py runserver 在浏览器中搜索http://127.0.0.1:8000/，就能看到Django火箭： • 创建应用程序（polls应用）项目和应用之间有什么区别？应用程序是执行某项操作的Web应用程序，例如Weblog系统，公共记录数据库或小型民意调查应用程序。项目是特定网站的配置和应用程序的集合。一个项目可以包含多个应用程序。一个应用程序可以在多个项目中。 1python manage.py startapp polls 创建了polls目录 123456789polls&#x2F; __init__.py admin.py apps.py migrations&#x2F; __init__.py models.py tests.py views.py • 第一个视图函数每一个请求的url地址，都对应着一个函数，叫视图函数，由视图函数处理请求后，再返回页面内容给浏览器显示。在polls/views.py中添加代码 1234from django.http import HttpResponsedef index(request): Return HttpResponse(&quot;Hello,world.You&#39;reatthepollsindex.&quot;) • 创建URL关系polls目录中创建URLconf，即创建一个urls.py文件，包含如下代码 1234567from django.urls import pathfrom . import viewsurlpatterns&#x3D;[path(&#39;&#39;, views.index, name&#x3D;&#39;index&#39;),] 在项目之下的urls.py文件（mysite/urls.py）中加入代码 1234567from django.contrib import adminfrom django.urls import include,pathurlpatterns&#x3D;[path(&#39;polls&#x2F;&#39;,include(&#39;polls.urls&#39;)),path(&#39;admin&#x2F;&#39;,admin.site.urls),] 重点：项目和应用之下urls.py文件的不同 123456# 项目下的urls.pyurlpatterns &#x3D; [ ... # 包含应用下的urls.py文件 url(正则表达式, include(&#39;应用名.urls&#39;))] 123456789101112131415# 应用下的urls.pyurlpatterns &#x3D; [ # 该path()函数传递了四个参数，两个是必需的 route和view， # 以及两个可选的kwargs和name。 path(route , view , kwargs , name), # route：route是包含URL模式的字符串。在处理请求时， # Django从第一个模式开始，urlpatterns然后沿列表向下移动， # 将请求的URL与每个模式进行比较，直到找到匹配的URL。 # view：当Django找到匹配的模式时，使用HttpRequest对象作为第一个参数， # 并将路线中所有“捕获的”值作为关键字参数，调用指定的view函数。 # name：命名URL可以使您在Django中的其他地方（尤其是在模板内部） # 明确地引用它。这项强大的功能可让您仅触摸单个文件 # 即可对项目的URL模式进行全局更改。]","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"}]}]}