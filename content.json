{"meta":{"title":"Biluo","subtitle":"There is nothing permanent except change","description":"","author":"Biluo","url":"http://codebiluo.cn","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-01-19T12:44:36.954Z","updated":"2020-01-19T12:44:36.954Z","comments":true,"path":"404.html","permalink":"http://codebiluo.cn/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"毕罗不是我的名字！","date":"2020-02-10T16:49:33.505Z","updated":"2020-02-10T16:49:33.505Z","comments":true,"path":"about/index.html","permalink":"http://codebiluo.cn/about/index.html","excerpt":"","text":"There‘s nothing permanent except CHANGE! 我是一个爱电影的成长期程序员，这里是我自己搭建的博客（用的是hexo+主题Material-X）。我会在这里分享技术、发布题解（然而我并不是ACM大佬，目前发布的都是一些LeetCode的题解），我还会聊一聊电影，写一些影评。望有缘人能有所收获，找到自己！！！ 由于题解过多，让博客显得臃肿，所以我将题解移到了GitBook上，这样大家看起来也可以更加方便！–（就是不知道有没有人看）– 技术只是手段，兴趣才会带来改变，希望探索各种新鲜的事物（不仅只是技术哦）能成为各位永恒的兴趣。"},{"title":"tags","date":"2020-01-19T09:32:34.000Z","updated":"2020-01-22T14:20:28.669Z","comments":true,"path":"tags/index.html","permalink":"http://codebiluo.cn/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-01-19T09:05:44.000Z","updated":"2020-01-22T14:22:02.769Z","comments":true,"path":"categories/index.html","permalink":"http://codebiluo.cn/categories/index.html","excerpt":"","text":""},{"title":"朋友们","date":"2020-02-05T11:20:14.342Z","updated":"2020-02-05T11:20:14.342Z","comments":true,"path":"friends/index.html","permalink":"http://codebiluo.cn/friends/index.html","excerpt":"","text":""},{"title":"link","date":"2020-01-19T07:41:07.000Z","updated":"2020-01-19T07:41:07.248Z","comments":true,"path":"link/index.html","permalink":"http://codebiluo.cn/link/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode-over","slug":"LeetCode-over","date":"2020-02-10T16:50:37.000Z","updated":"2020-02-10T16:56:11.656Z","comments":true,"path":"2020/02/11/LeetCode-over/","link":"","permalink":"http://codebiluo.cn/2020/02/11/LeetCode-over/","excerpt":"","text":"这是关于LeetCode在本博客的最后一篇文章，让我们悼念那些让我的博客显得臃肿无比的题解们。但是令人开心的是：他们在新的地方获得新生，那就是使用GitBook做出的一个电子书（官方是这么形容的）。之后刷LeetCode的题解都会发布在这里，我也会将它做成一个专栏，也希望大家能从中有所收获！最后附上链接： http://codebiluo.cn/myLeetCode/","categories":[{"name":"刷题","slug":"刷题","permalink":"http://codebiluo.cn/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codebiluo.cn/tags/LeetCode/"}]},{"title":"Unity+ARFoundation","slug":"Unity-ARFoundation","date":"2020-02-04T04:46:26.000Z","updated":"2020-02-05T11:21:21.924Z","comments":true,"path":"2020/02/04/Unity-ARFoundation/","link":"","permalink":"http://codebiluo.cn/2020/02/04/Unity-ARFoundation/","excerpt":"","text":"前两天想要上手Unity来AR方面的项目软件 ，探索过程中出现了各种各样的问题，现在将这个过程中遇到的各种各样问题梳理一下，希望后来者能开开心心上手Unity+AR。注意：这是一篇踩坑博客，具体搭建还请自行百度。 一、ARFoundation or ARCore or ARKitUnity作为一个平台，不直接提供XR（包括VR、AR和MR）的开发包，这时就需要其他公司提供各种各样的SDK工具包，国外有苹果公司的ARKit、谷歌公司的ARCore、Unity的ARFoundation，还有最近发现的OpenCVForUnity，而国内有EasyAR这些SDK工具包。ARKit是针对于IOS开发，ARCore是针对于Android开发，而我使用的是ARFoundation，这是Unity将ARKit和ARCore进一步整合的工作平台。（这里就要说到一个应该知道的问题，IOS开发一定需要Mac，或者是电脑装双系统，据望网友可靠信息，如果使用虚拟机，龟速运行不说， 还会有很多Bug。） 二、Android JDK &amp; NDK1、解决方法这是搭建环境过程遇到的最让我头疼的问题，直接原因就是我对进度条的不信任。当你进行Android开发时，需要将项目打包成apk，这时就需要Android JDK &amp; NDK工具包，这时你有两种选择①、自行下载SDK manager和NDK；（这条路让我感受到世界的恶意）②、使用Unity Hub直接下载Unity 2019.3.0f6 (64-bit)，这样可以直接添加各种模块； 2、方法①（想要较好解决方法的同学可以直接看方法②）SDK和NDK下载可以直接从官网下载，建议使用Goole浏览器的迅雷插件，这样可以快一点。SDK：https://www.androiddevtools.cn/NDK：https://developer.android.google.cn/ndk/downloads/下载SDK Tools后打开SDK manager再下载需要的对应工具，尽量下载最新版本。下载NDK之后，就会遇到一个第一个问题：NDK版本不正确令人震惊的是，Unity要求的NDK版本的小版本号怎么这么长！（黑人问号脸）还能把所有小版本都发布吗！这就导致我花费了大量时间在下载NDK，大版本错完小版本错，小版本错完之后还有错。 3、方法②对比之下，方法②就非常好。下载了Unity Hub之后，添加Android Build Support以及其分目录的模块后，直接下载Unity 2019.3.0f6 (64-bit)或者是Unity 2019.2.20f1 (64-bit)。下载的过程比较漫长，需要耐心等待，但是面包总会有的。下载到五分之四的时候，进度条就会卡住，而由于我对进度条的不信任，我就直接取消下载转到方法一。。。所以使用这个方法你只要相信进度条即可。 三、Mininum API Level配置环境的过程，有一个步骤时设置Mininum API Level，而我想的是设置的小一些，一定不会有问题，但事实不是如此。当我将其设置为最小的API Level 19：在编译运行的时候，会出现报错：这时需要将Mininum API Level设置的大一些，比如我设置的是API Level 24，就可以成功编译。 四、Building Gradle Project最终编译的时候，进度条再一次卡住/(ㄒoㄒ)/~~，这时编译进行到Building Gradle Project，Unity会直接卡死。 Gradle是一个基于JVM的构建工具，是一款通用灵活的构建工具，支持maven， Ivy仓库，支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml配置文件，基于Groovy，build脚本使用Groovy编写。——百度百科 而编译卡在这里的原因由于本地并没有Gradle，所以编译时需要下载，而外网资源下载速度我不用再提，据网友信息，他编译数小时后成功了！ 真是很短的时间呢！但我采取了其他的方法：预先下载Gradle。我下载的是gradle-5.4.1，之后在Edit-&gt;Preferences中将下载内容的地址输入到Gradle中。辛苦一整天，遇到诸多艰难，所幸克服，没有放弃，坚持走下去咯！","categories":[{"name":"Unity","slug":"Unity","permalink":"http://codebiluo.cn/categories/Unity/"}],"tags":[{"name":"AR","slug":"AR","permalink":"http://codebiluo.cn/tags/AR/"}]},{"title":"Django-4","slug":"Django-4","date":"2020-01-27T13:50:46.000Z","updated":"2020-01-27T13:51:05.717Z","comments":true,"path":"2020/01/27/Django-4/","link":"","permalink":"http://codebiluo.cn/2020/01/27/Django-4/","excerpt":"","text":"• 编写一个用于问题显示的表单（form）form是HTML的一个元素，修改polls/detail.html 12345678910&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&#123;% if error_message %&#125;&lt;p&gt;&lt;strong&gt;&#123;&#123; error_message &#125;&#125;&lt;/strong&gt;&lt;/p&gt;&#123;% endif %&#125;&lt;form action=\"&#123;% url 'polls:vote' question.id %&#125;\" method=\"post\"&gt;&#123;% csrf_token %&#125;&#123;% for choice in question.choice_set.all %&#125; &lt;input type=\"radio\" name=\"choice\" id=\"choice&#123;&#123; forloop.counter &#125;&#125;\" value=\"&#123;&#123; choice.id &#125;&#125;\"&gt; &lt;label for=\"choice&#123;&#123; forloop.counter &#125;&#125;\"&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/label&gt;&lt;br&gt;&#123;% endfor %&#125;&lt;input type=\"submit\" value=\"Vote\"&gt;&lt;/form&gt; 这部分涉及HTML相关内容，不再赘述 • 添加投票界面的相关内容添加关于polls/views.py的vote()函数的相关实现： 12345678910111213141516171819202122from django.http import HttpResponse, HttpResponseRedirectfrom django.shortcuts import get_object_or_404, renderfrom django.urls import reversefrom .models import Choice, Question# ...def vote(request, question_id): question = get_object_or_404(Question, pk=question_id) try: selected_choice = question.choice_set.get(pk=request.POST['choice']) except (KeyError, Choice.DoesNotExist): # Redisplay the question voting form. return render(request, 'polls/detail.html', &#123; 'question': question, 'error_message': \"You didn't select a choice.\", &#125;) else: selected_choice.votes += 1 selected_choice.save() # Always return an HttpResponseRedirect after successfully dealing # with POST data. This prevents data from being posted twice if a # user hits the Back button. return HttpResponseRedirect(reverse('polls:results', args=(question.id,))) 相关内容说明：1、request.POST是类似于字典的对象，可让您通过键名访问提交的数据。在这种情况下， request.POST[‘choice’]以字符串形式返回所选选项的ID。request.POST值始终是字符串。 请注意，Django还提供request.GET了以相同方式访问GET数据的方法-但我们request.POST在代码中明确使用，以确保仅通过POST调用更改数据。 2、如果没有提供POST数据，那么就会产生KEYERROR异常，重新显示问题表单。 3、在此示例reverse()中，我们在HttpResponseRedirect构造函数中使用该函数 。此功能有助于避免在视图功能中对URL进行硬编码。它提供了我们想要将控制权传递给的视图的名称，以及指向该视图的URL模式的可变部分。在这种情况下，使用我们在教程3中设置的URLconf ，此reverse()调用将返回一个字符串，例如’/polls/3/results/‘，其中3是的值question.id。然后，此重定向的URL将调用‘results’视图以显示最后一页。 • 投票结果页面相关内容进行投票之后，vote()视图将重定向到该问题的结果页面，故编写视图在views.py： 1234from django.shortcuts import get_object_or_404, renderdef results(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/results.html', &#123;'question': question&#125;) 同时创建polls/results.html模板： 1234567&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&lt;ul&gt;&#123;% for choice in question.choice_set.all %&#125; &lt;li&gt;&#123;&#123; choice.choice_text &#125;&#125; -- &#123;&#123; choice.votes &#125;&#125; vote&#123;&#123; choice.votes|pluralize &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt;&lt;a href=\"&#123;% url 'polls:detail' question.id %&#125;\"&gt;Vote again?&lt;/a&gt; 现在可以运行服务器，来看一看问题页面、投票页面和投票结果显示页面， • 使用通用视图来减少代码量在 detail() 和 results() 的视图函数是非常短并且相似，所以重复的代码是冗余的。这些视图代表了基本Web开发的一种常见情况：根据URL中传递的参数从数据库获取数据，加载模板并返回渲染的模板。因为这很常见，所以Django提供了一个捷径，称为“通用视图”系统。为了转换为通用视图系统，需要经过一些步骤： 1. 转换URLconf。 2. 删除一些旧的不需要的视图。 3. 根据Django的通用视图介绍新视图。 修改URL配置首先对polls/urls.py的URLconf进行修改： 123456789from django.urls import pathfrom . import viewsapp_name = 'polls'urlpatterns = [ path('', views.IndexView.as_view(), name='index'), path('&lt;int:pk&gt;/', views.DetailView.as_view(), name='detail'), path('&lt;int:pk&gt;/results/', views.ResultsView.as_view(), name='results'), path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 修改的是将更改为。 修改视图将polls/views.py修改为： 12345678910111213141516171819from django.http import HttpResponseRedirectfrom django.shortcuts import get_object_or_404, renderfrom django.urls import reversefrom django.views import genericfrom .models import Choice, Questionclass IndexView(generic.ListView): template_name = 'polls/index.html' context_object_name = 'latest_question_list'def get_queryset(self): \"\"\"Return the last five published questions.\"\"\" return Question.objects.order_by('-pub_date')[:5]class DetailView(generic.DetailView): model = Question template_name = 'polls/detail.html'class ResultsView(generic.DetailView): model = Question template_name = 'polls/results.html'def vote(request, question_id): ... # same as above, no changes needed. 在这里使用了两个通用视图ListView和DetailView，分别抽象了“显示对象列表”和“显示特定类型的对象的详细信息页面”的概念。","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"}]},{"title":"Django-3","slug":"Django-3","date":"2020-01-22T11:46:05.000Z","updated":"2020-01-22T14:11:18.794Z","comments":true,"path":"2020/01/22/Django-3/","link":"","permalink":"http://codebiluo.cn/2020/01/22/Django-3/","excerpt":"","text":"• 视图视图其实是视图函数的简称，视图是Django应用程序中网页的“类型”，通常具有特定功能并具有特定模板。在Django中，网页和其他内容是通过视图传递的。每个视图均由Python函数（或方法（对于基于类的视图而言））表示。Django将通过检查所请求的URL（准确地说，是域名之后的URL部分）来选择视图。 • URLURL即统一资源定位符，是每一个信息资源都有统一的且在网上唯一的地址。URLconfs即URL模式，是URL的一般形式Django提供了更加优雅的URL模式，例如： 1/newsarchive/&lt;year&gt;/&lt;month&gt;/ • 添加更多的视图更改views.py： 1234567def detail(request, question_id): return HttpResponse(\"You're looking at question %s.\" % question_id)def results(request, question_id): response = \"You're looking at the results of question %s.\" return HttpResponse(response % question_id)def vote(request, question_id): return HttpResponse(\"You're voting on question %s.\" % question_id) 并更改polls.urls.py： 123456789101112from django.urls import pathfrom . import viewsurlpatterns = [ # ex: /polls/ path('', views.index, name='index'), # ex: /polls/5/ path('&lt;int:question_id&gt;/', views.detail, name='detail'), # ex: /polls/5/results/ path('&lt;int:question_id&gt;/results/', views.results, name='results'), # ex: /polls/5/vote/ path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 根据输入的URL地址，通过遍历的方式寻找匹配的URL模式串，并调用相对应的视图函数，相应相对应的网页。比如说，当有人从网站请求页面时，例如“ / polls / 34 /”，Django将加载mysite.urls的Python模块，因为该ROOT_URLCONF设置指向该模块 。它找到名为的变量urlpatterns并按顺序遍历模式。在找到匹配项之后’polls/‘，它将剥离匹配的文本（”polls/“），并将其余文本–发送 “34/“到’polls.urls’URLconf进行进一步处理。在那里匹配’int:question_id/‘，从而导致对detail()视图的调用，如下所示：detail(request=, question_id=34) • 编写更强大的视图每个视图负责执行以下两项操作之一：返回HttpResponse包含所请求页面内容的对象，或者引发诸如之类的异常Http404。HttpResponse需要自己对其进行填充，而HttpRequest是Django自己生成。视图可以从数据库中读取记录，也可以使用Django等模板系统，也可以不使用第三方Python模板系统。它还可以使用所需的任何Python库生成PDF文件，输出XML，或即时创建ZIP文件。在view.py添加代码： 123456from .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] output = ', '.join([q.question_text for q in latest_question_list]) return HttpResponse(output) # Leave the rest of the views (detail, results, vote) unchanged • 将模板与视图创建的硬编码分开首先，在目录templates中创建一个polls目录。Django将在那里寻找模板。您的项目TEMPLATES置描述了Django如何加载和呈现模板。默认设置文件配置一个DjangoTemplates 后端，其APP_DIRS选项设置为 True。按照惯例DjangoTemplates，在每个文件夹中都会寻找一个“模板”子目录INSTALLED_APPS。在polls/templates/polls/添加一个模板： 123456789&#123;% if latest_question_list %&#125; &lt;ul&gt; &#123;% for question in latest_question_list %&#125; &lt;li&gt;&lt;a href=\"/polls/&#123;&#123; question.id &#125;&#125;/\"&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&#123;% else %&#125; &lt;p&gt;No polls are available.&lt;/p&gt;&#123;% endif %&#125; 现在运行服务器之后，可以子项/polls来加载一个“最新消息”列表。 • 快捷方式加载模板，填充上下文并使用渲染后的模板的结果返回对象HttpResponse是一种非常常见的用法。同时，Django提供了一种快捷方式。重写index()： 123456from django.shortcuts import renderfrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] context = &#123;'latest_question_list': latest_question_list&#125; return render(request, 'polls/index.html', context) 该render()函数将请求对象作为其第一个参数，将模板名称作为其第二个参数，并将字典作为其可选的第三个参数。它返回使用HttpResponse 给定上下文呈现的给定模板的对象。 • 404错误在views.py中添加代码： 12345678910from django.http import Http404from django.shortcuts import renderfrom .models import Question# ...def detail(request, question_id): try: question = Question.objects.get(pk=question_id) except Question.DoesNotExist: raise Http404(\"Question does not exist\") return render(request, 'polls/detail.html', &#123;'question': question&#125;) 为了快速使示例正常工作，对应模板polls/templates/polls/detail.html中只添加： 1&#123;&#123; question &#125;&#125; 现在运行服务器，可以看到更完整的polls网页 • 404的快捷方式重写detail()函数： 1234567from django.shortcuts import get_object_or_404, renderfrom .models import Question# ...def detail(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/detail.html', &#123;'question': question&#125;) • 使用模板系统polls/detail.html改写为： 123456&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&lt;ul&gt;&#123;% for choice in question.choice_set.all %&#125; &lt;li&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 模板系统使用点查找语法来访问变量属性。在的示例中，首先Django在对象上进行字典查找。如果失败，它将尝试属性查找-在这种情况下可以工作。如果属性查找失败，它将尝试进行列表索引查找。 • 命名空间URL名称在实际的Django项目中，可能有很多个应用程序，Django如何区分它们之间的URL名称呢？答案是将名称空间添加到URLconf中。在polls/urls.py中添加app_name以设置为应用程序名称空间： 123456789from django.urls import patfrom . import viewsapp_name = 'polls'urlpatterns = [ path('', views.index, name='index'), path('&lt;int:question_id&gt;/', views.detail, name='detail'), path('&lt;int:question_id&gt;/results/', views.results, name='results'), path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 这样可以区分多个应用程序的URL名称。","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"}]},{"title":"Django-2","slug":"Django-2","date":"2020-01-19T12:37:53.000Z","updated":"2020-01-22T11:46:23.853Z","comments":true,"path":"2020/01/19/Django-2/","link":"","permalink":"http://codebiluo.cn/2020/01/19/Django-2/","excerpt":"","text":"• 数据库设置默认使用SQLite，相关的设置都在setting.py文件中进行。 setting,py中还有其他设置：INSTALLED_APPS文件顶部的设置。该名称包含在此Django实例中激活的所有Django应用程序的名称。其中包含一些默认的应用程序。不需要时可以在INSTALLED_APPS中删去。 1python manage.py migrate 该migrate命令将查看该INSTALLED_APPS设置，并根据mysite/settings.py文件中的数据库设置以及应用程序随附的数据库迁移来创建任何必要的数据库表。 • 创建模型模型是相关数据的唯一、确定的事实来源。它包含要存储数据的基本字段和行为。也就是一个包含各种属性（数据）和方法（行为）的类。比如说：在民意调查应用中，我们将创建两个模型：Question和Choice。Question有一个问题和出版日期。Choice有两个字段：选择的文本和投票提示。每个Choice都与关联Question。 在polls/models.py文件中添加代码 12345678from django.db import modelsclass Question(models.Model): question_text &#x3D; models.CharField(max_length&#x3D;200) pub_date &#x3D; models.DateTimeField(&#39;date published&#39;)class Choice(models.Model): question &#x3D; models.ForeignKey(Question, on_delete&#x3D;models.CASCADE) choice_text &#x3D; models.CharField(max_length&#x3D;200) votes &#x3D; models.IntegerField(default&#x3D;0) 在这里，==每个模型都是django.db.models.Model的子类==。每个模型都有许多类变量，每个类变量代表模型中的数据库字段。==每一个字段都是一个Field的实例==，不同的Field代表了不同类型的数据。 • 激活模型为了包含应用，需要将应用的引用添加在设置的INSTALLED_APPS中，也就是将polls.apps.PollsConfig添加到INSTALLED_APPS中 123456789INSTALLED_APPS &#x3D; [ &#39;polls.apps.PollsConfig&#39;, &#39;django.contrib.admin&#39;, &#39;django.contrib.auth&#39;, &#39;django.contrib.contenttypes&#39;, &#39;django.contrib.sessions&#39;, &#39;django.contrib.messages&#39;, &#39;django.contrib.staticfiles&#39;,] 1python manage.py makemigrations polls 表示对模型进行了一些修改，称之为迁移（migration），会生成一个polls/migrations/0001_initial.py文件，可以进行人工编辑。 1python manage.py sqlmigrate polls 0001 可以看到SQL中，进行了那些迁移操作。 注：1、数据表的名称是将应用名称和模型名称的小写组合起来自动生成的；2、Django将附加”_id”到外键字段名称。3、该sqlmigrate命令==实际上并未在数据库上运行迁移-而是将其打印到屏幕上==，以便您可以查看SQL Django认为需要的内容。这对于检查Django将要执行的操作或是否有需要SQL脚本进行更改的数据库管理员很有用。 1python manage.py check 检查项目中是否存在任何问题，而无需进行迁移或接触数据库 1python manage.py migrate 获取所有尚未应用的迁移，并针对数据库来运行它们，实际上就是根据之前的修改来改变数据库。 模型更改的三步： • 更改模型（在models.py中）。 • 运行为这些更改创建迁移 python manage.py makemigrations • 运行以将那些更改应用到数据库 python manage.py migrate Django Admin介绍admin是作为网站管理员存在 • 创建管理员用户1python manage.py createsuperuser 之后按提示信息输入内容（在输入密码的时候，可能会有密码无回显的情况，只需正常输入，不会有其他影响，我的环境是Python3.8+Django3.0） 然后运行服务器，输入http://127.0.0.1:8000/admin/会显示管理员登录界面： 注意这里输入的不是，这个网页出现的会是错误页面：修改polls/admin.py之后，应用就可以出现在管理员页面上。 123from django.contrib import adminfrom .models import Questionadmin.site.register(Question) 之后可以通过管理员界面对Question数据库进行修改。","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"}]},{"title":"Django-1","slug":"Django-1","date":"2020-01-19T09:39:15.000Z","updated":"2020-01-19T12:59:47.525Z","comments":true,"path":"2020/01/19/Django-1/","link":"","permalink":"http://codebiluo.cn/2020/01/19/Django-1/","excerpt":"","text":"• 创建项目1django-admin startproject mysite 创建了mysite目录： 12345678mysite&#x2F; manage.py #一个命令行实用程序，可让您以各种方式与该Django项目进行交互。 mysite&#x2F; __init__.py settings.py #此Django项目的设置&#x2F;配置。 urls.py #此Django项目的URL声明；Django支持的网站的“目录”。 asgi.py wsgi.py • 运行服务器1Python manage.py runserver 在浏览器中搜索http://127.0.0.1:8000/，就能看到Django火箭： • 创建应用程序（polls应用）项目和应用之间有什么区别？应用程序是执行某项操作的Web应用程序，例如Weblog系统，公共记录数据库或小型民意调查应用程序。项目是特定网站的配置和应用程序的集合。一个项目可以包含多个应用程序。一个应用程序可以在多个项目中。 1python manage.py startapp polls 创建了polls目录 123456789polls&#x2F; __init__.py admin.py apps.py migrations&#x2F; __init__.py models.py tests.py views.py • 第一个视图函数每一个请求的url地址，都对应着一个函数，叫视图函数，由视图函数处理请求后，再返回页面内容给浏览器显示。在polls/views.py中添加代码 1234from django.http import HttpResponsedef index(request): Return HttpResponse(&quot;Hello,world.You&#39;reatthepollsindex.&quot;) • 创建URL关系polls目录中创建URLconf，即创建一个urls.py文件，包含如下代码 1234567from django.urls import pathfrom . import viewsurlpatterns&#x3D;[path(&#39;&#39;, views.index, name&#x3D;&#39;index&#39;),] 在项目之下的urls.py文件（mysite/urls.py）中加入代码 1234567from django.contrib import adminfrom django.urls import include,pathurlpatterns&#x3D;[path(&#39;polls&#x2F;&#39;,include(&#39;polls.urls&#39;)),path(&#39;admin&#x2F;&#39;,admin.site.urls),] 重点：项目和应用之下urls.py文件的不同 123456# 项目下的urls.pyurlpatterns &#x3D; [ ... # 包含应用下的urls.py文件 url(正则表达式, include(&#39;应用名.urls&#39;))] 123456789101112131415# 应用下的urls.pyurlpatterns &#x3D; [ # 该path()函数传递了四个参数，两个是必需的 route和view， # 以及两个可选的kwargs和name。 path(route , view , kwargs , name), # route：route是包含URL模式的字符串。在处理请求时， # Django从第一个模式开始，urlpatterns然后沿列表向下移动， # 将请求的URL与每个模式进行比较，直到找到匹配的URL。 # view：当Django找到匹配的模式时，使用HttpRequest对象作为第一个参数， # 并将路线中所有“捕获的”值作为关键字参数，调用指定的view函数。 # name：命名URL可以使您在Django中的其他地方（尤其是在模板内部） # 明确地引用它。这项强大的功能可让您仅触摸单个文件 # 即可对项目的URL模式进行全局更改。]","categories":[{"name":"python","slug":"python","permalink":"http://codebiluo.cn/categories/python/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://codebiluo.cn/tags/Django/"}]}]}