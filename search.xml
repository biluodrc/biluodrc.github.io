<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode-108-109</title>
      <link href="/2020/02/08/LeetCode-108-109/"/>
      <url>/2020/02/08/LeetCode-108-109/</url>
      
        <content type="html"><![CDATA[<h5 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h5><p>这两道题都是要求将线性表转换成二叉搜索树，数组转化为二叉搜索树是很简单的，使用<strong>标准的二分法</strong>即可，不再赘述，之后附上代码。<br>重点的问题是如何将链表转化为二叉搜索树（这里就不谈将链表转为数组这种只为AC的方法了）。由于不能用下标来访问链表，所以单纯地用数组转树的二分法是不合理的。那么不使用下标，该如何访问链表中点处的节点呢？方法是<strong>用快指针和慢指针来查找中点处的节点</strong>：<em>快指针每次移动两个节点，慢指针每次移动一个节点，当快指针访问到链尾的时候，慢指针正好指的位置就是中点处的节点。</em> Over！</p><h5 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 108题代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums , <span class="number">0</span> , nums.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums , <span class="keyword">int</span> left , <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        node-&gt;left = helper(nums , left , mid);</span><br><span class="line">        node-&gt;right = helper(nums , mid+<span class="number">1</span> , right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 109题代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(head , <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(ListNode *left , ListNode *right)</span>  <span class="comment">// 表示一种左闭右开</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *slow , *fast;</span><br><span class="line">        slow = fast = left;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == right || fast-&gt;next == right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *ans = <span class="keyword">new</span> TreeNode(slow-&gt;val);</span><br><span class="line">        ans-&gt;left = helper(left , slow);</span><br><span class="line">        ans-&gt;right = helper(slow-&gt;next , right);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-51/52 经典回溯问题</title>
      <link href="/2020/02/08/LeetCode-51-52/"/>
      <url>/2020/02/08/LeetCode-51-52/</url>
      
        <content type="html"><![CDATA[<h5 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h5><p>N皇后问题可以说是最经典的回溯问题，经典到刚接触C语言的时候，就有讲到这个问题。<br>现在重新看这个问题，就会比较熟练：问题是在<strong>模拟摆放皇后</strong>，使他们满足皇后之间不可互相攻击这个条件。</p><blockquote><p>国际象棋中，皇后可以横、直、斜着走，步数不受限制，但不能越子。<br>如对国际象棋感兴趣可以自己在 <a href="https://lichess.org/" target="_blank" rel="noopener">https://lichess.org/</a> 这个网站上自己玩。</p></blockquote><p>如果将棋盘分成<strong>行、列、斜三种情况（斜这种情况其实还包含了45°和-45°两种）</strong>，那么就需要我们对已经存在皇后的行、列、斜进行标记，标记的方法再好不过就是对他们编号，然后某一个位置有皇后之后，就将其对应行、列、斜编号的位置置为1（表示这些行、列、斜已经放置过皇后，不应该再放），用于之后新皇后是否能放在某个位置的判断。<br>行列的编号很简单，重点是在斜的情况编号，我使用的是找到他们行列号与斜编号的关系。易知，一个方向的斜应该有2<em>N-1个，我是假想了一种映射，将同一个斜上的所有皇后，都映射到行号为0或者是列号为零的行、列上。图示如下： <img src="https://img-blog.csdnimg.cn/20200208145343679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTc1OTI2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面就是找规律的游戏，最终我得到的斜编号与行列编号之间的关系是：<br>*</em>45°斜编号 = c+r;    -45°斜编号 = n+r-c;（r为行编号，c为列编号，n为棋盘大小）**</p><h5 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 51题代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; flagR(n , <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; flagX1(<span class="number">2</span>*n , <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; flagX2(<span class="number">2</span>*n , <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tem(n , <span class="built_in">string</span>(n , <span class="string">'.'</span>));</span><br><span class="line">    </span><br><span class="line">        helper(ans , tem , <span class="number">0</span> , n , flagR , flagX1 , flagX2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;ans , <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tem , </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> c , <span class="keyword">int</span> n , <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;flagR , </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;flagX1 , <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;flagX2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == n)  <span class="comment">// 递归终点，所有列都遍历完了</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(tem);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span> ; r &lt; n ; ++r)  <span class="comment">// 遍历行号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = c+r;</span><br><span class="line">            <span class="keyword">int</span> x2 = n+r-c;</span><br><span class="line">            <span class="keyword">if</span> (flagR[r] == <span class="number">0</span> &amp;&amp; flagX1[x1] == <span class="number">0</span> &amp;&amp; flagX2[x2] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flagR[r] = flagX1[x1] = flagX2[x2] = <span class="number">1</span>;</span><br><span class="line">                tem[r][c] = <span class="string">'Q'</span>;</span><br><span class="line">                helper(ans , tem , c+<span class="number">1</span> , n , flagR , flagX1 , flagX2);</span><br><span class="line">                flagR[r] = flagX1[x1] = flagX2[x2] = <span class="number">0</span>;</span><br><span class="line">                tem[r][c] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 52题代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; flagR(n , <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; flagX1(<span class="number">2</span>*n , <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; flagX2(<span class="number">2</span>*n , <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">        helper(ans , <span class="number">0</span> , n , flagR , flagX1 , flagX2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> &amp;ans , <span class="keyword">int</span> c , <span class="keyword">int</span> n , <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;flagR , </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;flagX1 , <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;flagX2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == n)  <span class="comment">// 递归终点，所有列都遍历完了</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span> ; r &lt; n ; ++r)  <span class="comment">// 遍历行号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = c+r;</span><br><span class="line">            <span class="keyword">int</span> x2 = n+r-c;</span><br><span class="line">            <span class="keyword">if</span> (flagR[r] == <span class="number">0</span> &amp;&amp; flagX1[x1] == <span class="number">0</span> &amp;&amp; flagX2[x2] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flagR[r] = flagX1[x1] = flagX2[x2] = <span class="number">1</span>;</span><br><span class="line">                helper(ans , c+<span class="number">1</span> , n , flagR , flagX1 , flagX2);</span><br><span class="line">                flagR[r] = flagX1[x1] = flagX2[x2] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-94 莫里斯中序遍历</title>
      <link href="/2020/02/07/LeetCode-94/"/>
      <url>/2020/02/07/LeetCode-94/</url>
      
        <content type="html"><![CDATA[<p>中序遍历常见的是递归和用栈辅助遍历两种方法，这两种方法网上很常见，故我不再赘述。<br>在看题解的时候，我看到一种莫里斯中序遍历，很有意思，就在写了一份关于这个的代码。</p><h5 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h5><p>首先是莫里斯中序遍历的过程：</p><blockquote><p>对于当前节点node来说，<br>如果node的左子树是空的，那么就将node的值压入输出序列中，并更新node的值为其右指针；<br>否则，将node左子树最右端节点的右指针指向node（这一步的目的之后会说），并更新node的值为其左指针；</p></blockquote><p>从这个过程中可以看到，压入输出序列的时间是当node左子树为空的时候。为了使左子树变空，那么就需要对不空的情况进行处理：易知，<strong>node节点压入输入序列一定是在其左子树压入输入序列之后</strong>，而一棵树中，<strong>最右侧的节点一定是最后压入的</strong>，所以将node节点放到其左子树最右端的右指针上，就能构造一个同时满足这两点，又不会改变树的输出序列的另一棵二叉树。<br>思路就是这样，在编写代码的时候，还需要注意一个问题：当node作为其左子树最右端节点的右指针的时候，还需要处理此时node的左指针，否则这棵树就会出现闭环，不再是二叉树。</p><h5 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 莫里斯中序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span>)  <span class="comment">// 左子树空</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(node-&gt;val);</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 左子树未空</span></span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *scan = node-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (scan-&gt;right != <span class="literal">NULL</span>) <span class="comment">// 搜索左节点向右遍历最右侧的节点</span></span><br><span class="line">                    scan = scan-&gt;right;</span><br><span class="line">                scan-&gt;right = node;</span><br><span class="line">                TreeNode *tem = node;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">                tem-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：o(n)<br>空间复杂度：o(n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历的递归形式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        dfs(root , ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *node , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        dfs(node-&gt;left , ans);</span><br><span class="line">        ans.push_back(node-&gt;val);</span><br><span class="line">        dfs(node-&gt;right , ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-103 双端队列</title>
      <link href="/2020/02/06/LeetCode-103/"/>
      <url>/2020/02/06/LeetCode-103/</url>
      
        <content type="html"><![CDATA[<h5 id="一、思路的诞生"><a href="#一、思路的诞生" class="headerlink" title="一、思路的诞生"></a>一、思路的诞生</h5><p>这个问题是在<strong>层次遍历的基础上做了延伸</strong>，寻找锯齿型的层次遍历。与一般层次遍历的单方向不同，锯齿形遍历是奇数层从左向右遍历，偶数层从右向左遍历（视根节点在奇数层）。<strong>这种对称的操作让我们想到了对层次遍历的数据结构队列进行改变，变为对称的双端队列</strong>（然鹅我并没有想到，我的想法还是使用队列，在入栈的顺序上做一些变化，后面会继续探讨这个想法不正确的地方。但是思路就是这样，<strong>把遍历的对称性作为突破口</strong>）。</p><h5 id="二、主要思路"><a href="#二、主要思路" class="headerlink" title="二、主要思路"></a>二、主要思路</h5><p>在确定了使用双端队列之后，接下来的问题就是具体每一层的入队、出队的位置是怎样的：<br>基本的原则是：<strong>同一层入队和出队的方向不同；相邻层入队方向不同，出队方向也不同</strong><br>基于这个原则，自己模拟一颗树的遍历过程会更加清晰的，我接下来给出我的模拟：<br><strong><em>假设：奇数层从队尾入，则偶数层从队头入</em></strong><br>初始化双端队列设为：d = [ 3 ]<br><img src="https://img-blog.csdnimg.cn/20200206115714399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTc1OTI2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第一层（根节点）：根节点从队头出；因为偶数层从队头入，队尾出，为了满足从右向左的遍历顺序，所以根节点的<strong>右节点先入，左节点后入</strong>；同时将根节点的值压入该层的遍历结果中。此时d = [ 9 , 20]；<br>第二层：<em>20</em> 出队后，因为其子节点位于奇数层，所以将其子节点<strong>先左后右</strong>压入队尾。<em>9</em> 如果有子节点也是同样的道理。压队的同时，将<em>20 9<em>按顺序压入该层的遍历结果中。此时d = [ 15 , 7]；<br>第三层：</em>15</em> 和 <em>7</em> 没有子节点，故没有压队的步骤，只需将其按顺序压入该层的遍历结果即可。<br>此时队列为空，故遍历结束，返回总体遍历结果；<br><strong>注意：</strong><br>1、问题要求返回的结果是<strong>分层保存</strong>的，故我们需要将不同层的遍历结果放在不同的一维数组中，然后再将他们放到一个二维数组中；<br>2、每一层的遍历，我们都需要知道<strong>哪些是该层的节点</strong>（不能单纯的使用下一层节点数是上一层的二倍，因为这不一定是一颗满树），我使用的方法是建了一个和保存节点的双端队列完全相同的双端队列，操作和树节点入队出队完全对应。（当然还有别的方法，暂时还能想到的是使用哈希表）</p><h5 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt; vector&lt;int&gt; &gt; ans;</span><br><span class="line">        vector&lt;int&gt; tem;</span><br><span class="line">        deque&lt;int&gt; d1;  &#x2F;&#x2F;存放节点的层数</span><br><span class="line">        deque&lt;TreeNode*&gt; d2; &#x2F;&#x2F;存放节点</span><br><span class="line">        if (root &#x3D;&#x3D; NULL)  &#x2F;&#x2F; 空树</span><br><span class="line">            return ans;</span><br><span class="line"></span><br><span class="line">        d1.push_back(1);</span><br><span class="line">        d2.push_back(root);</span><br><span class="line">        int depth &#x3D; 1;</span><br><span class="line">        while (!d1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            if (depth % 2 &#x3D;&#x3D; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                while (1)</span><br><span class="line">                &#123;</span><br><span class="line">                    int nowD &#x3D; d1.front();</span><br><span class="line">                    TreeNode* node &#x3D; d2.front();</span><br><span class="line">                    if (nowD !&#x3D; depth)  &#x2F;&#x2F;将这一层的所有节点弹出来</span><br><span class="line">                        break;</span><br><span class="line">                    tem.push_back(node-&gt;val);</span><br><span class="line">                    &#x2F;&#x2F; 将左右节点压队列（先左后右）</span><br><span class="line">                    d1.pop_front();</span><br><span class="line">                    d2.pop_front();</span><br><span class="line">                    if (node-&gt;left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        d1.push_back(nowD+1);</span><br><span class="line">                        d2.push_back(node-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (node-&gt;right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        d1.push_back(nowD+1);</span><br><span class="line">                        d2.push_back(node-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                while (1)</span><br><span class="line">                &#123;</span><br><span class="line">                    int nowD &#x3D; d1.back();</span><br><span class="line">                    TreeNode* node &#x3D; d2.back();</span><br><span class="line">                    if (nowD !&#x3D; depth)</span><br><span class="line">                        break;</span><br><span class="line">                    tem.push_back(node-&gt;val);</span><br><span class="line">                    &#x2F;&#x2F; 将右左节点压队列（先右后左）</span><br><span class="line">                    d1.pop_back();</span><br><span class="line">                    d2.pop_back();</span><br><span class="line">                    if (node-&gt;right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        d1.push_front(nowD+1);</span><br><span class="line">                        d2.push_front(node-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (node-&gt;left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        d1.push_front(nowD+1);</span><br><span class="line">                        d2.push_front(node-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(tem);</span><br><span class="line">            tem.clear();</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<strong>o(n)</strong>（遍历所有节点）</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity+ARFoundation</title>
      <link href="/2020/02/04/Unity-ARFoundation/"/>
      <url>/2020/02/04/Unity-ARFoundation/</url>
      
        <content type="html"><![CDATA[<p>前两天想要上手Unity来AR方面的<del>项目</del>软件 ，探索过程中出现了各种各样的问题，现在将这个过程中遇到的各种各样问题梳理一下，希望后来者能开开心心上手Unity+AR。<br>注意：这是一篇踩坑博客，具体搭建还请自行百度。</p><h4 id="一、ARFoundation-or-ARCore-or-ARKit"><a href="#一、ARFoundation-or-ARCore-or-ARKit" class="headerlink" title="一、ARFoundation or ARCore or ARKit"></a>一、ARFoundation or ARCore or ARKit</h4><p>Unity作为一个平台，不直接提供XR（包括VR、AR和MR）的开发包，这时就需要其他公司提供各种各样的SDK工具包，国外有苹果公司的ARKit、谷歌公司的ARCore、Unity的ARFoundation，还有最近发现的OpenCVForUnity，而国内有EasyAR这些SDK工具包。ARKit是针对于IOS开发，ARCore是针对于Android开发，而我使用的是ARFoundation，这是Unity将ARKit和ARCore进一步整合的工作平台。<br>（这里就要说到一个应该知道的问题，<strong>IOS开发一定需要Mac，或者是电脑装双系统</strong>，据望网友<del>可靠</del>信息，如果使用虚拟机，龟速运行不说， 还会有很多Bug。）</p><h4 id="二、Android-JDK-amp-NDK"><a href="#二、Android-JDK-amp-NDK" class="headerlink" title="二、Android JDK &amp; NDK"></a>二、Android JDK &amp; NDK</h4><h5 id="1、解决方法"><a href="#1、解决方法" class="headerlink" title="1、解决方法"></a>1、解决方法</h5><p>这是搭建环境过程遇到的最让我头疼的问题，直接原因就是我对进度条的不信任。<br>当你进行Android开发时，需要将项目打包成apk，这时就需要Android JDK &amp; NDK工具包，这时你有两种选择<br>①、自行下载SDK manager和NDK；（这条路让我感受到世界的恶意）<br>②、使用Unity Hub直接下载<strong>Unity 2019.3.0f6 (64-bit)</strong>，这样可以直接添加各种模块；</p><h5 id="2、方法①"><a href="#2、方法①" class="headerlink" title="2、方法①"></a>2、方法①</h5><p>（想要较好解决方法的同学可以直接看方法②）<br>SDK和NDK下载可以直接从官网下载，建议使用Goole浏览器的迅雷插件，这样可以快一点。<br>SDK：<a href="https://www.androiddevtools.cn/" target="_blank" rel="noopener">https://www.androiddevtools.cn/</a><br>NDK：<a href="https://developer.android.google.cn/ndk/downloads/" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/downloads/</a><br>下载SDK Tools后打开SDK manager再下载需要的对应工具，尽量下载最新版本。<br>下载NDK之后，就会遇到一个第一个问题：<strong>NDK版本不正确</strong><br><img src="https://img-blog.csdnimg.cn/2020020411555648.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTc1OTI2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>令人震惊的是，Unity要求的NDK版本的小版本号怎么这么长！（黑人问号脸）还能把所有小版本都发布吗！这就导致我花费了大量时间在下载NDK，大版本错完小版本错，小版本错完之后还有错。</p><h5 id="3、方法②"><a href="#3、方法②" class="headerlink" title="3、方法②"></a>3、方法②</h5><p>对比之下，方法②就非常好。下载了Unity Hub之后，添加Android Build Support以及其分目录的模块后，直接下载<strong>Unity 2019.3.0f6 (64-bit)</strong>或者是<strong>Unity 2019.2.20f1 (64-bit)</strong>。下载的过程比较漫长，需要耐心等待，但是面包总会有的。下载到五分之四的时候，进度条就会卡住，而由于我对进度条的不信任，我就直接取消下载转到方法一。。。<br>所以使用这个方法你只要相信进度条即可。</p><h4 id="三、Mininum-API-Level"><a href="#三、Mininum-API-Level" class="headerlink" title="三、Mininum API Level"></a>三、Mininum API Level</h4><p>配置环境的过程，有一个步骤时设置Mininum API Level，而我想的是设置的小一些，一定不会有问题，但事实不是如此。当我将其设置为最小的API Level 19：<br><img src="https://img-blog.csdnimg.cn/20200204121749589.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTc1OTI2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在编译运行的时候，会出现报错：<br><img src="https://img-blog.csdnimg.cn/20200204121842202.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTc1OTI2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这时需要将Mininum API Level设置的大一些，比如<strong>我设置的是API Level 24</strong>，就可以成功编译。</p><h4 id="四、Building-Gradle-Project"><a href="#四、Building-Gradle-Project" class="headerlink" title="四、Building Gradle Project"></a>四、Building Gradle Project</h4><p>最终编译的时候，进度条再一次卡住/(ㄒoㄒ)/~~，这时编译进行到<strong>Building Gradle Project</strong>，Unity会直接卡死。</p><blockquote><p>Gradle是一个基于JVM的构建工具，是一款通用灵活的构建工具，支持maven， Ivy仓库，支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml配置文件，基于Groovy，build脚本使用Groovy编写。——百度百科</p></blockquote><p>而编译卡在这里的原因由于本地并没有Gradle，所以编译时需要下载，而外网资源下载速度我不用再提，<strong>据网友信息，他编译数小时后成功了！</strong> 真是很短的时间呢！<br>但我采取了其他的方法：<strong>预先下载Gradle</strong>。<br>我下载的是gradle-5.4.1，之后在Edit-&gt;Preferences中将下载内容的地址输入到Gradle中。<img src="https://img-blog.csdnimg.cn/20200204123416425.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTc1OTI2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>辛苦一整天，遇到诸多艰难，所幸克服，没有放弃，坚持走下去咯！</strong></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-102 层次遍历</title>
      <link href="/2020/02/01/LeetCode-102/"/>
      <url>/2020/02/01/LeetCode-102/</url>
      
        <content type="html"><![CDATA[<h5 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h5><p>这道题使用的是二叉树的广度优先遍历，也就是层次遍历。与单纯的层次遍历不同的地方在于，这个问题<strong>要求返回的遍历结果是一个二维数组</strong>，一行代表树的一层。但是总的思路还是和层次遍历没有区别。<br>为了知道二叉树中<strong>每一个节点位于书的哪一层的问题</strong>，<strong>需要标识每一个节点所在的层数</strong>，并根据层次遍历时的节点，对其子节点进行标识。在这里我想到的方法有两种：第一种是建一个<strong>队列</strong>保存节点的层数，与层次遍历的队列保持一一对应；第二种是建一个<strong>哈希表</strong>，来实现每一个节点和其层数之间的对应关系。这里的标识方法甚至都可以使用线性表，但是考虑到查找的效率太低，故不使用线性表。</p><h5 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qDepth;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tem;</span><br><span class="line">        q.push(root);</span><br><span class="line">        qDepth.push(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nowDepth = <span class="number">1</span>;  <span class="comment">// 标记现在已经遍历到哪一层</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty())  <span class="comment">// 标准的层次遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> depth = qDepth.front();</span><br><span class="line">            qDepth.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">                qDepth.push(depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">                qDepth.push(depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (depth == nowDepth)</span><br><span class="line">            &#123;</span><br><span class="line">                tem.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// 每当到达新的一层将上一层的节点压入ans数组中</span></span><br><span class="line">            &#123;</span><br><span class="line">                nowDepth++;</span><br><span class="line">                ans.push_back(tem);</span><br><span class="line">                tem.clear();</span><br><span class="line">                tem.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(tem);  <span class="comment">// 注意最后还需要再将再压一次ans</span></span><br><span class="line">         <span class="comment">// 假设层数为m，当到达m+1层的时候，会直接跳出循环</span></span><br><span class="line">         <span class="comment">// 所以没有执行m层的压ans操作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-99 二叉搜索树多往中序遍历去想</title>
      <link href="/2020/01/31/LeetCode-99/"/>
      <url>/2020/01/31/LeetCode-99/</url>
      
        <content type="html"><![CDATA[<h5 id="一、错误思路"><a href="#一、错误思路" class="headerlink" title="一、错误思路"></a>一、错误思路</h5><p>最开始的思路，是进行<strong>深搜</strong>，向左树走的时候节点 N 压入biggers栈中，向右树走的时候节点压入smallers栈中，当子树深搜结束后，再将栈顶的节点，也就是节点 N 弹出。然后每到一个节点 P，就判断该节点与biggers和smallers栈中所有元素之间的关系，如果该节点的值大于等于biggers数组中的某一个节点 Q1，或者是该节点的值小于等于smallers数组中的某一个节点 Q2，就说明 P 和 Q1/Q2 就是被交换的节点。<br>但是这个方法的问题是，只考虑了<strong>任意节点与其一颗子树节点之间的关系，没有考虑两颗子树之间的关系</strong>，导致如果交换的节点是在两颗子树上，就无法找到交换的节点。</p><h5 id="二、错误代码"><a href="#二、错误代码" class="headerlink" title="二、错误代码"></a>二、错误代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误代码！！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; biggers , smallers;</span><br><span class="line">        helper(root , biggers , smallers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值作为一种标记来表示是否已经找到被交换的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode *node , <span class="built_in">vector</span>&lt;TreeNode*&gt; biggers , <span class="built_in">vector</span>&lt;TreeNode*&gt; smallers)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> bigger:biggers)  <span class="comment">// 检测node的值是否小于biggers中的所有元素的值</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;val &gt;= bigger-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(node-&gt;val , bigger-&gt;val);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> smaller:smallers)  <span class="comment">// 检测node的值是否大于smallers中的所有元素的值</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;val &lt;= smaller-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(node-&gt;val , smaller-&gt;val);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向左子树移动时，node是作为比左子树大的节点，故放入biggers中</span></span><br><span class="line">            biggers.push_back(node);</span><br><span class="line">            <span class="keyword">bool</span> flag = helper(node-&gt;left , biggers , smallers);</span><br><span class="line">            <span class="keyword">if</span> (flag)  <span class="comment">// 搜索到想要找的问题就直接返回</span></span><br><span class="line">                <span class="keyword">return</span> flag;</span><br><span class="line">            biggers.pop_back();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向右子树移动时，node是作为比右子树大的节点，故放入smallers中</span></span><br><span class="line">            smallers.push_back(node);</span><br><span class="line">            flag = helper(node-&gt;right , biggers , smallers);</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            smallers.pop_back();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 当前node并不是被交换的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="三、正确思路"><a href="#三、正确思路" class="headerlink" title="三、正确思路"></a>三、正确思路</h5><p>在处理二叉搜索树节点大小关系的问题时，都应该想到用中序遍历来处理问题。<br><strong>一个正确的二叉搜索树，他的中序遍历应该是一个递增的数组</strong>，把握这一点，就能解决这个问题。<br>如果交换了两个节点，那么对应的中序遍历，就会出现两个位置有递减的情况。这样问题就变为：<strong>得到树中序遍历的结果，将两个递减位置的节点进行交换</strong>。<br>举个例子可能会更加直观：<img src="https://img-blog.csdnimg.cn/20200131153305525.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTc1OTI2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这时一个正确的二叉搜索树，他的中序遍历是：1 2 3 4 5 6<br>交换节点之后，变为：<img src="https://img-blog.csdnimg.cn/20200131153510926.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTc1OTI2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这是可以看到中序遍历变为：6 2 3 4 5 1，根据思路叙述，交换的位置应该是6 2和5 1，看到交换的节点是前一个递减对的前一个节点和后一个递减对的后一个节点。<br>还需要注意的一点是，有可能只有一个递减对，那么就是直接交换递减对的两个节点。</p><h5 id="四、正确代码"><a href="#四、正确代码" class="headerlink" title="四、正确代码"></a>四、正确代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; midL;</span><br><span class="line">        helper(root , midL);</span><br><span class="line">        TreeNode *n1 , *n2;</span><br><span class="line">        n1 = n2 = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; midL.size()<span class="number">-1</span> ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n1 == <span class="literal">NULL</span> &amp;&amp; midL[i]-&gt;val &gt; midL[i+<span class="number">1</span>]-&gt;val)</span><br><span class="line">                n1 = midL[i];</span><br><span class="line">            <span class="keyword">if</span> (n1 != <span class="literal">NULL</span> &amp;&amp; midL[i]-&gt;val &gt; midL[i+<span class="number">1</span>]-&gt;val)</span><br><span class="line">                n2 = midL[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        swap(n1-&gt;val , n2-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode *node , <span class="built_in">vector</span>&lt;TreeNode*&gt; &amp;midL)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            helper(node-&gt;left , midL);</span><br><span class="line">            midL.push_back(node);</span><br><span class="line">            helper(node-&gt;right , midL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-100 留心小问题即可</title>
      <link href="/2020/01/31/LeetCode-100/"/>
      <url>/2020/01/31/LeetCode-100/</url>
      
        <content type="html"><![CDATA[<h4 id="一、问题及注意点"><a href="#一、问题及注意点" class="headerlink" title="一、问题及注意点"></a>一、问题及注意点</h4><p>这道题主要是考察对节点为空的情况时的考虑，想要访问某一个节点的内容，第一个需要解决的问题就是<strong>排除节点空的情况</strong>。<br>剩下的就是编写类似深搜的代码。</p><h4 id="二、具体代码"><a href="#二、具体代码" class="headerlink" title="二、具体代码"></a>二、具体代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(p , q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* p , TreeNode* q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((p == <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>) || (p != <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>))  <span class="comment">// 判断只有一者空的情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>)  <span class="comment">// 判断出现节点都空的情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val != q-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">bool</span> flag1 = helper(p-&gt;left , q-&gt;left);</span><br><span class="line">            <span class="keyword">bool</span> flag2 = helper(p-&gt;right , q-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> flag1*flag2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：o(n)（n为树节点个数）</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-4 超多方法;找到多个变量之间的关系来减少变量个数</title>
      <link href="/2020/01/29/LeetCode-4/"/>
      <url>/2020/01/29/LeetCode-4/</url>
      
        <content type="html"><![CDATA[<h4 id="一、直接顺序遍历到所求位置"><a href="#一、直接顺序遍历到所求位置" class="headerlink" title="一、直接顺序遍历到所求位置"></a>一、直接顺序遍历到所求位置</h4><p>所谓求中位数，<strong>实际上就是求两个数组排序后的第 tar 个元素</strong>（当两数组长度之和m+n为奇数时，tar1 = (m+n)/2，当为偶数时，tar1 = (m+n)/2，tar2 = tar1+1）。<br>可以想到<strong>归并排序时归并的操作</strong>，cnt1和cnt2分别指向两个数组当前遍历到的位置，选择两数组中较小的元素，将其对应遍历指针cnt加一。<br>在这里需要注意的是，有可能出现</p><blockquote><p>nums1 = {1,2}<br>nums2 = {3,4,5,6,7,8}</p></blockquote><p>这样的情况，这时就需要对下边进行判断，<strong>当一个遍历指针已经越界的时候，就直接将另一个遍历指针加一</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> tar1 = (len1+len2)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> tar2 = tar1+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt1 , cnt2;</span><br><span class="line">        cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans1 , ans2;</span><br><span class="line">        ans1 = ans2 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tar2 ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt2 &gt;= len2 || (cnt1 &lt; len1 &amp;&amp; nums1[cnt1] &lt; nums2[cnt2]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == tar1)</span><br><span class="line">                    ans1 = nums1[cnt1];</span><br><span class="line">                <span class="keyword">if</span> (i == tar2)</span><br><span class="line">                    ans2 = nums1[cnt1];</span><br><span class="line">                cnt1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == tar1)</span><br><span class="line">                    ans1 = nums2[cnt2];</span><br><span class="line">                <span class="keyword">if</span> (i == tar2)</span><br><span class="line">                    ans2 = nums2[cnt2];</span><br><span class="line">                cnt2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((len1+len2) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (ans1+ans2)/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ans2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：o(m+n)</strong><br>没有达到题目的要求，还需要再进行优化</p><h4 id="二、查找第tar个数"><a href="#二、查找第tar个数" class="headerlink" title="二、查找第tar个数"></a>二、查找第tar个数</h4><p>第一种方法使用顺序遍历的方式查找第tar个数字，时间复杂度必然无法达到log(m+n)，想要优化，第一个想到的就是用二分查找的方式加速查找，这时需要思考的问题就是： <strong>用什么作为二分的标准？</strong><br>一种方法是将查找第tar数字进行二分，<strong>每一次确定 tar/2 个一定在中位数之前的数字</strong>；<br>另一种方法是将下标作为二分的标准，找到两个数组分块位置之间的关系，<strong>对一个数组进行标准的二分</strong>；</p><p>第一种方法是通过一定的判断，将数组舍去一部分，假设两个数组为</p><blockquote><p>nums1 = {1,3,5,6};<br>nums2 = {2,4,9,10,12};</p></blockquote><p>可知：tar这时是等于4，则 tar/2 等于2，这时比较两个数组中第二个元素，由于 3&lt;4 所以可以确定<strong>nums1中的 {1,3}一定是小于最后的中位数。也就是第tar数</strong>，新数组变为</p><blockquote><p>nums1 = {5,6};<br>nums2 = {2,4,9,10,12};</p></blockquote><p>我们的tar也就变成 4-2=2 然后进行新一轮的处理。</p><p><strong>在代码中，用k来代替tar</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.size() , len2 = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> len = len1+len2;</span><br><span class="line">        <span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>)  <span class="comment">// 需要探查查两次</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ans1 = helper(nums1 , nums2 , len/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> ans2 = helper(nums1 , nums2 , len/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1.0</span>*ans1+ans2)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//只要探查一次</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = helper(nums1 , nums2 , len/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1 , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2 , <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums2[k<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums2.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums1[k<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums1[<span class="number">0</span>]&gt;nums2[<span class="number">0</span>]?nums2[<span class="number">0</span>]:nums1[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k_2 = k/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = k_2&gt;nums1.size()?nums1.size():k_2;</span><br><span class="line">        <span class="keyword">int</span> p2 = k_2&gt;nums2.size()?nums2.size():k_2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums1[p1<span class="number">-1</span>] &gt; nums2[p2<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(nums1 , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums2.begin()+p2,nums2.end()) , k-p2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums1.begin()+p1,nums1.end()) , nums2 , k-p1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：o(log(m+n))</strong>（在代码中实际是o(log(k))，因为k=(m+n)/2，故时间复杂度也就是o(log(m+n))）</p><h4 id="三、二分查找"><a href="#三、二分查找" class="headerlink" title="三、二分查找"></a>三、二分查找</h4><h5 id="1、心路历程"><a href="#1、心路历程" class="headerlink" title="1、心路历程"></a>1、心路历程</h5><p>当我看到题目中要求的复杂度有 log 的时候，第一个想到的就是二分查找，由于二分查找是作用于一个数组，所以我的想法就是分别有left1、right1、left2、right2来表示两个数组的边界。同时，注意到中位数的定义，决定了我们最后要找的数字，<strong>两个数组的分界线两边的元素个数应该是相同的（在长度和为奇数的情况下）</strong>，这样也就约束了二分查找时的<strong>递归条件</strong>。而中位数的定义决定了，<strong>位于中位数左边的元素一定是小于位于它右边的元素</strong>，这样就约束了<strong>递归出口条件</strong>。<br>但是由于这个方法引入了两个分界线，虽然知道它们之间的关系，但是在编写代码时还是容易产生混乱，然后，我最后没有把这个思路编成代码（手动狗头），<em>望有缘人能完成它</em>。</p><h5 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h5><p>根据<em>两个数组的分界线两边的元素个数应该是相同的（在长度和为奇数的情况下）</em>，假设分界线为p1和p2，需要注意的是，上面思路中，是将下标作为分界线，而这里是<strong>将两个下标之间的位置假象为分界线</strong>，故</p><blockquote><p>当len1+len2为偶数时<br>∵ p1 + p2 = len1-p1 + len2-p2<br>∴ p2 = (len1+len2) / 2 - p1;<br>当len1+len2为奇数时<br>∵ p1 + p2 = len1-p1 + len2-p2 + 1<br>∴ p2 = (len1+len2 + 1) / 2 - p1; </p></blockquote><p><strong>注意：</strong><br>①、因为<strong>代码中下标都为整型</strong>，所以偶数情况等价于 p2= (len1 + len2 + 1) / 2 - p1<br>②、因为分界线一定是非负的，所以 p1 应该是长度较小数组的分界线（以 p1 作为二分查找的中点时）</p><p><strong><em>为了写题解方便，暂时不考虑边界条件（p1 != 0 , p1 != len1 , p2 != 0 , p2 != len2）</em></strong><br>根据<em>位于中位数左边的元素一定是小于位于它右边的元素</em>，由于同一个数组元素已经有序，需要判断的就是不同数组分界线处元素的大小关系。</p><blockquote><p>假设某一次迭代两数组分解情况如下<br>nums1 = { …… 4 | 5 …… }<br>nums2 = { …… 2 | 3 …… }<br>很容易就能发现，如果将这种分界情况作为答案，一定是不可行的：因为 4&lt;3 ，分界线左端元素不满足恒小于分界线端元素。这时为了得到合理的分界情况，就希望 nums1 的分界线向左移，nums2 的分界线会随之移动。<br>同时还有<br>②<br>nums1 = { …… 2 | 3 …… }<br>nums2 = { …… 4 | 5 …… }<br>这种情况，这时就希望 nums1 的分界线向右移动</p></blockquote><p>因为使用二分查找，所以分界线的移动都是通过<strong>端点的移动</strong>来进行：<br><strong>向左移，就将右端点赋值为 p1-1;<br>向右移，就将左端点赋值为 p1+1;</strong></p><p>大致思路完成后，就需要考虑端点的情况，通过示例，能知道需要处理那些边界条件，<strong>这些边界条件不仅在递归过程中，还会在最后的递归出口用到</strong>：</p><blockquote><p>比较两端元素时，分界线已经到端点位置<br>①<br>nums1 = { | …… }<br>nums2 = { …… | …… }<br>②<br>nums1 = { …… | …… }<br>nums2 = { | …… }<br>③<br>nums1 = { …… | }<br>nums2 = { …… | …… }<br>④<br>nums1 = { …… | …… }<br>nums2 = { …… | }</p></blockquote><h5 id="3、具体代码"><a href="#3、具体代码" class="headerlink" title="3、具体代码"></a>3、具体代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = nums2.size();</span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2)</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2 , nums1);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span> , right = len1;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p1 = (left+right+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> p2 = (len1+len2+<span class="number">1</span>)/<span class="number">2</span>-p1;</span><br><span class="line">            <span class="keyword">if</span> (p1 != <span class="number">0</span> &amp;&amp; p2 != len2 &amp;&amp; nums1[p1<span class="number">-1</span>] &gt; nums2[p2])  <span class="comment">// 还需要将查找区间向左移</span></span><br><span class="line">                right = p1<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p1 != len1 &amp;&amp; p2 != <span class="number">0</span> &amp;&amp; nums2[p2<span class="number">-1</span>] &gt; nums1[p1])</span><br><span class="line">                left = p1+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> maxLeft = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (p1 == <span class="number">0</span>) &#123; maxLeft = nums2[p2<span class="number">-1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p2 == <span class="number">0</span>) &#123; maxLeft = nums1[p1<span class="number">-1</span>]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; maxLeft = max(nums1[p1<span class="number">-1</span>], nums2[p2<span class="number">-1</span>]); &#125;</span><br><span class="line">                <span class="keyword">if</span> ( (len1 + len2) % <span class="number">2</span> == <span class="number">1</span> ) &#123; <span class="keyword">return</span> maxLeft; &#125; <span class="comment">// 奇数的话不需要考虑右半部分</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minRight = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (p1 == len1) &#123; minRight = nums2[p2]; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p2 == len2) &#123; minRight = nums1[p1]; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; minRight = min(nums2[p2], nums1[p1]); &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>; <span class="comment">//如果是偶数的话返回结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：o( log(min{m , n}) )</strong>（m，n为两数组长度）</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-97 指数型增长的暴力果然不可行</title>
      <link href="/2020/01/28/LeetCode-97/"/>
      <url>/2020/01/28/LeetCode-97/</url>
      
        <content type="html"><![CDATA[<h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>这个题要求判断两个字符串s1、s2，是否能通过某种方式，将他们的<strong>字符任意排列</strong>，从而组成字符串s3，也就是题目所说的s1、s2交错组成s3。</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><h5 id="1、暴力法"><a href="#1、暴力法" class="headerlink" title="1、暴力法"></a>1、暴力法</h5><p>首先想到的是简单的暴力法，对问题进行递归。按字符顺序递归。假设某一层递归s1，s2，s3分别到达下标p1，p2，p3，问题变成分别尝试s3[p3]取s1[p1]和s2[p2]（取的规则是字符要求相同）并继续递归。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.size() + s2.size() != s3.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(s1 , <span class="number">0</span> , s2 , <span class="number">0</span> , s3 , <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s1 , <span class="keyword">int</span> p1 , <span class="built_in">string</span> s2 , <span class="keyword">int</span> p2 , <span class="built_in">string</span> s3 , <span class="keyword">int</span> p3)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p3 == s3.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag1 , flag2;</span><br><span class="line">        flag1 = flag2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用s1[p1]作为s3[p3]</span></span><br><span class="line">        <span class="keyword">if</span> (p1 &lt; s1.size() &amp;&amp; s1[p1] == s3[p3])</span><br><span class="line">            flag1 = helper(s1 , p1+<span class="number">1</span> , s2 , p2 , s3 , p3+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 用s2[p2]作为s3[p3]</span></span><br><span class="line">        <span class="keyword">if</span> (p2 &lt; s2.size() &amp;&amp; s2[p2] == s3[p3])</span><br><span class="line">            flag2 = helper(s1 , p1 , s2 , p2+<span class="number">1</span> , s3 , p3+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flag1 == <span class="literal">true</span> || flag2 == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<strong>o(2^m * (m-n))</strong>（m为s1、s2中长度较长者）<br>注意：由于这个方法是指数爆炸增长的复杂度，<strong>cpp代码会超时</strong>。</p><h5 id="2、动态规划"><a href="#2、动态规划" class="headerlink" title="2、动态规划"></a>2、动态规划</h5><p>使用二维布尔数组dp用于表示两数组某一位的交错情况：<strong>dp[i][j]==1表示s1的前i位和s2的前j位可以交错组成s3的前i+j位</strong>。知道dp数组表示的含义，问题也就迎刃而解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.size() , len2 = s2.size() , len3 = s3.size();</span><br><span class="line">        <span class="keyword">if</span> (len1+len2 != len3)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(len1+<span class="number">1</span> , <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len2+<span class="number">1</span> , <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len2 ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[<span class="number">0</span>][i<span class="number">-1</span>] == <span class="literal">true</span> &amp;&amp; s2[i<span class="number">-1</span>] == s3[i<span class="number">-1</span>])</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len1 ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i<span class="number">-1</span>][<span class="number">0</span>] == <span class="literal">true</span> &amp;&amp; s1[i<span class="number">-1</span>] == s3[i<span class="number">-1</span>])</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len1 ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= len2 ; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((dp[i<span class="number">-1</span>][j] == <span class="literal">true</span> &amp;&amp; s1[i<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]) || (dp[i][j<span class="number">-1</span>] == <span class="literal">true</span> &amp;&amp; s2[j<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]))</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i = 0 ; i &lt; len1 ; ++i)  // 显示dp数组</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     copy(dp[i].begin() , dp[i].end() , ostream_iterator&lt;bool&gt;(cout , " "));</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<strong>o(m*n)</strong>（m，n为s1，s2数组的长度）</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-4</title>
      <link href="/2020/01/27/Django-4/"/>
      <url>/2020/01/27/Django-4/</url>
      
        <content type="html"><![CDATA[<h4 id="•-编写一个用于问题显示的表单（form）"><a href="#•-编写一个用于问题显示的表单（form）" class="headerlink" title="• 编写一个用于问题显示的表单（form）"></a>• 编写一个用于问题显示的表单（form）</h4><p>form是HTML的一个元素，修改<em>polls/detail.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% if error_message %&#125;<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; error_message &#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"&#123;% url 'polls:vote' question.id %&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">&#123;% csrf_token %&#125;</span><br><span class="line">&#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"choice"</span> <span class="attr">id</span>=<span class="string">"choice&#123;&#123; forloop.counter &#125;&#125;"</span> <span class="attr">value</span>=<span class="string">"&#123;&#123; choice.id &#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"choice&#123;&#123; forloop.counter &#125;&#125;"</span>&gt;</span>&#123;&#123; choice.choice_text &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Vote"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这部分涉及HTML相关内容，不再赘述</p><h4 id="•-添加投票界面的相关内容"><a href="#•-添加投票界面的相关内容" class="headerlink" title="• 添加投票界面的相关内容"></a>• 添加投票界面的相关内容</h4><p>添加关于<em>polls/views.py</em>的vote()函数的相关实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse, HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Choice, Question</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        selected_choice = question.choice_set.get(pk=request.POST[<span class="string">'choice'</span>])</span><br><span class="line">    <span class="keyword">except</span> (KeyError, Choice.DoesNotExist):</span><br><span class="line">        <span class="comment"># Redisplay the question voting form.</span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">'polls/detail.html'</span>, &#123;</span><br><span class="line">            <span class="string">'question'</span>: question,</span><br><span class="line">            <span class="string">'error_message'</span>: <span class="string">"You didn't select a choice."</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        selected_choice.votes += <span class="number">1</span></span><br><span class="line">        selected_choice.save()</span><br><span class="line">        <span class="comment"># Always return an HttpResponseRedirect after successfully dealing</span></span><br><span class="line">        <span class="comment"># with POST data. This prevents data from being posted twice if a</span></span><br><span class="line">        <span class="comment"># user hits the Back button.</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">'polls:results'</span>, args=(question.id,)))</span><br></pre></td></tr></table></figure><p>相关内容说明：<br>1、<strong>request.POST</strong>是类似于字典的对象，可让您通过键名访问提交的数据。在这种情况下， <strong>request.POST[‘choice’]</strong>以字符串形式返回所选选项的<strong>ID</strong>。<strong>request.POST</strong>值始终是字符串。</p><p>请注意，<strong>Django</strong>还提供<strong>request.GET</strong>了以相同方式访问<strong>GET</strong>数据的方法-但我们<strong>request.POST</strong>在代码中明确使用，以确保仅通过<strong>POST</strong>调用更改数据。</p><p>2、如果没有提供<strong>POST</strong>数据，那么就会产生<strong>KEYERROR</strong>异常，重新显示问题表单。</p><p>3、在此示例reverse()中，我们在<strong>HttpResponseRedirect</strong>构造函数中使用该函数 。此功能有助于避免在视图功能中对URL进行硬编码。它提供了我们想要将控制权传递给的视图的名称，以及指向该视图的URL模式的可变部分。在这种情况下，使用我们在教程3中设置的<strong>URLconf</strong> ，此<strong>reverse()</strong>调用将返回一个字符串，例如’/polls/3/results/‘，其中3是的值<strong>question.id</strong>。然后，此重定向的URL将调用<strong>‘results’</strong>视图以显示最后一页。</p><h4 id="•-投票结果页面相关内容"><a href="#•-投票结果页面相关内容" class="headerlink" title="• 投票结果页面相关内容"></a>• 投票结果页面相关内容</h4><p>进行投票之后，vote()视图将重定向到该问题的结果页面，故编写视图在<em>views.py</em>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">results</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'polls/results.html'</span>, &#123;<span class="string">'question'</span>: question&#125;)</span><br></pre></td></tr></table></figure><p>同时创建<em>polls/results.html</em>模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; choice.choice_text &#125;&#125; -- &#123;&#123; choice.votes &#125;&#125; vote&#123;&#123; choice.votes|pluralize &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'polls:detail' question.id %&#125;"</span>&gt;</span>Vote again?<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在可以运行服务器，来看一看问题页面、投票页面和投票结果显示页面，</p><h4 id="•-使用通用视图来减少代码量"><a href="#•-使用通用视图来减少代码量" class="headerlink" title="• 使用通用视图来减少代码量"></a>• 使用通用视图来减少代码量</h4><p>在 <strong>detail()</strong> 和 <strong>results()</strong> 的视图函数是非常短并且相似，所以重复的代码是冗余的。<br>这些视图代表了基本Web开发的一种常见情况：根据URL中传递的参数从数据库获取数据，加载模板并返回渲染的模板。因为这很常见，所以Django提供了一个捷径，称为“<strong>通用视图</strong>”系统。<br>为了转换为通用视图系统，需要经过一些步骤：<br>    1. 转换URLconf。<br>    2. 删除一些旧的不需要的视图。<br>    3. 根据Django的通用视图介绍新视图。 </p><p><strong>修改URL配置</strong><br>首先对<em>polls/urls.py</em>的URLconf进行修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">app_name = <span class="string">'polls'</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>, views.IndexView.as_view(), name=<span class="string">'index'</span>),</span><br><span class="line">    path(<span class="string">'&lt;int:pk&gt;/'</span>, views.DetailView.as_view(), name=<span class="string">'detail'</span>),</span><br><span class="line">    path(<span class="string">'&lt;int:pk&gt;/results/'</span>, views.ResultsView.as_view(), name=<span class="string">'results'</span>),</span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/vote/'</span>, views.vote, name=<span class="string">'vote'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>修改的是将更改<question_id>为<pk>。</p><p><strong>修改视图</strong><br>将<em>polls/views.py</em>修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> generic</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Choice, Question</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexView</span><span class="params">(generic.ListView)</span>:</span></span><br><span class="line">    template_name = <span class="string">'polls/index.html'</span></span><br><span class="line">    context_object_name = <span class="string">'latest_question_list'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return the last five published questions."""</span></span><br><span class="line">        <span class="keyword">return</span> Question.objects.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailView</span><span class="params">(generic.DetailView)</span>:</span></span><br><span class="line">    model = Question</span><br><span class="line">    template_name = <span class="string">'polls/detail.html'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultsView</span><span class="params">(generic.DetailView)</span>:</span></span><br><span class="line">    model = Question</span><br><span class="line">    template_name = <span class="string">'polls/results.html'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    ... <span class="comment"># same as above, no changes needed.</span></span><br></pre></td></tr></table></figure><p>在这里使用了两个通用视图<strong>ListView</strong>和<strong>DetailView</strong>，分别抽象了“显示对象列表”和“显示特定类型的对象的详细信息页面”的概念。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-95 合理利用返回值</title>
      <link href="/2020/01/27/LeetCode-95/"/>
      <url>/2020/01/27/LeetCode-95/</url>
      
        <content type="html"><![CDATA[<h4 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h4><p>最开始做这道题的时候，我把题目理解成了值为1到n的二叉搜索树有几颗，而不是这些树分别是什么。但这两个问题的关联度较大，问题的关键在于想到：<strong>当我们确定了根节点的值是什么，那么他左右子树的取值范围就已经很明确了。</strong><br>若根节点的取值是在[left , right]中的一个值k，由二叉搜索树的定义可知，左子树的值在[left , k-1]，右子树的值在[k+1 , right]。假设我们已经求出左右子树（<strong>注意求出的应该是一组树</strong>，而不是一个树），所以我们用两重循环遍历所有左右子树搭配的可能，也就求出根节点值为k、取值范围在[left , right]间的所有树，<strong>遍历即可求出值为[left , right]的所有树</strong>。<br>这样问题就形成了递归，自然也就解决。</p><h4 id="二、注意："><a href="#二、注意：" class="headerlink" title="二、注意："></a>二、注意：</h4><p>在最开始的时候，我将helper()（代码中的函数）的返回值设置成void，虽然想到根节点确定，左右子树范围确定这一点，但是一直不知道该怎么转换成代码。（当时冒出的想法是，一棵树如果已经完整（有n个节点），那么就将他push_back到结果中，但是没有实现）</p><h4 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; generateTrees(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; ans;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span> , n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; helper(<span class="keyword">int</span> left , <span class="keyword">int</span> right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left ; i &lt;= right ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; leftTrees = helper(left , i<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rightTrees = helper(i+<span class="number">1</span> , right);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> leftTree : leftTrees)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> rightTree : rightTrees)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root-&gt;left = leftTree;</span><br><span class="line">                    root-&gt;right = rightTree;</span><br><span class="line">                    ans.push_back(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-92 哨位节点的重要性</title>
      <link href="/2020/01/26/LeetCode-92/"/>
      <url>/2020/01/26/LeetCode-92/</url>
      
        <content type="html"><![CDATA[<h4 id="一、解题思路"><a href="#一、解题思路" class="headerlink" title="一、解题思路"></a>一、解题思路</h4><p>这个问题其实等同于反转链表，只是将问题变成了子链表。<br>在反转链表的时候，是<strong>引入了prev，scan，next三个指针</strong>，分别表示当前节点的前一个节点，当前节点，当前节点的后一个节点。<strong>遍历的过程只需要将scan-&gt;next赋值为prev</strong>。最后处理头节点即可。<br>回到这个问题，其实就是在反转m至n号节点，将最后处理头节点的过程变成处理这一段链表两端节点。</p><h4 id="二、具体流程"><a href="#二、具体流程" class="headerlink" title="二、具体流程"></a>二、具体流程</h4><p>首先需要先找到第m个节点，然后反转m至n号节点，然后将m号节点的next指针指向第n+1号节点，再将m-1号节点的next指针指向m-1号节点。</p><h4 id="三、重点问题"><a href="#三、重点问题" class="headerlink" title="三、重点问题"></a>三、重点问题</h4><p>在处理的过程中会有这么几个问题：<br>eg：1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>1、考虑m=1，n=2的情况，这种情况导致<strong>m-1号节点为空</strong>，如果直接对给定链表操作，会导致代码中不断地在考虑特殊情况，所以我们添加哨位节点，这样代码实现的难度直线下降。<br>2、考虑m=3，n=4的情况，这种情况会在next进行迭代的时候出现<strong>空指针访问的情况</strong>。所以在迭代的时候需要充分考虑空指针。</p><h4 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *prev , *scan , *next;</span><br><span class="line">        ListNode *tem = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        tem-&gt;next = head;</span><br><span class="line">        head = tem;  <span class="comment">//添加一个哨位节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历找第m个节点</span></span><br><span class="line">        scan = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; m ; ++i)</span><br><span class="line">            scan = scan-&gt;next;</span><br><span class="line">        ListNode *m_1Node = scan;</span><br><span class="line">        ListNode *mNode = scan-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转m至n号节点</span></span><br><span class="line">        prev = mNode;</span><br><span class="line">        scan = mNode-&gt;next;</span><br><span class="line">        next = mNode-&gt;next==<span class="literal">NULL</span>?<span class="literal">NULL</span>:mNode-&gt;next-&gt;next;  <span class="comment">//考虑翻转最后一个节点的可能</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m ; i &lt; n ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scan-&gt;next = prev;</span><br><span class="line"></span><br><span class="line">            prev = scan;</span><br><span class="line">            scan = next;</span><br><span class="line">            next = next==<span class="literal">NULL</span>?<span class="literal">NULL</span>:next-&gt;next;  <span class="comment">// 考虑n号节点之后再没有节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接两端</span></span><br><span class="line">        m_1Node-&gt;next = prev;</span><br><span class="line">        mNode-&gt;next = scan;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-3 官方题解的优化滑动窗口</title>
      <link href="/2020/01/26/LeetCode-3/"/>
      <url>/2020/01/26/LeetCode-3/</url>
      
        <content type="html"><![CDATA[<h4 id="一、子问题"><a href="#一、子问题" class="headerlink" title="一、子问题"></a>一、子问题</h4><p>解决这道题之前，可以先思考一个重要的问题，就是<strong>给定的一段字符串，如何判断它是否有重复的字符。</strong><br>法一、容易想到的是遍历每一个字符，判断在它之后是否出现相同字符，时间复杂度o(n^2)。<br>法二、同LeetCode-1，<strong>用哈希表进行搜索加速</strong>：维护一个数组作为哈希表，初始化为0。遍历字符串，并将每个字符对应位置（eg：‘f’-‘a’ = 5，‘f’对应下标为5）置为1，如果该位置已经置1，那么就说明出现重复字符。这个方法只需要一次遍历，时间复杂度o(n)。  </p><h4 id="二、问题思路"><a href="#二、问题思路" class="headerlink" title="二、问题思路"></a>二、问题思路</h4><p>解决子问题之后，我们知道可以用哈希表来进行加速。维护一个数组作为哈希表，<strong>初始化内容为-1</strong>（不初始化为0是因为之后哈希表中保存的会是字符下标），遍历整个字符串，将每一个字符对应位置保存当前字符的下标。遍历至下标n处，如果该位置对应哈希表内容为m（m != -1），则说明 <strong>[m,n) 是无重复字符子串，[m,n]会出现重复字符</strong>。计算当前无重复子串长度后，保存较大者。之后重置哈希表，再进行之后字符串的遍历。<br>这个方法也就是官方题解中的优化滑动窗口。  </p><h4 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> from , to;  <span class="comment">//当前最长子串起止下标</span></span><br><span class="line">    from = to = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hash[<span class="number">256</span>];  <span class="comment">//每个字符的键值对</span></span><br><span class="line">    <span class="built_in">memset</span>(hash , <span class="number">-1</span> , <span class="keyword">sizeof</span>(hash));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (s[to] != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash[s[to]] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[s[to]] = to;</span><br><span class="line">            to++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (hash[s[to]] &lt; from)  <span class="comment">//重复的不是当前最长子串</span></span><br><span class="line">        &#123;</span><br><span class="line">            hash[s[to]] = to;</span><br><span class="line">            to++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//当前最长子串出现重复，更新from的值为重复字符（前面的那个）位置加1</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans &gt; (to - from) ? ans : (to - from);</span><br><span class="line">            from = hash[s[to]] + <span class="number">1</span>;</span><br><span class="line">            hash[s[to]] = to;</span><br><span class="line">            to++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans = ans &gt; (to - from) ? ans : (to - from);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-2 需要考虑周全的问题</title>
      <link href="/2020/01/23/LeetCode-2/"/>
      <url>/2020/01/23/LeetCode-2/</url>
      
        <content type="html"><![CDATA[<h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>这个问题主要考察的是链表的操作和出现特殊情况的处理。<br>1、当两个链表一样长的时候，问题比较好处理，直接挨个相加即可；<br>2、当两个链表不一样的时候，就需要对遍历节点进行判断，不能出现再访问属性val的语句；<br>3、由于一条链有可能为空这种极端情况，所以不能简单的采用原地算法；<br>4、问题有一个小坑，就是有可能最后还有一位进位，对这个情况要考虑在内；<br>5、可以通过添加一个哑节点来减少代码；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode *scan1 = l1;</span><br><span class="line">        ListNode *scan2 = l2;</span><br><span class="line">        ListNode *head = new ListNode(<span class="number">0</span>);  //这是哑节点</span><br><span class="line">        ListNode *scan = head;</span><br><span class="line">        int flag = <span class="number">0</span>;  //标记进位</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (scan1 == NULL &amp;&amp; scan2 == NULL)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            int n1 = scan1!=NULL?scan1-&gt;val:0;</span><br><span class="line">            int n2 = scan2!=NULL?scan2-&gt;val:0;</span><br><span class="line">            scan-&gt;next = new ListNode((n1+n2+flag)%10);</span><br><span class="line">            flag = (n1+n2+flag)/<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (scan1 != NULL)</span><br><span class="line">                scan1 = scan1-&gt;next; </span><br><span class="line">            <span class="keyword">if</span> (scan2 != NULL)</span><br><span class="line">                scan2 = scan2-&gt;next;</span><br><span class="line">            scan = scan-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)  //如果最后还有进位</span><br><span class="line">            scan-&gt;next = new ListNode(1);</span><br><span class="line"></span><br><span class="line">        return head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(MAX{m,n})<br>空间复杂度：O(MAX{m,n})</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-1 利用哈希表进行查找加速</title>
      <link href="/2020/01/23/LeetCode-1/"/>
      <url>/2020/01/23/LeetCode-1/</url>
      
        <content type="html"><![CDATA[<p>问题可以转换为，已有一个ele（为数组中的任意元素），需要在数组中寻找另一个元素等于target-ele</p><h3 id="1、暴力遍历法"><a href="#1、暴力遍历法" class="headerlink" title="1、暴力遍历法"></a>1、暴力遍历法</h3><p>最直观的想法遍历每一个元素，再对该元素进行遍历，查看是否有满足条件的其他元素，使得他们两的加和为target。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span> ; i &lt; nums.size() ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int j = i+<span class="number">1</span> ; j &lt; nums.size() ; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i]+nums[j] == target)</span><br><span class="line">                    <span class="keyword">return</span> &#123;i , j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span> , <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="2、一遍hash"><a href="#2、一遍hash" class="headerlink" title="2、一遍hash"></a>2、一遍hash</h3><p>这个方法的想法主要是利用哈希表来进行查找加速。<br>遍历数组元素ele，将ele放入哈希表中（ele值作为外键，ele下标作为內键），同时判断target-ele是否在哈希表中：<br>如果在，那么搜索结束，直接返回；<br>如果不在，继续遍历，直到结尾；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        map&lt;int, int&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span> ; i &lt; nums.size() ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.count(target-nums[i]) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;m[target-nums[i]] , i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-3</title>
      <link href="/2020/01/22/Django-3/"/>
      <url>/2020/01/22/Django-3/</url>
      
        <content type="html"><![CDATA[<h2 id="•-视图"><a href="#•-视图" class="headerlink" title="• 视图"></a>• 视图</h2><p><strong>视图其实是视图函数的简称</strong>，视图是Django应用程序中网页的“类型”，通常具有特定功能并具有特定模板。<br>在Django中，网页和其他内容是通过视图传递的。每个视图均由Python函数（或方法（对于基于类的视图而言））表示。Django将通过检查所请求的URL（准确地说，是域名之后的URL部分）来选择视图。</p><h2 id="•-URL"><a href="#•-URL" class="headerlink" title="• URL"></a>• URL</h2><p><strong>URL即统一资源定位符</strong>，是每一个信息资源都有统一的且在网上唯一的地址。<br><strong>URLconfs即URL模式</strong>，是URL的一般形式Django提供了更加优雅的URL模式，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/newsarchive/<span class="tag">&lt;<span class="name">year</span>&gt;</span>/<span class="tag">&lt;<span class="name">month</span>&gt;</span>/</span><br></pre></td></tr></table></figure><h2 id="•-添加更多的视图"><a href="#•-添加更多的视图" class="headerlink" title="• 添加更多的视图"></a>• 添加更多的视图</h2><p>更改<em>views.py</em>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"You're looking at question %s."</span> % question_id)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">results</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    response = <span class="string">"You're looking at the results of question %s."</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(response % question_id)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"You're voting on question %s."</span> % question_id)</span><br></pre></td></tr></table></figure><p>并更改<em>polls.urls.py</em>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># ex: /polls/</span></span><br><span class="line">    path(<span class="string">''</span>, views.index, name=<span class="string">'index'</span>),</span><br><span class="line">    <span class="comment"># ex: /polls/5/</span></span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/'</span>, views.detail, name=<span class="string">'detail'</span>),</span><br><span class="line">    <span class="comment"># ex: /polls/5/results/</span></span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/results/'</span>, views.results, name=<span class="string">'results'</span>),</span><br><span class="line">    <span class="comment"># ex: /polls/5/vote/</span></span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/vote/'</span>, views.vote, name=<span class="string">'vote'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>根据输入的URL地址，<strong>通过遍历的方式寻找匹配的URL模式串</strong>，并调用相对应的视图函数，相应相对应的网页。<br>比如说，当有人从网站请求页面时，例如“ / polls / 34 /”，Django将加载<em>mysite.urls</em>的Python模块，因为该<em>ROOT_URLCONF</em>设置指向该模块 。它找到名为的变量urlpatterns并按顺序遍历模式。在找到匹配项之后’polls/‘，它将剥离匹配的文本（”polls/“），并将其余文本–发送 “34/“到’polls.urls’URLconf进行进一步处理。在那里匹配’<a href="int:question_id">int:question_id</a>/‘，从而导致对detail()视图的调用，如下所示：<br>detail(request=<HttpRequest object>, question_id=34)</p><h2 id="•-编写更强大的视图"><a href="#•-编写更强大的视图" class="headerlink" title="• 编写更强大的视图"></a>• 编写更强大的视图</h2><p>每个视图负责执行以下两项操作之一：<strong>返回HttpResponse包含所请求页面内容的对象，或者引发诸如之类的异常Http404</strong>。<br>HttpResponse需要自己对其进行填充，而HttpRequest是Django自己生成。<br>视图可以从数据库中读取记录，也可以使用Django等模板系统，也可以不使用第三方Python模板系统。它还可以使用所需的任何Python库生成PDF文件，输出XML，或即时创建ZIP文件。<br>在<em>view.py</em>添加代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    latest_question_list = Question.objects.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br><span class="line">    output = <span class="string">', '</span>.join([q.question_text <span class="keyword">for</span> q <span class="keyword">in</span> latest_question_list])</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(output)</span><br><span class="line">    <span class="comment"># Leave the rest of the views (detail, results, vote) unchanged</span></span><br></pre></td></tr></table></figure><h2 id="•-将模板与视图创建的硬编码分开"><a href="#•-将模板与视图创建的硬编码分开" class="headerlink" title="• 将模板与视图创建的硬编码分开"></a>• 将模板与视图创建的硬编码分开</h2><p>首先，在目录templates中创建一个polls目录。Django将在那里寻找模板。<br>您的项目TEMPLATES置描述了Django如何加载和呈现模板。默认设置文件配置一个DjangoTemplates 后端，其APP_DIRS选项设置为 True。按照惯例DjangoTemplates，在每个文件夹中都会寻找一个“模板”子目录INSTALLED_APPS。<br>在<em>polls/templates/polls/</em>添加一个模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if latest_question_list %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for question in latest_question_list %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/polls/&#123;&#123; question.id &#125;&#125;/"</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>No polls are available.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>现在运行服务器之后，可以子项/polls来加载一个“最新消息”列表。</p><h2 id="•-快捷方式"><a href="#•-快捷方式" class="headerlink" title="• 快捷方式"></a>• 快捷方式</h2><p>加载模板，填充上下文并使用渲染后的模板的结果返回对象HttpResponse是一种非常常见的用法。<br>同时，Django提供了一种快捷方式。重写index()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    latest_question_list = Question.objects.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br><span class="line">    context = &#123;<span class="string">'latest_question_list'</span>: latest_question_list&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'polls/index.html'</span>, context)</span><br></pre></td></tr></table></figure><p>该render()函数将<strong>请求对象作为其第一个参数，将模板名称作为其第二个参数，并将字典作为其可选的第三个参数</strong>。它返回使用HttpResponse 给定上下文呈现的给定模板的对象。</p><h2 id="•-404错误"><a href="#•-404错误" class="headerlink" title="• 404错误"></a>• 404错误</h2><p>在<em>views.py</em>中添加代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        question = Question.objects.get(pk=question_id)</span><br><span class="line">    <span class="keyword">except</span> Question.DoesNotExist:</span><br><span class="line">        <span class="keyword">raise</span> Http404(<span class="string">"Question does not exist"</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'polls/detail.html'</span>, &#123;<span class="string">'question'</span>: question&#125;)</span><br></pre></td></tr></table></figure><p>为了快速使示例正常工作，对应模板<em>polls/templates/polls/detail.html</em><br>中只添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; question &#125;&#125;</span><br></pre></td></tr></table></figure><p>现在运行服务器，可以看到更完整的polls网页  </p><h2 id="•-404的快捷方式"><a href="#•-404的快捷方式" class="headerlink" title="• 404的快捷方式"></a>• 404的快捷方式</h2><p>重写detail()函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'polls/detail.html'</span>, &#123;<span class="string">'question'</span>: question&#125;)</span><br></pre></td></tr></table></figure><h2 id="•-使用模板系统"><a href="#•-使用模板系统" class="headerlink" title="• 使用模板系统"></a>• 使用模板系统</h2><p><em>polls/detail.html</em>改写为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; choice.choice_text &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模板系统使用点查找语法来访问变量属性。在的示例中，首先Django在对象上进行字典查找。如果失败，它将尝试属性查找-在这种情况下可以工作。如果属性查找失败，它将尝试进行列表索引查找。</p><h2 id="•-命名空间URL名称"><a href="#•-命名空间URL名称" class="headerlink" title="• 命名空间URL名称"></a>• 命名空间URL名称</h2><p>在实际的Django项目中，可能有很多个应用程序，Django如何区分它们之间的URL名称呢？答案是将名称空间添加到URLconf中。<br>在polls/urls.py中添加app_name以设置为应用程序名称空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> pat</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">app_name = <span class="string">'polls'</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>, views.index, name=<span class="string">'index'</span>),</span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/'</span>, views.detail, name=<span class="string">'detail'</span>),</span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/results/'</span>, views.results, name=<span class="string">'results'</span>),</span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/vote/'</span>, views.vote, name=<span class="string">'vote'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样可以区分多个应用程序的URL名称。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-2</title>
      <link href="/2020/01/19/Django-2/"/>
      <url>/2020/01/19/Django-2/</url>
      
        <content type="html"><![CDATA[<h2 id="•-数据库设置"><a href="#•-数据库设置" class="headerlink" title="• 数据库设置"></a>• 数据库设置</h2><p>默认使用SQLite，相关的设置都在<em>setting.py</em>文件中进行。</p><p><em>setting,py</em>中还有其他设置：<br>INSTALLED_APPS文件顶部的设置。该名称包含在此Django实例中激活的所有Django应用程序的名称。其中包含一些默认的应用程序。不需要时可以在INSTALLED_APPS中删去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>该migrate命令将查看该INSTALLED_APPS设置，并根据<em>mysite/settings.py</em>文件中的数据库设置以及应用程序随附的数据库迁移来创建任何必要的数据库表。</p><h2 id="•-创建模型"><a href="#•-创建模型" class="headerlink" title="• 创建模型"></a>• 创建模型</h2><p>模型是相关数据的唯一、确定的事实来源。它包含要存储数据的基本字段和行为。也就是一个包含各种属性（数据）和方法（行为）的类。<br>比如说：<br>在民意调查应用中，我们将创建两个模型：Question和Choice。Question有一个问题和出版日期。Choice有两个字段：选择的文本和投票提示。每个Choice都与关联Question。</p><p>在<em>polls/models.py</em>文件中添加代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">class Question(models.Model):</span><br><span class="line">    question_text &#x3D; models.CharField(max_length&#x3D;200)</span><br><span class="line">    pub_date &#x3D; models.DateTimeField(&#39;date published&#39;)</span><br><span class="line">class Choice(models.Model):</span><br><span class="line">    question &#x3D; models.ForeignKey(Question, on_delete&#x3D;models.CASCADE)</span><br><span class="line">    choice_text &#x3D; models.CharField(max_length&#x3D;200)</span><br><span class="line">    votes &#x3D; models.IntegerField(default&#x3D;0)</span><br></pre></td></tr></table></figure><p>在这里，==每个模型都是django.db.models.Model的子类==。每个模型都有许多类变量，每个类变量代表模型中的数据库字段。==每一个字段都是一个Field的实例==，不同的Field代表了不同类型的数据。</p><h2 id="•-激活模型"><a href="#•-激活模型" class="headerlink" title="• 激活模型"></a>• 激活模型</h2><p>为了包含应用，需要将应用的引用添加在设置的INSTALLED_APPS中，也就是将<br>polls.apps.PollsConfig添加到INSTALLED_APPS中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS &#x3D; [</span><br><span class="line">    &#39;polls.apps.PollsConfig&#39;,</span><br><span class="line">    &#39;django.contrib.admin&#39;,</span><br><span class="line">    &#39;django.contrib.auth&#39;,</span><br><span class="line">    &#39;django.contrib.contenttypes&#39;,</span><br><span class="line">    &#39;django.contrib.sessions&#39;,</span><br><span class="line">    &#39;django.contrib.messages&#39;,</span><br><span class="line">    &#39;django.contrib.staticfiles&#39;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations polls</span><br></pre></td></tr></table></figure><p>表示对模型进行了一些修改，称之为<strong>迁移（migration）</strong>，会生成一个<em>polls/migrations/0001_initial.py</em>文件，可以进行人工编辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py sqlmigrate polls 0001</span><br></pre></td></tr></table></figure><p>可以看到SQL中，进行了那些迁移操作。</p><p><strong>注：</strong><br>1、数据表的名称是将应用名称和模型名称的小写组合起来自动生成的；<br>2、Django将附加”_id”到外键字段名称。<br>3、该sqlmigrate命令<strong>==实际上并未在数据库上运行迁移-而是将其打印到屏幕上==</strong>，以便您可以查看SQL Django认为需要的内容。这对于检查Django将要执行的操作或是否有需要SQL脚本进行更改的数据库管理员很有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py check</span><br></pre></td></tr></table></figure><p>检查项目中是否存在任何问题，而无需进行迁移或接触数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>获取所有尚未应用的迁移，并针对数据库来运行它们，实际上就是根据之前的修改来改变数据库。</p><p>模型更改的三步：<br>    <strong>• 更改模型（在<em>models.py</em>中）。<br>    • 运行为这些更改创建迁移 python manage.py makemigrations<br>    • 运行以将那些更改应用到数据库 python manage.py migrate</strong></p><p>Django Admin介绍<br>admin是作为网站管理员存在</p><h2 id="•-创建管理员用户"><a href="#•-创建管理员用户" class="headerlink" title="• 创建管理员用户"></a>• 创建管理员用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure><p>之后按提示信息输入内容（在输入密码的时候，可能会有密码无回显的情况，只需正常输入，不会有其他影响，我的环境是Python3.8+Django3.0）</p><p>然后运行服务器，输入<a href="http://127.0.0.1:8000/admin/" target="_blank" rel="noopener">http://127.0.0.1:8000/admin/</a><br>会显示管理员登录界面：<br><img src="https://img-blog.csdnimg.cn/20200115172844937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTc1OTI2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>注意这里输入的不是，这个网页出现的会是错误页面：<br><img src="https://img-blog.csdnimg.cn/20200115172852382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTc1OTI2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>修改<em>polls/admin.py</em>之后，应用就可以出现在管理员页面上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from .models import Question</span><br><span class="line">admin.site.register(Question)</span><br></pre></td></tr></table></figure><p>之后可以通过管理员界面对Question数据库进行修改。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-1</title>
      <link href="/2020/01/19/Django-1/"/>
      <url>/2020/01/19/Django-1/</url>
      
        <content type="html"><![CDATA[<h2 id="•-创建项目"><a href="#•-创建项目" class="headerlink" title="• 创建项目"></a>• 创建项目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django-admin startproject mysite</span><br></pre></td></tr></table></figure><p>创建了mysite目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysite&#x2F;</span><br><span class="line">    manage.py #一个命令行实用程序，可让您以各种方式与该Django项目进行交互。</span><br><span class="line">    mysite&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">        settings.py #此Django项目的设置&#x2F;配置。</span><br><span class="line">        urls.py #此Django项目的URL声明；Django支持的网站的“目录”。</span><br><span class="line">        asgi.py</span><br><span class="line">        wsgi.py</span><br></pre></td></tr></table></figure><h2 id="•-运行服务器"><a href="#•-运行服务器" class="headerlink" title="• 运行服务器"></a>• 运行服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python manage.py runserver</span><br></pre></td></tr></table></figure><p>在浏览器中搜索<a href="http://127.0.0.1:8000/，就能看到Django火箭：" target="_blank" rel="noopener">http://127.0.0.1:8000/，就能看到Django火箭：</a><br><img src="https://img-blog.csdnimg.cn/20200105125207937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTc1OTI2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="•-创建应用程序（polls应用）"><a href="#•-创建应用程序（polls应用）" class="headerlink" title="• 创建应用程序（polls应用）"></a>• 创建应用程序（polls应用）</h2><p>项目和应用之间有什么区别？<strong>应用程序是执行某项操作的Web应用程序</strong>，例如Weblog系统，公共记录数据库或小型民意调查应用程序。<strong>项目是特定网站的配置和应用程序的集合。一个项目可以包含多个应用程序。一个应用程序可以在多个项目中。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp polls</span><br></pre></td></tr></table></figure><p>创建了polls目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">polls&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    admin.py</span><br><span class="line">    apps.py</span><br><span class="line">    migrations&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">    models.py</span><br><span class="line">    tests.py</span><br><span class="line">    views.py</span><br></pre></td></tr></table></figure><h2 id="•-第一个视图函数"><a href="#•-第一个视图函数" class="headerlink" title="• 第一个视图函数"></a>• 第一个视图函数</h2><p>每一个请求的url地址，都对应着一个函数，叫视图函数，由视图函数处理请求后，再返回页面内容给浏览器显示。<br>在<strong>polls/views.py</strong>中添加代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">        Return HttpResponse(&quot;Hello,world.You&#39;reatthepollsindex.&quot;)</span><br></pre></td></tr></table></figure><h2 id="•-创建URL关系"><a href="#•-创建URL关系" class="headerlink" title="• 创建URL关系"></a>• 创建URL关系</h2><p>polls目录中创建URLconf，即创建一个urls.py文件，包含如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line"></span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns&#x3D;[</span><br><span class="line">path(&#39;&#39;,  views.index, name&#x3D;&#39;index&#39;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在项目之下的urls.py文件（mysite/urls.py）中加入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import include,path</span><br><span class="line"></span><br><span class="line">urlpatterns&#x3D;[</span><br><span class="line">path(&#39;polls&#x2F;&#39;,include(&#39;polls.urls&#39;)),</span><br><span class="line">path(&#39;admin&#x2F;&#39;,admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>重点：项目和应用之下urls.py文件的不同</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 项目下的urls.py</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    # 包含应用下的urls.py文件</span><br><span class="line">    url(正则表达式, include(&#39;应用名.urls&#39;))</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 应用下的urls.py</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line"> </span><br><span class="line">   # 该path()函数传递了四个参数，两个是必需的 route和view，</span><br><span class="line">   # 以及两个可选的kwargs和name。</span><br><span class="line">   path(route , view , kwargs , name),</span><br><span class="line">        # route：route是包含URL模式的字符串。在处理请求时，</span><br><span class="line">        # Django从第一个模式开始，urlpatterns然后沿列表向下移动，</span><br><span class="line">        # 将请求的URL与每个模式进行比较，直到找到匹配的URL。</span><br><span class="line">        # view：当Django找到匹配的模式时，使用HttpRequest对象作为第一个参数，</span><br><span class="line">        # 并将路线中所有“捕获的”值作为关键字参数，调用指定的view函数。</span><br><span class="line">        # name：命名URL可以使您在Django中的其他地方（尤其是在模板内部）</span><br><span class="line">        # 明确地引用它。这项强大的功能可让您仅触摸单个文件</span><br><span class="line">        # 即可对项目的URL模式进行全局更改。</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
