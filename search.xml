<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode/LeetCode-3</title>
      <link href="/2020/01/26/leetcode/LeetCode-3/"/>
      <url>/2020/01/26/leetcode/LeetCode-3/</url>
      
        <content type="html"><![CDATA[<h4 id="一、子问题"><a href="#一、子问题" class="headerlink" title="一、子问题"></a>一、子问题</h4><p>解决这道题之前，可以先思考一个重要的问题，就是<strong>给定的一段字符串，如何判断它是否有重复的字符。</strong><br>法一、容易想到的是遍历每一个字符，判断在它之后是否出现相同字符，时间复杂度o(n^2)。<br>法二、同LeetCode-1，<strong>用哈希表进行搜索加速</strong>：维护一个数组作为哈希表，初始化为0。遍历字符串，并将每个字符对应位置（eg：‘f’-‘a’ = 5，‘f’对应下标为5）置为1，如果该位置已经置1，那么就说明出现重复字符。这个方法只需要一次遍历，时间复杂度o(n)。</p><h4 id="二、问题思路"><a href="#二、问题思路" class="headerlink" title="二、问题思路"></a>二、问题思路</h4><p>解决子问题之后，我们知道可以用哈希表来进行加速。维护一个数组作为哈希表，<strong>初始化内容为-1</strong>（不初始化为0是因为之后哈希表中保存的会是字符下标），遍历整个字符串，将每一个字符对应位置保存当前字符的下标。遍历至下标n处，如果该位置对应哈希表内容为m（m != -1），则说明 <strong>[m,n) 是无重复字符子串，[m,n]会出现重复字符</strong>。计算当前无重复子串长度后，保存较大者。之后重置哈希表，再进行之后字符串的遍历。<br>这个方法也就是官方题解中的优化滑动窗口。</p><h4 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h4><pre><code class="cpp"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">char</span> * s)</span></span>{    <span class="keyword">int</span> from , to;  <span class="comment">//当前最长子串起止下标</span>    from = to = <span class="number">0</span>;    <span class="keyword">int</span> ans = <span class="number">0</span>;    <span class="keyword">int</span> hash[<span class="number">256</span>];  <span class="comment">//每个字符的键值对</span>    <span class="built_in">memset</span>(hash , <span class="number">-1</span> , <span class="keyword">sizeof</span>(hash));    <span class="keyword">while</span> (s[to] != <span class="string">'\0'</span>)    {        <span class="keyword">if</span> (hash[s[to]] == <span class="number">-1</span>)        {            hash[s[to]] = to;            to++;        }        <span class="keyword">else</span> <span class="keyword">if</span> (hash[s[to]] &lt; from)  <span class="comment">//重复的不是当前最长子串</span>        {            hash[s[to]] = to;            to++;        }        <span class="keyword">else</span>  <span class="comment">//当前最长子串出现重复，更新from的值为重复字符（前面的那个）位置加1</span>        {            ans = ans &gt; (to - from) ? ans : (to - from);            from = hash[s[to]] + <span class="number">1</span>;            hash[s[to]] = to;            to++;        }    }    ans = ans &gt; (to - from) ? ans : (to - from);    <span class="keyword">return</span> ans;}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-2</title>
      <link href="/2020/01/23/leetcode/LeetCode-2/"/>
      <url>/2020/01/23/leetcode/LeetCode-2/</url>
      
        <content type="html"><![CDATA[<h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>这个问题主要考察的是链表的操作和出现特殊情况的处理。<br>1、当两个链表一样长的时候，问题比较好处理，直接挨个相加即可；<br>2、当两个链表不一样的时候，就需要对遍历节点进行判断，不能出现再访问属性val的语句；<br>3、由于一条链有可能为空这种极端情况，所以不能简单的采用原地算法；<br>4、问题有一个小坑，就是有可能最后还有一位进位，对这个情况要考虑在内；<br>5、可以通过添加一个哑节点来减少代码；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode *scan1 = l1;</span><br><span class="line">        ListNode *scan2 = l2;</span><br><span class="line">        ListNode *head = new ListNode(<span class="number">0</span>);  //这是哑节点</span><br><span class="line">        ListNode *scan = head;</span><br><span class="line">        int flag = <span class="number">0</span>;  //标记进位</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (scan1 == NULL &amp;&amp; scan2 == NULL)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            int n1 = scan1!=NULL?scan1-&gt;val:0;</span><br><span class="line">            int n2 = scan2!=NULL?scan2-&gt;val:0;</span><br><span class="line">            scan-&gt;next = new ListNode((n1+n2+flag)%10);</span><br><span class="line">            flag = (n1+n2+flag)/<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (scan1 != NULL)</span><br><span class="line">                scan1 = scan1-&gt;next; </span><br><span class="line">            <span class="keyword">if</span> (scan2 != NULL)</span><br><span class="line">                scan2 = scan2-&gt;next;</span><br><span class="line">            scan = scan-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)  //如果最后还有进位</span><br><span class="line">            scan-&gt;next = new ListNode(1);</span><br><span class="line"></span><br><span class="line">        return head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(MAX{m,n})<br>空间复杂度：O(MAX{m,n})</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-1</title>
      <link href="/2020/01/23/leetcode/LeetCode-1/"/>
      <url>/2020/01/23/leetcode/LeetCode-1/</url>
      
        <content type="html"><![CDATA[<p>问题可以转换为，已有一个ele（为数组中的任意元素），需要在数组中寻找另一个元素等于target-ele</p><h3 id="1、暴力遍历法"><a href="#1、暴力遍历法" class="headerlink" title="1、暴力遍历法"></a>1、暴力遍历法</h3><p>最直观的想法遍历每一个元素，再对该元素进行遍历，查看是否有满足条件的其他元素，使得他们两的加和为target。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span> ; i &lt; nums.size() ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int j = i+<span class="number">1</span> ; j &lt; nums.size() ; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i]+nums[j] == target)</span><br><span class="line">                    <span class="keyword">return</span> &#123;i , j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span> , <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="2、一遍hash"><a href="#2、一遍hash" class="headerlink" title="2、一遍hash"></a>2、一遍hash</h3><p>这个方法的想法主要是利用哈希表来进行查找加速。<br>遍历数组元素ele，将ele放入哈希表中（ele值作为外键，ele下标作为內键），同时判断target-ele是否在哈希表中：<br>如果在，那么搜索结束，直接返回；<br>如果不在，继续遍历，直到结尾；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        map&lt;int, int&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span> ; i &lt; nums.size() ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.count(target-nums[i]) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;m[target-nums[i]] , i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-3</title>
      <link href="/2020/01/22/Django/Django-3/"/>
      <url>/2020/01/22/Django/Django-3/</url>
      
        <content type="html"><![CDATA[<h2 id="•-视图"><a href="#•-视图" class="headerlink" title="• 视图"></a>• 视图</h2><p><strong>视图其实是视图函数的简称</strong>，视图是Django应用程序中网页的“类型”，通常具有特定功能并具有特定模板。<br>在Django中，网页和其他内容是通过视图传递的。每个视图均由Python函数（或方法（对于基于类的视图而言））表示。Django将通过检查所请求的URL（准确地说，是域名之后的URL部分）来选择视图。</p><h2 id="•-URL"><a href="#•-URL" class="headerlink" title="• URL"></a>• URL</h2><p><strong>URL即统一资源定位符</strong>，是每一个信息资源都有统一的且在网上唯一的地址。<br><strong>URLconfs即URL模式</strong>，是URL的一般形式Django提供了更加优雅的URL模式，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/newsarchive/<span class="tag">&lt;<span class="name">year</span>&gt;</span>/<span class="tag">&lt;<span class="name">month</span>&gt;</span>/</span><br></pre></td></tr></table></figure><h2 id="•-添加更多的视图"><a href="#•-添加更多的视图" class="headerlink" title="• 添加更多的视图"></a>• 添加更多的视图</h2><p>更改<em>views.py</em>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"You're looking at question %s."</span> % question_id)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">results</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    response = <span class="string">"You're looking at the results of question %s."</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(response % question_id)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"You're voting on question %s."</span> % question_id)</span><br></pre></td></tr></table></figure><p>并更改<em>polls.urls.py</em>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># ex: /polls/</span></span><br><span class="line">    path(<span class="string">''</span>, views.index, name=<span class="string">'index'</span>),</span><br><span class="line">    <span class="comment"># ex: /polls/5/</span></span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/'</span>, views.detail, name=<span class="string">'detail'</span>),</span><br><span class="line">    <span class="comment"># ex: /polls/5/results/</span></span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/results/'</span>, views.results, name=<span class="string">'results'</span>),</span><br><span class="line">    <span class="comment"># ex: /polls/5/vote/</span></span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/vote/'</span>, views.vote, name=<span class="string">'vote'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>根据输入的URL地址，<strong>通过遍历的方式寻找匹配的URL模式串</strong>，并调用相对应的视图函数，相应相对应的网页。<br>比如说，当有人从网站请求页面时，例如“ / polls / 34 /”，Django将加载<em>mysite.urls</em>的Python模块，因为该<em>ROOT_URLCONF</em>设置指向该模块 。它找到名为的变量urlpatterns并按顺序遍历模式。在找到匹配项之后’polls/‘，它将剥离匹配的文本（”polls/“），并将其余文本–发送 “34/“到’polls.urls’URLconf进行进一步处理。在那里匹配’<a href="int:question_id">int:question_id</a>/‘，从而导致对detail()视图的调用，如下所示：<br>detail(request=<HttpRequest object>, question_id=34)</p><h2 id="•-编写更强大的视图"><a href="#•-编写更强大的视图" class="headerlink" title="• 编写更强大的视图"></a>• 编写更强大的视图</h2><p>每个视图负责执行以下两项操作之一：<strong>返回HttpResponse包含所请求页面内容的对象，或者引发诸如之类的异常Http404</strong>。<br>HttpResponse需要自己对其进行填充，而HttpRequest是Django自己生成。<br>视图可以从数据库中读取记录，也可以使用Django等模板系统，也可以不使用第三方Python模板系统。它还可以使用所需的任何Python库生成PDF文件，输出XML，或即时创建ZIP文件。<br>在<em>view.py</em>添加代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    latest_question_list = Question.objects.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br><span class="line">    output = <span class="string">', '</span>.join([q.question_text <span class="keyword">for</span> q <span class="keyword">in</span> latest_question_list])</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(output)</span><br><span class="line">    <span class="comment"># Leave the rest of the views (detail, results, vote) unchanged</span></span><br></pre></td></tr></table></figure><h2 id="•-将模板与视图创建的硬编码分开"><a href="#•-将模板与视图创建的硬编码分开" class="headerlink" title="• 将模板与视图创建的硬编码分开"></a>• 将模板与视图创建的硬编码分开</h2><p>首先，在目录templates中创建一个polls目录。Django将在那里寻找模板。<br>您的项目TEMPLATES置描述了Django如何加载和呈现模板。默认设置文件配置一个DjangoTemplates 后端，其APP_DIRS选项设置为 True。按照惯例DjangoTemplates，在每个文件夹中都会寻找一个“模板”子目录INSTALLED_APPS。<br>在<em>polls/templates/polls/</em>添加一个模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if latest_question_list %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for question in latest_question_list %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/polls/&#123;&#123; question.id &#125;&#125;/"</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>No polls are available.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>现在运行服务器之后，可以子项/polls来加载一个“最新消息”列表。</p><h2 id="•-快捷方式"><a href="#•-快捷方式" class="headerlink" title="• 快捷方式"></a>• 快捷方式</h2><p>加载模板，填充上下文并使用渲染后的模板的结果返回对象HttpResponse是一种非常常见的用法。<br>同时，Django提供了一种快捷方式。重写index()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    latest_question_list = Question.objects.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br><span class="line">    context = &#123;<span class="string">'latest_question_list'</span>: latest_question_list&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'polls/index.html'</span>, context)</span><br></pre></td></tr></table></figure><p>该render()函数将<strong>请求对象作为其第一个参数，将模板名称作为其第二个参数，并将字典作为其可选的第三个参数</strong>。它返回使用HttpResponse 给定上下文呈现的给定模板的对象。</p><h2 id="•-404错误"><a href="#•-404错误" class="headerlink" title="• 404错误"></a>• 404错误</h2><p>在<em>views.py</em>中添加代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        question = Question.objects.get(pk=question_id)</span><br><span class="line">    <span class="keyword">except</span> Question.DoesNotExist:</span><br><span class="line">        <span class="keyword">raise</span> Http404(<span class="string">"Question does not exist"</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'polls/detail.html'</span>, &#123;<span class="string">'question'</span>: question&#125;)</span><br></pre></td></tr></table></figure><p>为了快速使示例正常工作，对应模板<em>polls/templates/polls/detail.html</em><br>中只添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; question &#125;&#125;</span><br></pre></td></tr></table></figure><p>现在运行服务器，可以看到更完整的polls网页  </p><h2 id="•-404的快捷方式"><a href="#•-404的快捷方式" class="headerlink" title="• 404的快捷方式"></a>• 404的快捷方式</h2><p>重写detail()函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'polls/detail.html'</span>, &#123;<span class="string">'question'</span>: question&#125;)</span><br></pre></td></tr></table></figure><h2 id="•-使用模板系统"><a href="#•-使用模板系统" class="headerlink" title="• 使用模板系统"></a>• 使用模板系统</h2><p><em>polls/detail.html</em>改写为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; choice.choice_text &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模板系统使用点查找语法来访问变量属性。在的示例中，首先Django在对象上进行字典查找。如果失败，它将尝试属性查找-在这种情况下可以工作。如果属性查找失败，它将尝试进行列表索引查找。</p><h2 id="•-命名空间URL名称"><a href="#•-命名空间URL名称" class="headerlink" title="• 命名空间URL名称"></a>• 命名空间URL名称</h2><p>在实际的Django项目中，可能有很多个应用程序，Django如何区分它们之间的URL名称呢？答案是将名称空间添加到URLconf中。<br>在polls/urls.py中添加app_name以设置为应用程序名称空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> pat</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">app_name = <span class="string">'polls'</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>, views.index, name=<span class="string">'index'</span>),</span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/'</span>, views.detail, name=<span class="string">'detail'</span>),</span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/results/'</span>, views.results, name=<span class="string">'results'</span>),</span><br><span class="line">    path(<span class="string">'&lt;int:question_id&gt;/vote/'</span>, views.vote, name=<span class="string">'vote'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样可以区分多个应用程序的URL名称。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-2</title>
      <link href="/2020/01/19/Django/Django-2/"/>
      <url>/2020/01/19/Django/Django-2/</url>
      
        <content type="html"><![CDATA[<h2 id="•-数据库设置"><a href="#•-数据库设置" class="headerlink" title="• 数据库设置"></a>• 数据库设置</h2><p>默认使用SQLite，相关的设置都在<em>setting.py</em>文件中进行。</p><p><em>setting,py</em>中还有其他设置：<br>INSTALLED_APPS文件顶部的设置。该名称包含在此Django实例中激活的所有Django应用程序的名称。其中包含一些默认的应用程序。不需要时可以在INSTALLED_APPS中删去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>该migrate命令将查看该INSTALLED_APPS设置，并根据<em>mysite/settings.py</em>文件中的数据库设置以及应用程序随附的数据库迁移来创建任何必要的数据库表。</p><h2 id="•-创建模型"><a href="#•-创建模型" class="headerlink" title="• 创建模型"></a>• 创建模型</h2><p>模型是相关数据的唯一、确定的事实来源。它包含要存储数据的基本字段和行为。也就是一个包含各种属性（数据）和方法（行为）的类。<br>比如说：<br>在民意调查应用中，我们将创建两个模型：Question和Choice。Question有一个问题和出版日期。Choice有两个字段：选择的文本和投票提示。每个Choice都与关联Question。</p><p>在<em>polls/models.py</em>文件中添加代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">class Question(models.Model):</span><br><span class="line">    question_text &#x3D; models.CharField(max_length&#x3D;200)</span><br><span class="line">    pub_date &#x3D; models.DateTimeField(&#39;date published&#39;)</span><br><span class="line">class Choice(models.Model):</span><br><span class="line">    question &#x3D; models.ForeignKey(Question, on_delete&#x3D;models.CASCADE)</span><br><span class="line">    choice_text &#x3D; models.CharField(max_length&#x3D;200)</span><br><span class="line">    votes &#x3D; models.IntegerField(default&#x3D;0)</span><br></pre></td></tr></table></figure><p>在这里，==每个模型都是django.db.models.Model的子类==。每个模型都有许多类变量，每个类变量代表模型中的数据库字段。==每一个字段都是一个Field的实例==，不同的Field代表了不同类型的数据。</p><h2 id="•-激活模型"><a href="#•-激活模型" class="headerlink" title="• 激活模型"></a>• 激活模型</h2><p>为了包含应用，需要将应用的引用添加在设置的INSTALLED_APPS中，也就是将<br>polls.apps.PollsConfig添加到INSTALLED_APPS中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS &#x3D; [</span><br><span class="line">    &#39;polls.apps.PollsConfig&#39;,</span><br><span class="line">    &#39;django.contrib.admin&#39;,</span><br><span class="line">    &#39;django.contrib.auth&#39;,</span><br><span class="line">    &#39;django.contrib.contenttypes&#39;,</span><br><span class="line">    &#39;django.contrib.sessions&#39;,</span><br><span class="line">    &#39;django.contrib.messages&#39;,</span><br><span class="line">    &#39;django.contrib.staticfiles&#39;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations polls</span><br></pre></td></tr></table></figure><p>表示对模型进行了一些修改，称之为<strong>迁移（migration）</strong>，会生成一个<em>polls/migrations/0001_initial.py</em>文件，可以进行人工编辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py sqlmigrate polls 0001</span><br></pre></td></tr></table></figure><p>可以看到SQL中，进行了那些迁移操作。</p><p><strong>注：</strong><br>1、数据表的名称是将应用名称和模型名称的小写组合起来自动生成的；<br>2、Django将附加”_id”到外键字段名称。<br>3、该sqlmigrate命令<strong>==实际上并未在数据库上运行迁移-而是将其打印到屏幕上==</strong>，以便您可以查看SQL Django认为需要的内容。这对于检查Django将要执行的操作或是否有需要SQL脚本进行更改的数据库管理员很有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py check</span><br></pre></td></tr></table></figure><p>检查项目中是否存在任何问题，而无需进行迁移或接触数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>获取所有尚未应用的迁移，并针对数据库来运行它们，实际上就是根据之前的修改来改变数据库。</p><p>模型更改的三步：<br>    <strong>• 更改模型（在<em>models.py</em>中）。<br>    • 运行为这些更改创建迁移 python manage.py makemigrations<br>    • 运行以将那些更改应用到数据库 python manage.py migrate</strong></p><p>Django Admin介绍<br>admin是作为网站管理员存在</p><h2 id="•-创建管理员用户"><a href="#•-创建管理员用户" class="headerlink" title="• 创建管理员用户"></a>• 创建管理员用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure><p>之后按提示信息输入内容（在输入密码的时候，可能会有密码无回显的情况，只需正常输入，不会有其他影响，我的环境是Python3.8+Django3.0）</p><p>然后运行服务器，输入<a href="http://127.0.0.1:8000/admin/" target="_blank" rel="noopener">http://127.0.0.1:8000/admin/</a><br>会显示管理员登录界面：<br><img src="https://img-blog.csdnimg.cn/20200115172844937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTc1OTI2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>注意这里输入的不是，这个网页出现的会是错误页面：<br><img src="https://img-blog.csdnimg.cn/20200115172852382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTc1OTI2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>修改<em>polls/admin.py</em>之后，应用就可以出现在管理员页面上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from .models import Question</span><br><span class="line">admin.site.register(Question)</span><br></pre></td></tr></table></figure><p>之后可以通过管理员界面对Question数据库进行修改。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-1</title>
      <link href="/2020/01/19/Django/Django-1/"/>
      <url>/2020/01/19/Django/Django-1/</url>
      
        <content type="html"><![CDATA[<h2 id="•-创建项目"><a href="#•-创建项目" class="headerlink" title="• 创建项目"></a>• 创建项目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django-admin startproject mysite</span><br></pre></td></tr></table></figure><p>创建了mysite目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysite&#x2F;</span><br><span class="line">    manage.py #一个命令行实用程序，可让您以各种方式与该Django项目进行交互。</span><br><span class="line">    mysite&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">        settings.py #此Django项目的设置&#x2F;配置。</span><br><span class="line">        urls.py #此Django项目的URL声明；Django支持的网站的“目录”。</span><br><span class="line">        asgi.py</span><br><span class="line">        wsgi.py</span><br></pre></td></tr></table></figure><h2 id="•-运行服务器"><a href="#•-运行服务器" class="headerlink" title="• 运行服务器"></a>• 运行服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python manage.py runserver</span><br></pre></td></tr></table></figure><p>在浏览器中搜索<a href="http://127.0.0.1:8000/，就能看到Django火箭：" target="_blank" rel="noopener">http://127.0.0.1:8000/，就能看到Django火箭：</a><br><img src="https://img-blog.csdnimg.cn/20200105125207937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTc1OTI2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="•-创建应用程序（polls应用）"><a href="#•-创建应用程序（polls应用）" class="headerlink" title="• 创建应用程序（polls应用）"></a>• 创建应用程序（polls应用）</h2><p>项目和应用之间有什么区别？<strong>应用程序是执行某项操作的Web应用程序</strong>，例如Weblog系统，公共记录数据库或小型民意调查应用程序。<strong>项目是特定网站的配置和应用程序的集合。一个项目可以包含多个应用程序。一个应用程序可以在多个项目中。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp polls</span><br></pre></td></tr></table></figure><p>创建了polls目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">polls&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    admin.py</span><br><span class="line">    apps.py</span><br><span class="line">    migrations&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">    models.py</span><br><span class="line">    tests.py</span><br><span class="line">    views.py</span><br></pre></td></tr></table></figure><h2 id="•-第一个视图函数"><a href="#•-第一个视图函数" class="headerlink" title="• 第一个视图函数"></a>• 第一个视图函数</h2><p>每一个请求的url地址，都对应着一个函数，叫视图函数，由视图函数处理请求后，再返回页面内容给浏览器显示。<br>在<strong>polls/views.py</strong>中添加代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">        Return HttpResponse(&quot;Hello,world.You&#39;reatthepollsindex.&quot;)</span><br></pre></td></tr></table></figure><h2 id="•-创建URL关系"><a href="#•-创建URL关系" class="headerlink" title="• 创建URL关系"></a>• 创建URL关系</h2><p>polls目录中创建URLconf，即创建一个urls.py文件，包含如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line"></span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns&#x3D;[</span><br><span class="line">path(&#39;&#39;,  views.index, name&#x3D;&#39;index&#39;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在项目之下的urls.py文件（mysite/urls.py）中加入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import include,path</span><br><span class="line"></span><br><span class="line">urlpatterns&#x3D;[</span><br><span class="line">path(&#39;polls&#x2F;&#39;,include(&#39;polls.urls&#39;)),</span><br><span class="line">path(&#39;admin&#x2F;&#39;,admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>重点：项目和应用之下urls.py文件的不同</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 项目下的urls.py</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    # 包含应用下的urls.py文件</span><br><span class="line">    url(正则表达式, include(&#39;应用名.urls&#39;))</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 应用下的urls.py</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line"> </span><br><span class="line">   # 该path()函数传递了四个参数，两个是必需的 route和view，</span><br><span class="line">   # 以及两个可选的kwargs和name。</span><br><span class="line">   path(route , view , kwargs , name),</span><br><span class="line">        # route：route是包含URL模式的字符串。在处理请求时，</span><br><span class="line">        # Django从第一个模式开始，urlpatterns然后沿列表向下移动，</span><br><span class="line">        # 将请求的URL与每个模式进行比较，直到找到匹配的URL。</span><br><span class="line">        # view：当Django找到匹配的模式时，使用HttpRequest对象作为第一个参数，</span><br><span class="line">        # 并将路线中所有“捕获的”值作为关键字参数，调用指定的view函数。</span><br><span class="line">        # name：命名URL可以使您在Django中的其他地方（尤其是在模板内部）</span><br><span class="line">        # 明确地引用它。这项强大的功能可让您仅触摸单个文件</span><br><span class="line">        # 即可对项目的URL模式进行全局更改。</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
